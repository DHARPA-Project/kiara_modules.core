{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara modules for: core \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 TODO Package content \u00b6 Value types \u00b6 array : An Apache arrow array. boolean : A boolean. bytes : An array of bytes. database : A database, containing one or several tables. date : A date. dict : A dict-like object. file : A representation of a file. file_bundle : A representation of a set of files (folder, archive, etc.). float : A float. integer : An integer. list : A list-like object. renderables : A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. string : A string. table : A table. Modules \u00b6 array.map : Map a list of values into another list of values. array.metadata : Extract metadata from an 'array' value. array.sample : Sample an array. array.store : Save an Arrow array to a file. bytes.load : -- n/a -- bytes.msgpack.from_value : -- n/a -- bytes.msgpack.to_value : -- n/a -- bytes.store : -- n/a -- database.create : Create a database from files, file_bundles, etc. database.export_network_data : -- n/a -- database.info : Extract extended metadata (like tables, schemas) from a database object. database.load : -- n/a -- database.metadata : Extract basic metadata from a database object. database.query.sql : Execute a sql query against an (Arrow) table. database.store : Save an sqlite database to a file. date.extract_from_string : Extract a date object from a string. date.range_check : Check whether a date falls within a specified date range. dev.dummy : Module that simulates processing, but uses hard-coded outputs as a result. dict.store : -- n/a -- file.import : Import an external file into a kiara session. file.load : Load a file and its metadata. file.metadata : -- n/a -- file.store : Save a file to disk. file_bundle.import : Import a file bundle into the kiara data store. file_bundle.load : Load a file bundle and its metadata. file_bundle.metadata : -- n/a -- file_bundle.store : Save a file bundle to disk. generic.restore_from_json : -- n/a -- generic.restore_scalar : Utility module, only used internally. generic.store : -- n/a -- json.to_json : Convert arbitrary types into json. list.contains : Check whether an element is in a list. list.store : -- n/a -- logic.and : Returns 'True' if both inputs are 'True'. logic.not : Negates the input. logic.or : Returns 'True' if one of the inputs is 'True'. string.deserialize : -- n/a -- string.match_regex : Match a string using a regular expression. string.replace : Replace a string if it matches a key in a mapping dictionary. string.serialize : -- n/a -- table.create : Create an Arrow table from files, file_bundles, etc. table.cut_column : Cut off one column from a table, returning an array. table.export : Export a table object to disk. table.export_table : -- n/a -- table.filter.with_mask : Filter a table using a mask array. table.load : Load a table object from disk. table.map_column : Map the items of one column of a table onto an array, using another module. table.merge : Create a table from other tables and/or arrays. table.metadata : Extract metadata from a table object. table.query.graphql : Execute a graphql aggregation query against an (Arrow) table. table.query.sql : Execute a sql query against an (Arrow) table. table.sample : Sample a table. table.store : -- n/a -- value.data_profile : Generate a data profile report for a dataset. yaml.to_yaml : Convert arbitrary types into YAML format. Pipelines \u00b6 array.restore : Load a column from a table object, returning an array. logic.nand : Returns 'False' if both inputs are 'True'. logic.nor : Returns 'True' if both inputs are 'False'. logic.xor : Returns 'True' if exactly one of it's two inputs is 'True'. table.filter.by_date : Filter a table by a date or date range. Operation types \u00b6 kiara_modules.core.operations.DataProfileOperationType : -- n/a -- Links \u00b6 Documentation: https://dharpa.org/kiara_modules.core Code: https://github.com/DHARPA-Project/kiara_modules.core","title":"Home"},{"location":"#kiara-modules-for-core","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara modules for: core"},{"location":"#description","text":"TODO","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#value-types","text":"array : An Apache arrow array. boolean : A boolean. bytes : An array of bytes. database : A database, containing one or several tables. date : A date. dict : A dict-like object. file : A representation of a file. file_bundle : A representation of a set of files (folder, archive, etc.). float : A float. integer : An integer. list : A list-like object. renderables : A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. string : A string. table : A table.","title":"Value types"},{"location":"#modules","text":"array.map : Map a list of values into another list of values. array.metadata : Extract metadata from an 'array' value. array.sample : Sample an array. array.store : Save an Arrow array to a file. bytes.load : -- n/a -- bytes.msgpack.from_value : -- n/a -- bytes.msgpack.to_value : -- n/a -- bytes.store : -- n/a -- database.create : Create a database from files, file_bundles, etc. database.export_network_data : -- n/a -- database.info : Extract extended metadata (like tables, schemas) from a database object. database.load : -- n/a -- database.metadata : Extract basic metadata from a database object. database.query.sql : Execute a sql query against an (Arrow) table. database.store : Save an sqlite database to a file. date.extract_from_string : Extract a date object from a string. date.range_check : Check whether a date falls within a specified date range. dev.dummy : Module that simulates processing, but uses hard-coded outputs as a result. dict.store : -- n/a -- file.import : Import an external file into a kiara session. file.load : Load a file and its metadata. file.metadata : -- n/a -- file.store : Save a file to disk. file_bundle.import : Import a file bundle into the kiara data store. file_bundle.load : Load a file bundle and its metadata. file_bundle.metadata : -- n/a -- file_bundle.store : Save a file bundle to disk. generic.restore_from_json : -- n/a -- generic.restore_scalar : Utility module, only used internally. generic.store : -- n/a -- json.to_json : Convert arbitrary types into json. list.contains : Check whether an element is in a list. list.store : -- n/a -- logic.and : Returns 'True' if both inputs are 'True'. logic.not : Negates the input. logic.or : Returns 'True' if one of the inputs is 'True'. string.deserialize : -- n/a -- string.match_regex : Match a string using a regular expression. string.replace : Replace a string if it matches a key in a mapping dictionary. string.serialize : -- n/a -- table.create : Create an Arrow table from files, file_bundles, etc. table.cut_column : Cut off one column from a table, returning an array. table.export : Export a table object to disk. table.export_table : -- n/a -- table.filter.with_mask : Filter a table using a mask array. table.load : Load a table object from disk. table.map_column : Map the items of one column of a table onto an array, using another module. table.merge : Create a table from other tables and/or arrays. table.metadata : Extract metadata from a table object. table.query.graphql : Execute a graphql aggregation query against an (Arrow) table. table.query.sql : Execute a sql query against an (Arrow) table. table.sample : Sample a table. table.store : -- n/a -- value.data_profile : Generate a data profile report for a dataset. yaml.to_yaml : Convert arbitrary types into YAML format.","title":"Modules"},{"location":"#pipelines","text":"array.restore : Load a column from a table object, returning an array. logic.nand : Returns 'False' if both inputs are 'True'. logic.nor : Returns 'True' if both inputs are 'False'. logic.xor : Returns 'True' if exactly one of it's two inputs is 'True'. table.filter.by_date : Filter a table by a date or date range.","title":"Pipelines"},{"location":"#operation-types","text":"kiara_modules.core.operations.DataProfileOperationType : -- n/a --","title":"Operation types"},{"location":"#links","text":"Documentation: https://dharpa.org/kiara_modules.core Code: https://github.com/DHARPA-Project/kiara_modules.core","title":"Links"},{"location":"SUMMARY/","text":"Home Usage Development Value types Modules Pipelines Operation types API docs","title":"SUMMARY"},{"location":"usage/","text":"Usage \u00b6","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"modules/","text":"xxxxxxx","title":"Index"},{"location":"modules/SUMMARY/","text":"array bytes load msgpack store database create export_network_data info load metadata query store date dev dict file file_bundle generic json list logic string table create cut_column export export_table filter load map_column merge metadata query sample store value yaml","title":"SUMMARY"},{"location":"modules/array/","text":"array.map \u00b6 Documentation Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another kiara module. This 'child' module will then be used to compute the array items of the result. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. module_type string The name of the yes kiara module to use to filter the input data. module_config object The config for no the kiara filter module. input_name string The name of the no input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input. output_name string The name of the no output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. Module config -- no config -- Python class class_name MapModule module_name kiara_modules.core.array full_name kiara_modules.core.array.MapModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa input_array: pa . Array = inputs . get_value_data( \u2026 init_data: typing . Dict[str, typing . Any] = {} for input_name in self . input_schemas . keys(): if input_name in [ \"array\" , self . module_inp\u2026 continue init_data[input_name] = inputs . get_value_o\u2026 result_list = map_with_module( input_array, module_input_name = self . module_input_name, module_obj = self . child_module, init_data = init_data, module_output_name = self . module_output_name, ) outputs . set_value( \"array\" , pa . array(result_lis\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 array.metadata \u00b6 Documentation Extract metadata from an 'array' value. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name ArrayMetadataModule module_name kiara_modules.core.array full_name kiara_modules.core.array.ArrayMetada\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 array.sample \u00b6 Documentation Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. sample_type string The sample yes method. Module config -- no config -- Python class class_name SampleArrayModule module_name kiara_modules.core.array full_name kiara_modules.core.array.SampleArray\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 sample_size: int = inputs . get_value_data( \"samp\u2026 sample_type: str = self . get_config_value( \"samp\u2026 if sample_size < 0 : raise KiaraProcessingException( f\"Invalid sample size '{ sample_size }':\u2026 ) input_name = self . get_value_type() if input_name == \"any\" : input_name = \"value_item\" value: Value = inputs . get_value_obj(input_name) func = getattr(self, f\"sample_{ sample_type }\" ) result = func(value = value, sample_size = sample_\u2026 outputs . set_value( \"sampled_value\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 array.store \u00b6 Documentation Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with kira to re-assemble the array object from disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreArrayTypeModule module_name kiara_modules.core.array full_name kiara_modules.core.array.StoreArrayT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"array"},{"location":"modules/array/#kiara_info.modules.array.map","text":"Documentation Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another kiara module. This 'child' module will then be used to compute the array items of the result. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. module_type string The name of the yes kiara module to use to filter the input data. module_config object The config for no the kiara filter module. input_name string The name of the no input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input. output_name string The name of the no output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. Module config -- no config -- Python class class_name MapModule module_name kiara_modules.core.array full_name kiara_modules.core.array.MapModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa input_array: pa . Array = inputs . get_value_data( \u2026 init_data: typing . Dict[str, typing . Any] = {} for input_name in self . input_schemas . keys(): if input_name in [ \"array\" , self . module_inp\u2026 continue init_data[input_name] = inputs . get_value_o\u2026 result_list = map_with_module( input_array, module_input_name = self . module_input_name, module_obj = self . child_module, init_data = init_data, module_output_name = self . module_output_name, ) outputs . set_value( \"array\" , pa . array(result_lis\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"array.map"},{"location":"modules/array/#kiara_info.modules.array.metadata","text":"Documentation Extract metadata from an 'array' value. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name ArrayMetadataModule module_name kiara_modules.core.array full_name kiara_modules.core.array.ArrayMetada\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"array.metadata"},{"location":"modules/array/#kiara_info.modules.array.sample","text":"Documentation Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. sample_type string The sample yes method. Module config -- no config -- Python class class_name SampleArrayModule module_name kiara_modules.core.array full_name kiara_modules.core.array.SampleArray\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 sample_size: int = inputs . get_value_data( \"samp\u2026 sample_type: str = self . get_config_value( \"samp\u2026 if sample_size < 0 : raise KiaraProcessingException( f\"Invalid sample size '{ sample_size }':\u2026 ) input_name = self . get_value_type() if input_name == \"any\" : input_name = \"value_item\" value: Value = inputs . get_value_obj(input_name) func = getattr(self, f\"sample_{ sample_type }\" ) result = func(value = value, sample_size = sample_\u2026 outputs . set_value( \"sampled_value\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"array.sample"},{"location":"modules/array/#kiara_info.modules.array.store","text":"Documentation Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with kira to re-assemble the array object from disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, array Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreArrayTypeModule module_name kiara_modules.core.array full_name kiara_modules.core.array.StoreArrayT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"array.store"},{"location":"modules/bytes/","text":"","title":"bytes"},{"location":"modules/bytes/load/","text":"bytes.load \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadBytesModule module_name kiara_modules.core.bytes full_name kiara_modules.core.bytes.LoadBytesMo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 path = inputs . get_value_data( \"path\" ) if not os . path . exists(path): raise KiaraProcessingException( f\"Can't read file, path does not exist\u2026 ) with open(path, \"rb\" ) as f: content = f . read() outputs . set_value( \"bytes\" , content) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"load"},{"location":"modules/bytes/load/#kiara_info.modules.bytes.load","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadBytesModule module_name kiara_modules.core.bytes full_name kiara_modules.core.bytes.LoadBytesMo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 path = inputs . get_value_data( \"path\" ) if not os . path . exists(path): raise KiaraProcessingException( f\"Can't read file, path does not exist\u2026 ) with open(path, \"rb\" ) as f: content = f . read() outputs . set_value( \"bytes\" , content) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"bytes.load"},{"location":"modules/bytes/msgpack/","text":"bytes.msgpack.from_value \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, msgpack, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type to yes serialize/deseria\u2026 Module config -- no config -- Python class class_name SerializeToMsgPackModule module_name kiara_modules.core.bytes.msgpack full_name kiara_modules.core.bytes.msgpack.Ser\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import msgpack type_name: str = self . get_config_value( \"value_\u2026 if not hasattr(self, f\"from_{ type_name }\" ): raise KiaraProcessingException( f\"Value type not supported for msgpack\u2026 ) func = getattr(self, f\"from_{ type_name }\" ) value = inputs . get_value_obj( \"value_item\" ) metadata = value . get_metadata(also_return_sche\u2026 msg = func(value = value) data = { \"value_type\" : value . type_name, \"metada\u2026 msg = msgpack . packb(data, use_bin_type = True ) outputs . set_value( \"bytes\" , msg) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 bytes.msgpack.to_value \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, msgpack, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type to yes serialize/deseria\u2026 Module config -- no config -- Python class class_name DeserializeFromMsgPackModule module_name kiara_modules.core.bytes.msgpack full_name kiara_modules.core.bytes.msgpack.Des\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import msgpack msg = inputs . get_value_data( \"bytes\" ) unpacked = msgpack . unpackb(msg, raw = False ) value_type = unpacked[ \"value_type\" ] outputs . set_value( \"value_type\" , value_type) metadata = unpacked[ \"metadata\" ] outputs . set_value( \"value_metadata\" , metadata) new_data = unpacked[ \"data\" ] if not hasattr(self, f\"to_{ value_type }\" ): raise KiaraProcessingException( f\"Value type not supported for msgpack\u2026 ) func = getattr(self, f\"to_{ value_type }\" ) obj = func(data = new_data) outputs . set_value( \"value_data\" , obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"msgpack"},{"location":"modules/bytes/msgpack/#kiara_info.modules.bytes.msgpack.from_value","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, msgpack, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type to yes serialize/deseria\u2026 Module config -- no config -- Python class class_name SerializeToMsgPackModule module_name kiara_modules.core.bytes.msgpack full_name kiara_modules.core.bytes.msgpack.Ser\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import msgpack type_name: str = self . get_config_value( \"value_\u2026 if not hasattr(self, f\"from_{ type_name }\" ): raise KiaraProcessingException( f\"Value type not supported for msgpack\u2026 ) func = getattr(self, f\"from_{ type_name }\" ) value = inputs . get_value_obj( \"value_item\" ) metadata = value . get_metadata(also_return_sche\u2026 msg = func(value = value) data = { \"value_type\" : value . type_name, \"metada\u2026 msg = msgpack . packb(data, use_bin_type = True ) outputs . set_value( \"bytes\" , msg) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"bytes.msgpack.from_value"},{"location":"modules/bytes/msgpack/#kiara_info.modules.bytes.msgpack.to_value","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, msgpack, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type to yes serialize/deseria\u2026 Module config -- no config -- Python class class_name DeserializeFromMsgPackModule module_name kiara_modules.core.bytes.msgpack full_name kiara_modules.core.bytes.msgpack.Des\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import msgpack msg = inputs . get_value_data( \"bytes\" ) unpacked = msgpack . unpackb(msg, raw = False ) value_type = unpacked[ \"value_type\" ] outputs . set_value( \"value_type\" , value_type) metadata = unpacked[ \"metadata\" ] outputs . set_value( \"value_metadata\" , metadata) new_data = unpacked[ \"data\" ] if not hasattr(self, f\"to_{ value_type }\" ): raise KiaraProcessingException( f\"Value type not supported for msgpack\u2026 ) func = getattr(self, f\"to_{ value_type }\" ) obj = func(data = new_data) outputs . set_value( \"value_data\" , obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"bytes.msgpack.to_value"},{"location":"modules/bytes/store/","text":"bytes.store \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreBytesTypeModule module_name kiara_modules.core.bytes full_name kiara_modules.core.bytes.StoreBytesT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"store"},{"location":"modules/bytes/store/#kiara_info.modules.bytes.store","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core, bytes, serialization Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreBytesTypeModule module_name kiara_modules.core.bytes full_name kiara_modules.core.bytes.StoreBytesT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"bytes.store"},{"location":"modules/database/","text":"","title":"database"},{"location":"modules/database/create/","text":"database.create \u00b6 Documentation Create a database from files, file_bundles, etc. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. ignore_errors boolean Whether to no ignore convert errors and omit the failed items. Module config -- no config -- Python class class_name ConvertToDatabaseModule module_name kiara_modules.core.database full_name kiara_modules.core.database.ConvertT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_config: typing . Mapping[ str, typing . Mapping[str, typing . Any] ] = self . _kiara . type_mgmt . get_type_config_for_\u2026 source_type = source_config[ \"type\" ] target_type: str = self . get_config_value( \"targ\u2026 allow_none: bool = self . get_config_value( \"allo\u2026 source: Value = inputs . get_value_obj(source_pr\u2026 if source_type != source . type_name: raise KiaraProcessingException( f\"Invalid type ({ source . type_name }) of\u2026 ) if not source . is_set or source . is_none: if allow_none: outputs . set_value( \"value_item\" , None ) return else : raise KiaraProcessingException( \"No sou\u2026 if not hasattr(self, f\"from_{ source_profile }\" ): raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"from_{ source_profile }\" ) converted = func(source) outputs . set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"create"},{"location":"modules/database/create/#kiara_info.modules.database.create","text":"Documentation Create a database from files, file_bundles, etc. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. ignore_errors boolean Whether to no ignore convert errors and omit the failed items. Module config -- no config -- Python class class_name ConvertToDatabaseModule module_name kiara_modules.core.database full_name kiara_modules.core.database.ConvertT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_config: typing . Mapping[ str, typing . Mapping[str, typing . Any] ] = self . _kiara . type_mgmt . get_type_config_for_\u2026 source_type = source_config[ \"type\" ] target_type: str = self . get_config_value( \"targ\u2026 allow_none: bool = self . get_config_value( \"allo\u2026 source: Value = inputs . get_value_obj(source_pr\u2026 if source_type != source . type_name: raise KiaraProcessingException( f\"Invalid type ({ source . type_name }) of\u2026 ) if not source . is_set or source . is_none: if allow_none: outputs . set_value( \"value_item\" , None ) return else : raise KiaraProcessingException( \"No sou\u2026 if not hasattr(self, f\"from_{ source_profile }\" ): raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"from_{ source_profile }\" ) converted = func(source) outputs . set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.create"},{"location":"modules/database/export_network_data/","text":"database.export_network_data \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportNetworkDataModule module_name kiara_modules.core.database full_name kiara_modules.core.database.ExportNe\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self . get_config_value( \"t\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_type) func_name = f\"export_as__{ target_profile }\" if not hasattr(self, func_name): raise Exception ( f\"Can't export '{ source_type }' value: \u2026 ) base_path = inputs . get_value_data( \"base_path\" ) if base_path is None : base_path = os . getcwd() name = inputs . get_value_data( \"name\" ) func = getattr(self, func_name) # TODO: check signature? base_path = os . path . abspath(base_path) os . makedirs(base_path, exist_ok = True ) result = func(value = source, base_path = base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value( \"export_details\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"export_network_data"},{"location":"modules/database/export_network_data/#kiara_info.modules.database.export_network_data","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportNetworkDataModule module_name kiara_modules.core.database full_name kiara_modules.core.database.ExportNe\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self . get_config_value( \"t\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_type) func_name = f\"export_as__{ target_profile }\" if not hasattr(self, func_name): raise Exception ( f\"Can't export '{ source_type }' value: \u2026 ) base_path = inputs . get_value_data( \"base_path\" ) if base_path is None : base_path = os . getcwd() name = inputs . get_value_data( \"name\" ) func = getattr(self, func_name) # TODO: check signature? base_path = os . path . abspath(base_path) os . makedirs(base_path, exist_ok = True ) result = func(value = source, base_path = base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value( \"export_details\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.export_network_data"},{"location":"modules/database/info/","text":"database.info \u00b6 Documentation Extract extended metadata (like tables, schemas) from a database object. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name DatabaseInfoMetadataModule module_name kiara_modules.core.database full_name kiara_modules.core.database.Database\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"info"},{"location":"modules/database/info/#kiara_info.modules.database.info","text":"Documentation Extract extended metadata (like tables, schemas) from a database object. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name DatabaseInfoMetadataModule module_name kiara_modules.core.database full_name kiara_modules.core.database.Database\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.info"},{"location":"modules/database/load/","text":"database.load \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the no value to be stored (if database sub-type). Module config -- no config -- Python class class_name LoadDatabaseModule module_name kiara_modules.core.database full_name kiara_modules.core.database.LoadData\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) path = os . path . join(base_path, rel_path) outputs . set_value( \"database\" , path) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"load"},{"location":"modules/database/load/#kiara_info.modules.database.load","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the no value to be stored (if database sub-type). Module config -- no config -- Python class class_name LoadDatabaseModule module_name kiara_modules.core.database full_name kiara_modules.core.database.LoadData\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) path = os . path . join(base_path, rel_path) outputs . set_value( \"database\" , path) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.load"},{"location":"modules/database/metadata/","text":"database.metadata \u00b6 Documentation Extract basic metadata from a database object. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name DatabaseMetadataModule module_name kiara_modules.core.database full_name kiara_modules.core.database.Database\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"metadata"},{"location":"modules/database/metadata/#kiara_info.modules.database.metadata","text":"Documentation Extract basic metadata from a database object. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name DatabaseMetadataModule module_name kiara_modules.core.database full_name kiara_modules.core.database.Database\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.metadata"},{"location":"modules/database/query/","text":"database.query.sql \u00b6 Documentation Execute a sql query against an (Arrow) table. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. query string The query to no execute. If not specified, the user will be able to provide their own. Module config -- no config -- Python class class_name QueryTableSQL module_name kiara_modules.core.database.query full_name kiara_modules.core.database.query.Qu\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pandas as pd import pyarrow as pa if self . get_config_value( \"query\" ) is None : _query: str = inputs . get_value_data( \"query\u2026 else : _query = self . get_config_value( \"query\" ) _database: KiaraDatabase = inputs . get_value_da\u2026 # can't re-use the default engine, because pan\u2026 engine = create_engine(_database . db_url) df = pd . read_sql(_query, con = engine) table = pa . Table . from_pandas(df) outputs . set_value( \"query_result\" , table) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"query"},{"location":"modules/database/query/#kiara_info.modules.database.query.sql","text":"Documentation Execute a sql query against an (Arrow) table. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. query string The query to no execute. If not specified, the user will be able to provide their own. Module config -- no config -- Python class class_name QueryTableSQL module_name kiara_modules.core.database.query full_name kiara_modules.core.database.query.Qu\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pandas as pd import pyarrow as pa if self . get_config_value( \"query\" ) is None : _query: str = inputs . get_value_data( \"query\u2026 else : _query = self . get_config_value( \"query\" ) _database: KiaraDatabase = inputs . get_value_da\u2026 # can't re-use the default engine, because pan\u2026 engine = create_engine(_database . db_url) df = pd . read_sql(_query, con = engine) table = pa . Table . from_pandas(df) outputs . set_value( \"query_result\" , table) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.query.sql"},{"location":"modules/database/store/","text":"database.store \u00b6 Documentation Save an sqlite database to a file. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreDatabaseTypeModule module_name kiara_modules.core.database full_name kiara_modules.core.database.StoreDat\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"store"},{"location":"modules/database/store/#kiara_info.modules.database.store","text":"Documentation Save an sqlite database to a file. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreDatabaseTypeModule module_name kiara_modules.core.database full_name kiara_modules.core.database.StoreDat\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"database.store"},{"location":"modules/date/","text":"date.extract_from_string \u00b6 Documentation Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 r\"_(\\d{4}-\\d{2}-\\d{2})_\" \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name ExtractDateModule module_name kiara_modules.core.date full_name kiara_modules.core.date.ExtractDateM\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) date_match = re . findall( r\"_(\\d{4}-\\d{2}-\\d{2})\u2026 assert date_match d_obj = parser . parse(date_match[ 0 ]) # type: i\u2026 outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 date.range_check \u00b6 Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name DateRangeCheckModule module_name kiara_modules.core.date full_name kiara_modules.core.date.DateRangeChe\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from dateutil import parser d = inputs . get_value_data( \"date\" ) earliest: typing . Optional[datetime . datetime] = \u2026 latest: typing . Optional[datetime . datetime] = i\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if hasattr(d, \"as_py\" ): d = d . as_py() if isinstance(d, str): d = parser . parse(d) if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date"},{"location":"modules/date/#kiara_info.modules.date.extract_from_string","text":"Documentation Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 r\"_(\\d{4}-\\d{2}-\\d{2})_\" \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name ExtractDateModule module_name kiara_modules.core.date full_name kiara_modules.core.date.ExtractDateM\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from dateutil import parser text = inputs . get_value_data( \"text\" ) date_match = re . findall( r\"_(\\d{4}-\\d{2}-\\d{2})\u2026 assert date_match d_obj = parser . parse(date_match[ 0 ]) # type: i\u2026 outputs . set_value( \"date\" , d_obj) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.extract_from_string"},{"location":"modules/date/#kiara_info.modules.date.range_check","text":"Documentation Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name DateRangeCheckModule module_name kiara_modules.core.date full_name kiara_modules.core.date.DateRangeChe\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from dateutil import parser d = inputs . get_value_data( \"date\" ) earliest: typing . Optional[datetime . datetime] = \u2026 latest: typing . Optional[datetime . datetime] = i\u2026 if not earliest and not latest: outputs . set_value( \"within_range\" , True ) return if hasattr(d, \"as_py\" ): d = d . as_py() if isinstance(d, str): d = parser . parse(d) if earliest and latest: matches = earliest <= d <= latest elif earliest: matches = earliest <= d else : matches = d <= latest outputs . set_value( \"within_range\" , matches) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"date.range_check"},{"location":"modules/dev/","text":"dev.dummy \u00b6 Documentation Module that simulates processing, but uses hard-coded outputs as a result. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. documentation string no input_schema object The input yes schema for this module. output_schema object The output yes schema for this module. outputs object The (dummy) no output for this module. delay number The delay in no seconds from processing start to when the (dummy) outputs are returned. Module config -- no config -- Python class class_name DummyModule module_name kiara_modules.core.dev full_name kiara_modules.core.dev.DummyModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 \"\"\"Returns the hardcoded output values that ar\u2026 Optionally, this module can simulate processin\u2026 \"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 output_values: typing . Mapping = self . config . ge\u2026 value_dict = {} for output_name in self . output_names: if output_name not in output_values . keys(): raise NotImplementedError () # v = self.output_schemas[output_name]\u2026 # value_dict[output_name] = v else : value_dict[output_name] = output_value\u2026 outputs . set_values( ** value_dict) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"dev"},{"location":"modules/dev/#kiara_info.modules.dev.dummy","text":"Documentation Module that simulates processing, but uses hard-coded outputs as a result. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. documentation string no input_schema object The input yes schema for this module. output_schema object The output yes schema for this module. outputs object The (dummy) no output for this module. delay number The delay in no seconds from processing start to when the (dummy) outputs are returned. Module config -- no config -- Python class class_name DummyModule module_name kiara_modules.core.dev full_name kiara_modules.core.dev.DummyModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 \"\"\"Returns the hardcoded output values that ar\u2026 Optionally, this module can simulate processin\u2026 \"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 output_values: typing . Mapping = self . config . ge\u2026 value_dict = {} for output_name in self . output_names: if output_name not in output_values . keys(): raise NotImplementedError () # v = self.output_schemas[output_name]\u2026 # value_dict[output_name] = v else : value_dict[output_name] = output_value\u2026 outputs . set_values( ** value_dict) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"dev.dummy"},{"location":"modules/dict/","text":"dict.store \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. value_type string The type of the yes value to save. options integer The options to no use for the json serialization. Check https://github.c\u2026 for details. file_name string The name of the no serialized file. Module config -- no config -- Python class class_name SaveDictModule module_name kiara_modules.core.dict full_name kiara_modules.core.dict.SaveDictModu\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"dict"},{"location":"modules/dict/#kiara_info.modules.dict.store","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. value_type string The type of the yes value to save. options integer The options to no use for the json serialization. Check https://github.c\u2026 for details. file_name string The name of the no serialized file. Module config -- no config -- Python class class_name SaveDictModule module_name kiara_modules.core.dict full_name kiara_modules.core.dict.SaveDictModu\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"dict.store"},{"location":"modules/file/","text":"file.import \u00b6 Documentation Import an external file into a kiara session. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. source_profile string The name of yes the source profile. Used to distinguish different input categories for the same input type. source_type string The type of yes the source to import from. Module config -- no config -- Python class class_name DefaultFileImportModule module_name kiara_modules.core.file full_name kiara_modules.core.file.DefaultFileI\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_profile) if self . get_target_value_type() == \"any\" : output_key: str = \"value_item\" else : output_key = self . get_target_value_type() func_name = f\"import_from__{ source_profile }__{ \u2026 if not hasattr(self, func_name): raise Exception ( f\"Can't import '{ source_type }' value: \u2026 ) func = getattr(self, func_name) # TODO: check signature? result = func(source) # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value(output_key, result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file.load \u00b6 Documentation Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadLocalFileModule module_name kiara_modules.core.file full_name kiara_modules.core.file.LoadLocalFil\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) path = os . path . join(base_path, rel_path) file_model = KiaraFile . load_file(path) outputs . set_value( \"file\" , file_model) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file.metadata \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name FileMetadataModule module_name kiara_modules.core.file full_name kiara_modules.core.file.FileMetadata\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file.store \u00b6 Documentation Save a file to disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreFileTypeModule module_name kiara_modules.core.file full_name kiara_modules.core.file.StoreFileTyp\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file"},{"location":"modules/file/#kiara_info.modules.file.import","text":"Documentation Import an external file into a kiara session. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. source_profile string The name of yes the source profile. Used to distinguish different input categories for the same input type. source_type string The type of yes the source to import from. Module config -- no config -- Python class class_name DefaultFileImportModule module_name kiara_modules.core.file full_name kiara_modules.core.file.DefaultFileI\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_profile) if self . get_target_value_type() == \"any\" : output_key: str = \"value_item\" else : output_key = self . get_target_value_type() func_name = f\"import_from__{ source_profile }__{ \u2026 if not hasattr(self, func_name): raise Exception ( f\"Can't import '{ source_type }' value: \u2026 ) func = getattr(self, func_name) # TODO: check signature? result = func(source) # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value(output_key, result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file.import"},{"location":"modules/file/#kiara_info.modules.file.load","text":"Documentation Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadLocalFileModule module_name kiara_modules.core.file full_name kiara_modules.core.file.LoadLocalFil\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) path = os . path . join(base_path, rel_path) file_model = KiaraFile . load_file(path) outputs . set_value( \"file\" , file_model) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file.load"},{"location":"modules/file/#kiara_info.modules.file.metadata","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name FileMetadataModule module_name kiara_modules.core.file full_name kiara_modules.core.file.FileMetadata\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file.metadata"},{"location":"modules/file/#kiara_info.modules.file.store","text":"Documentation Save a file to disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreFileTypeModule module_name kiara_modules.core.file full_name kiara_modules.core.file.StoreFileTyp\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file.store"},{"location":"modules/file_bundle/","text":"file_bundle.import \u00b6 Documentation Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. source_profile string The name of yes the source profile. Used to distinguish different input categories for the same input type. source_type string The type of yes the source to import from. Module config -- no config -- Python class class_name DefaultFileBundleImportModule module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.Defau\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_profile) if self . get_target_value_type() == \"any\" : output_key: str = \"value_item\" else : output_key = self . get_target_value_type() func_name = f\"import_from__{ source_profile }__{ \u2026 if not hasattr(self, func_name): raise Exception ( f\"Can't import '{ source_type }' value: \u2026 ) func = getattr(self, func_name) # TODO: check signature? result = func(source) # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value(output_key, result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file_bundle.load \u00b6 Documentation Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadFileBundleModule module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.LoadF\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) path = os . path . join(base_path, rel_path) included_files = inputs . get_value_data( \"includ\u2026 excluded_dirs = inputs . get_value_data( \"exclude\u2026 excluded_files = inputs . get_value_data( \"exclud\u2026 import_config = FolderImportConfig( include_files = included_files, exclude_dirs = excluded_dirs, excluded_files = excluded_files, ) bundle = KiaraFileBundle . import_folder(source = \u2026 outputs . set_values(file_bundle = bundle) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file_bundle.metadata \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name FileBundleMetadataModule module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.FileB\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file_bundle.store \u00b6 Documentation Save a file bundle to disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreFileBundleType module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.Store\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file_bundle"},{"location":"modules/file_bundle/#kiara_info.modules.file_bundle.import","text":"Documentation Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. source_profile string The name of yes the source profile. Used to distinguish different input categories for the same input type. source_type string The type of yes the source to import from. Module config -- no config -- Python class class_name DefaultFileBundleImportModule module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.Defau\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_profile) if self . get_target_value_type() == \"any\" : output_key: str = \"value_item\" else : output_key = self . get_target_value_type() func_name = f\"import_from__{ source_profile }__{ \u2026 if not hasattr(self, func_name): raise Exception ( f\"Can't import '{ source_type }' value: \u2026 ) func = getattr(self, func_name) # TODO: check signature? result = func(source) # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value(output_key, result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file_bundle.import"},{"location":"modules/file_bundle/#kiara_info.modules.file_bundle.load","text":"Documentation Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadFileBundleModule module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.LoadF\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) path = os . path . join(base_path, rel_path) included_files = inputs . get_value_data( \"includ\u2026 excluded_dirs = inputs . get_value_data( \"exclude\u2026 excluded_files = inputs . get_value_data( \"exclud\u2026 import_config = FolderImportConfig( include_files = included_files, exclude_dirs = excluded_dirs, excluded_files = excluded_files, ) bundle = KiaraFileBundle . import_folder(source = \u2026 outputs . set_values(file_bundle = bundle) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file_bundle.load"},{"location":"modules/file_bundle/#kiara_info.modules.file_bundle.metadata","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name FileBundleMetadataModule module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.FileB\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file_bundle.metadata"},{"location":"modules/file_bundle/#kiara_info.modules.file_bundle.store","text":"Documentation Save a file bundle to disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreFileBundleType module_name kiara_modules.core.file_bundle full_name kiara_modules.core.file_bundle.Store\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"file_bundle.store"},{"location":"modules/generic/","text":"generic.restore_from_json \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name RestoreFromJsonDictModule module_name kiara_modules.core.generic full_name kiara_modules.core.generic.RestoreFr\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) file_name = inputs . get_value_data( \"file_name\" ) full_path = os . path . join(base_path, file_name) if not os . path . exists(full_path): raise KiaraProcessingException( f\"Can't deserialize dict, path to file\u2026 ) if not os . path . isfile(os . path . realpath(full_pa\u2026 raise KiaraProcessingException( f\"Can't deserialize dict, path is not \u2026 ) with open(full_path, \"r\" ) as f: content = f . read() data = orjson . loads(content) outputs . set_value( \"value_item\" , data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 generic.restore_scalar \u00b6 Documentation Utility module, only used internally. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type of yes the scalar to load. Module config -- no config -- Python class class_name RestoreScalarModule module_name kiara_modules.core.generic full_name kiara_modules.core.generic.RestoreSc\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 data = inputs . get_value_obj( \"scalar_data\" ) outputs . set_value( \"value_item\" , data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 generic.store \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreScalarModule module_name kiara_modules.core.generic full_name kiara_modules.core.generic.StoreScal\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"generic"},{"location":"modules/generic/#kiara_info.modules.generic.restore_from_json","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name RestoreFromJsonDictModule module_name kiara_modules.core.generic full_name kiara_modules.core.generic.RestoreFr\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 base_path = inputs . get_value_data( \"base_path\" ) file_name = inputs . get_value_data( \"file_name\" ) full_path = os . path . join(base_path, file_name) if not os . path . exists(full_path): raise KiaraProcessingException( f\"Can't deserialize dict, path to file\u2026 ) if not os . path . isfile(os . path . realpath(full_pa\u2026 raise KiaraProcessingException( f\"Can't deserialize dict, path is not \u2026 ) with open(full_path, \"r\" ) as f: content = f . read() data = orjson . loads(content) outputs . set_value( \"value_item\" , data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"generic.restore_from_json"},{"location":"modules/generic/#kiara_info.modules.generic.restore_scalar","text":"Documentation Utility module, only used internally. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type of yes the scalar to load. Module config -- no config -- Python class class_name RestoreScalarModule module_name kiara_modules.core.generic full_name kiara_modules.core.generic.RestoreSc\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 data = inputs . get_value_obj( \"scalar_data\" ) outputs . set_value( \"value_item\" , data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"generic.restore_scalar"},{"location":"modules/generic/#kiara_info.modules.generic.store","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The type of the yes value to save. Module config -- no config -- Python class class_name StoreScalarModule module_name kiara_modules.core.generic full_name kiara_modules.core.generic.StoreScal\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"generic.store"},{"location":"modules/json/","text":"json.to_json \u00b6 Documentation Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. source_type string The source type. yes target_type string The target type. yes Module config -- no config -- Python class class_name ToJsonModuleOld module_name kiara_modules.core.json full_name kiara_modules.core.json.ToJsonModule\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value = inputs . get_value_obj( \"source_value\" ) if value . value_schema . type != self . source_type: raise KiaraProcessingException( f\"Can't convert value of source type '\u2026 ) config = inputs . get_value_data( \"config\" ) if config is None : config = {} target_value = self . convert(value = value, confi\u2026 # TODO: validate value? outputs . set_value( \"target_value\" , target_value) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"json"},{"location":"modules/json/#kiara_info.modules.json.to_json","text":"Documentation Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. source_type string The source type. yes target_type string The target type. yes Module config -- no config -- Python class class_name ToJsonModuleOld module_name kiara_modules.core.json full_name kiara_modules.core.json.ToJsonModule\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value = inputs . get_value_obj( \"source_value\" ) if value . value_schema . type != self . source_type: raise KiaraProcessingException( f\"Can't convert value of source type '\u2026 ) config = inputs . get_value_data( \"config\" ) if config is None : config = {} target_value = self . convert(value = value, confi\u2026 # TODO: validate value? outputs . set_value( \"target_value\" , target_value) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"json.to_json"},{"location":"modules/list/","text":"list.contains \u00b6 Documentation Check whether an element is in a list. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name IncludedInListCheckModule module_name kiara_modules.core.list full_name kiara_modules.core.list.IncludedInLi\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 list.store \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. value_type string The type of the yes value to save. options integer The options to no use for the json serialization. Check https://github.c\u2026 for details. file_name string The name of the no serialized file. Module config -- no config -- Python class class_name StoreDictModule module_name kiara_modules.core.list full_name kiara_modules.core.list.StoreDictMod\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"list"},{"location":"modules/list/#kiara_info.modules.list.contains","text":"Documentation Check whether an element is in a list. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name IncludedInListCheckModule module_name kiara_modules.core.list full_name kiara_modules.core.list.IncludedInLi\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 item_list = inputs . get_value_data( \"list\" ) item = inputs . get_value_data( \"item\" ) outputs . set_value( \"is_included\" , item in item_\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"list.contains"},{"location":"modules/list/#kiara_info.modules.list.store","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. value_type string The type of the yes value to save. options integer The options to no use for the json serialization. Check https://github.c\u2026 for details. file_name string The name of the no serialized file. Module config -- no config -- Python class class_name StoreDictModule module_name kiara_modules.core.list full_name kiara_modules.core.list.StoreDictMod\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"list.store"},{"location":"modules/logic/","text":"logic.and \u00b6 Documentation Returns 'True' if both inputs are 'True'. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. delay number the delay in no seconds from processing start to when the output is returned. Module config -- no config -- Python class class_name AndModule module_name kiara_modules.core.logic full_name kiara_modules.core.logic.AndModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.not \u00b6 Documentation Negates the input. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. delay number the delay in no seconds from processing start to when the output is returned. Module config -- no config -- Python class class_name NotModule module_name kiara_modules.core.logic full_name kiara_modules.core.logic.NotModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 logic.or \u00b6 Documentation Returns 'True' if one of the inputs is 'True'. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. delay number the delay in no seconds from processing start to when the output is returned. Module config -- no config -- Python class class_name OrModule module_name kiara_modules.core.logic full_name kiara_modules.core.logic.OrModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic"},{"location":"modules/logic/#kiara_info.modules.logic.and","text":"Documentation Returns 'True' if both inputs are 'True'. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. delay number the delay in no seconds from processing start to when the output is returned. Module config -- no config -- Python class class_name AndModule module_name kiara_modules.core.logic full_name kiara_modules.core.logic.AndModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . delay) # type: ignore outputs . set_value( \"y\" , inputs . get_value_data( \"a\" ) and inputs \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.and"},{"location":"modules/logic/#kiara_info.modules.logic.not","text":"Documentation Negates the input. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. delay number the delay in no seconds from processing start to when the output is returned. Module config -- no config -- Python class class_name NotModule module_name kiara_modules.core.logic full_name kiara_modules.core.logic.NotModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 \"\"\"Negates the input boolean.\"\"\" time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , not inputs . get_value_da\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.not"},{"location":"modules/logic/#kiara_info.modules.logic.or","text":"Documentation Returns 'True' if one of the inputs is 'True'. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. delay number the delay in no seconds from processing start to when the output is returned. Module config -- no config -- Python class class_name OrModule module_name kiara_modules.core.logic full_name kiara_modules.core.logic.OrModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 time . sleep(self . config . get( \"delay\" )) # type: \u2026 outputs . set_value( \"y\" , inputs . get_value_data( \"\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"logic.or"},{"location":"modules/string/","text":"string.deserialize \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. serialization\u2026 string The yes serialization type that was used to serialize the value. Module config -- no config -- Python class class_name DeserializeStringModule module_name kiara_modules.core.string full_name kiara_modules.core.string.Deserializ\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 serialization_type = self . get_config_value( \"se\u2026 if serialization_type not in [ \"json\" ]: raise KiaraProcessingException( f\"Can't deserialize string: serialisat\u2026 ) serialized = inputs . get_value_data( \"serialized\u2026 outputs . set_value( \"value_item\" , serialized) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.match_regex \u00b6 Documentation Match a string using a regular expression. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. regex string The regex to yes apply. only_first_ma\u2026 boolean Whether to no only return the first match, or all matches. Module config -- no config -- Python class class_name RegexModule module_name kiara_modules.core.string full_name kiara_modules.core.string.RegexModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.replace \u00b6 Documentation Replace a string if it matches a key in a mapping dictionary. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. replacement_m\u2026 object A map, yes containing the strings to be replaced as keys, and the replacements as values. default_value string The default no value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. Module config -- no config -- Python class class_name ReplaceStringModule module_name kiara_modules.core.string full_name kiara_modules.core.string.ReplaceStr\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 string.serialize \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. value_type string The type of yes the source value. serialization\u2026 string The type of yes the converted value. Module config -- no config -- Python class class_name SerializeStringModule module_name kiara_modules.core.string full_name kiara_modules.core.string.SerializeS\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_type: str = self . get_config_value( \"value\u2026 value_obj = inputs . get_value_obj( \"value_item\" ) serialization_type = self . get_config_value( \"se\u2026 if value_type != value_obj . type_name: raise KiaraProcessingException( f\"Invalid type ({ value_obj . type_name })\u2026 ) if not hasattr(self, f\"to_{ serialization_type }\u2026 # this can never happen, I think raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"to_{ serialization_type }\u2026 serialized = func(value_obj) if isinstance(serialized, typing . Mapping): serialized = DeserializeConfig( ** serialize\u2026 if not isinstance(serialized, DeserializeConfi\u2026 raise KiaraProcessingException( f\"Invalid serialization result type: { \u2026 ) outputs . set_values( deserialize_config = serialized, value_info = \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string"},{"location":"modules/string/#kiara_info.modules.string.deserialize","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. serialization\u2026 string The yes serialization type that was used to serialize the value. Module config -- no config -- Python class class_name DeserializeStringModule module_name kiara_modules.core.string full_name kiara_modules.core.string.Deserializ\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 serialization_type = self . get_config_value( \"se\u2026 if serialization_type not in [ \"json\" ]: raise KiaraProcessingException( f\"Can't deserialize string: serialisat\u2026 ) serialized = inputs . get_value_data( \"serialized\u2026 outputs . set_value( \"value_item\" , serialized) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.deserialize"},{"location":"modules/string/#kiara_info.modules.string.match_regex","text":"Documentation Match a string using a regular expression. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. regex string The regex to yes apply. only_first_ma\u2026 boolean Whether to no only return the first match, or all matches. Module config -- no config -- Python class class_name RegexModule module_name kiara_modules.core.string full_name kiara_modules.core.string.RegexModule Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) regex = self . get_config_value( \"regex\" ) matches = re . findall(regex, text) if not matches: raise KiaraProcessingException( f\"No match \u2026 if self . get_config_value( \"only_first_match\" ): result = matches[ 0 ] else : result = matches outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.match_regex"},{"location":"modules/string/#kiara_info.modules.string.replace","text":"Documentation Replace a string if it matches a key in a mapping dictionary. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. replacement_m\u2026 object A map, yes containing the strings to be replaced as keys, and the replacements as values. default_value string The default no value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. Module config -- no config -- Python class class_name ReplaceStringModule module_name kiara_modules.core.string full_name kiara_modules.core.string.ReplaceStr\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 text = inputs . get_value_data( \"text\" ) repl_map = self . get_config_value( \"replacement_\u2026 default = self . get_config_value( \"default_value\u2026 if text not in repl_map . keys(): if default is None : result = text else : result = default else : result = repl_map[text] outputs . set_value( \"text\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.replace"},{"location":"modules/string/#kiara_info.modules.string.serialize","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. value_type string The type of yes the source value. serialization\u2026 string The type of yes the converted value. Module config -- no config -- Python class class_name SerializeStringModule module_name kiara_modules.core.string full_name kiara_modules.core.string.SerializeS\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_type: str = self . get_config_value( \"value\u2026 value_obj = inputs . get_value_obj( \"value_item\" ) serialization_type = self . get_config_value( \"se\u2026 if value_type != value_obj . type_name: raise KiaraProcessingException( f\"Invalid type ({ value_obj . type_name })\u2026 ) if not hasattr(self, f\"to_{ serialization_type }\u2026 # this can never happen, I think raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"to_{ serialization_type }\u2026 serialized = func(value_obj) if isinstance(serialized, typing . Mapping): serialized = DeserializeConfig( ** serialize\u2026 if not isinstance(serialized, DeserializeConfi\u2026 raise KiaraProcessingException( f\"Invalid serialization result type: { \u2026 ) outputs . set_values( deserialize_config = serialized, value_info = \u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"string.serialize"},{"location":"modules/table/","text":"","title":"table"},{"location":"modules/table/create/","text":"table.create \u00b6 Documentation Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: \u2022 bytes: a memoryview of the byte-representation of the Table \u2022 string: the base64-encoded byte-representation of the Table Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. ignore_errors boolean Whether to no ignore convert errors and omit the failed items. Module config -- no config -- Python class class_name ConvertToTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.ConvertToTa\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_config: typing . Mapping[ str, typing . Mapping[str, typing . Any] ] = self . _kiara . type_mgmt . get_type_config_for_\u2026 source_type = source_config[ \"type\" ] target_type: str = self . get_config_value( \"targ\u2026 allow_none: bool = self . get_config_value( \"allo\u2026 source: Value = inputs . get_value_obj(source_pr\u2026 if source_type != source . type_name: raise KiaraProcessingException( f\"Invalid type ({ source . type_name }) of\u2026 ) if not source . is_set or source . is_none: if allow_none: outputs . set_value( \"value_item\" , None ) return else : raise KiaraProcessingException( \"No sou\u2026 if not hasattr(self, f\"from_{ source_profile }\" ): raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"from_{ source_profile }\" ) converted = func(source) outputs . set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"create"},{"location":"modules/table/create/#kiara_info.modules.table.create","text":"Documentation Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: \u2022 bytes: a memoryview of the byte-representation of the Table \u2022 string: the base64-encoded byte-representation of the Table Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value no defaults for this module. source_profile string The profile yes of the source value. target_type string The type of yes the value to convert to. allow_none_in\u2026 boolean Whether to no allow 'none' source values, if one is encountered 'none' is returned. ignore_errors boolean Whether to no ignore convert errors and omit the failed items. Module config -- no config -- Python class class_name ConvertToTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.ConvertToTa\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 source_profile: str = self . get_config_value( \"s\u2026 source_config: typing . Mapping[ str, typing . Mapping[str, typing . Any] ] = self . _kiara . type_mgmt . get_type_config_for_\u2026 source_type = source_config[ \"type\" ] target_type: str = self . get_config_value( \"targ\u2026 allow_none: bool = self . get_config_value( \"allo\u2026 source: Value = inputs . get_value_obj(source_pr\u2026 if source_type != source . type_name: raise KiaraProcessingException( f\"Invalid type ({ source . type_name }) of\u2026 ) if not source . is_set or source . is_none: if allow_none: outputs . set_value( \"value_item\" , None ) return else : raise KiaraProcessingException( \"No sou\u2026 if not hasattr(self, f\"from_{ source_profile }\" ): raise Exception ( f\"Module '{ self . _module_type_id }' can'\u2026 ) func = getattr(self, f\"from_{ source_profile }\" ) converted = func(source) outputs . set_value(target_type, converted) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.create"},{"location":"modules/table/cut_column/","text":"table.cut_column \u00b6 Documentation Cut off one column from a table, returning an array. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CutColumnModule module_name kiara_modules.core.table full_name kiara_modules.core.table.CutColumnMo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa table_value = inputs . get_value_obj( \"table\" ) column_name: str = inputs . get_value_data( \"colu\u2026 available = table_value . get_metadata( \"table\" )[ \u2026 if column_name not in available: raise KiaraProcessingException( f\"Invalid column name '{ column_name }'.\u2026 ) table: pa . Table = inputs . get_value_data( \"table\u2026 column = table . column(column_name) outputs . set_value( \"array\" , column) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"cut_column"},{"location":"modules/table/cut_column/#kiara_info.modules.table.cut_column","text":"Documentation Cut off one column from a table, returning an array. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CutColumnModule module_name kiara_modules.core.table full_name kiara_modules.core.table.CutColumnMo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa table_value = inputs . get_value_obj( \"table\" ) column_name: str = inputs . get_value_data( \"colu\u2026 available = table_value . get_metadata( \"table\" )[ \u2026 if column_name not in available: raise KiaraProcessingException( f\"Invalid column name '{ column_name }'.\u2026 ) table: pa . Table = inputs . get_value_data( \"table\u2026 column = table . column(column_name) outputs . set_value( \"array\" , column) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.cut_column"},{"location":"modules/table/export/","text":"table.export \u00b6 Documentation Export a table object to disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name ExportArrowTable module_name kiara_modules.core.table full_name kiara_modules.core.table.ExportArrow\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa from pyarrow import feather table: pa . Table = inputs . get_value_data( \"table\u2026 full_path: str = inputs . get_value_data( \"path\" ) force_overwrite = inputs . get_value_data( \"force\u2026 format: str = inputs . get_value_data( \"format\" ) compression = inputs . get_value_data( \"compressi\u2026 if compression not in [ \"zstd\" , \"lz4\" , \"uncompr\u2026 raise KiaraProcessingException( f\"Invalid compression format '{ compres\u2026 ) if format != \"feather\" : raise KiaraProcessingException( f\"Can't export table to format '{ forma\u2026 ) if os . path . exists(full_path) and not force_ove\u2026 raise KiaraProcessingException( f\"Can't write table to file, file alre\u2026 ) os . makedirs(os . path . dirname(full_path), exist_\u2026 feather . write_feather(table, full_path, compre\u2026 result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname(full_path\u2026 \"rel_path\" : os . path . basename(full_path\u2026 \"format\" : format, }, \"value_id\" : NO_VALUE_ID_MARKER, \"output_name\" : \"table\" , } outputs . set_value( \"load_config\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"export"},{"location":"modules/table/export/#kiara_info.modules.table.export","text":"Documentation Export a table object to disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name ExportArrowTable module_name kiara_modules.core.table full_name kiara_modules.core.table.ExportArrow\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa from pyarrow import feather table: pa . Table = inputs . get_value_data( \"table\u2026 full_path: str = inputs . get_value_data( \"path\" ) force_overwrite = inputs . get_value_data( \"force\u2026 format: str = inputs . get_value_data( \"format\" ) compression = inputs . get_value_data( \"compressi\u2026 if compression not in [ \"zstd\" , \"lz4\" , \"uncompr\u2026 raise KiaraProcessingException( f\"Invalid compression format '{ compres\u2026 ) if format != \"feather\" : raise KiaraProcessingException( f\"Can't export table to format '{ forma\u2026 ) if os . path . exists(full_path) and not force_ove\u2026 raise KiaraProcessingException( f\"Can't write table to file, file alre\u2026 ) os . makedirs(os . path . dirname(full_path), exist_\u2026 feather . write_feather(table, full_path, compre\u2026 result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname(full_path\u2026 \"rel_path\" : os . path . basename(full_path\u2026 \"format\" : format, }, \"value_id\" : NO_VALUE_ID_MARKER, \"output_name\" : \"table\" , } outputs . set_value( \"load_config\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.export"},{"location":"modules/table/export_table/","text":"table.export_table \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.ExportTable\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self . get_config_value( \"t\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_type) func_name = f\"export_as__{ target_profile }\" if not hasattr(self, func_name): raise Exception ( f\"Can't export '{ source_type }' value: \u2026 ) base_path = inputs . get_value_data( \"base_path\" ) if base_path is None : base_path = os . getcwd() name = inputs . get_value_data( \"name\" ) func = getattr(self, func_name) # TODO: check signature? base_path = os . path . abspath(base_path) os . makedirs(base_path, exist_ok = True ) result = func(value = source, base_path = base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value( \"export_details\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"export_table"},{"location":"modules/table/export_table/#kiara_info.modules.table.export_table","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value no constants for this module. defaults object Value defaults no for this module. target_profile string The name of yes the target profile. Used to distinguish different target formats for the same data type. source_type string The type of yes the source data that is going to be exported. Module config -- no config -- Python class class_name ExportTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.ExportTable\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 target_profile: str = self . get_config_value( \"t\u2026 source_type: str = self . get_config_value( \"sour\u2026 source = inputs . get_value_data(source_type) func_name = f\"export_as__{ target_profile }\" if not hasattr(self, func_name): raise Exception ( f\"Can't export '{ source_type }' value: \u2026 ) base_path = inputs . get_value_data( \"base_path\" ) if base_path is None : base_path = os . getcwd() name = inputs . get_value_data( \"name\" ) func = getattr(self, func_name) # TODO: check signature? base_path = os . path . abspath(base_path) os . makedirs(base_path, exist_ok = True ) result = func(value = source, base_path = base_pat\u2026 # schema = ValueSchema(type=self.get_target_va\u2026 # value_lineage = ValueLineage.from_module_and\u2026 # module=self, output_name=output_key, inp\u2026 # ) # value: Value = self._kiara.data_registry.reg\u2026 # value_data=result, value_schema=schema, \u2026 # ) outputs . set_value( \"export_details\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.export_table"},{"location":"modules/table/filter/","text":"table.filter.with_mask \u00b6 Documentation Filter a table using a mask array. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CreateFilteredTableModule module_name kiara_modules.core.table.filter full_name kiara_modules.core.table.filter.Crea\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa input_table: pa . Table = inputs . get_value_data( \u2026 filter_array: pa . Array = inputs . get_value_data\u2026 filtered = input_table . filter(filter_array) outputs . set_value( \"table\" , filtered) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"filter"},{"location":"modules/table/filter/#kiara_info.modules.table.filter.with_mask","text":"Documentation Filter a table using a mask array. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name CreateFilteredTableModule module_name kiara_modules.core.table.filter full_name kiara_modules.core.table.filter.Crea\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa input_table: pa . Table = inputs . get_value_data( \u2026 filter_array: pa . Array = inputs . get_value_data\u2026 filtered = input_table . filter(filter_array) outputs . set_value( \"table\" , filtered) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.filter.with_mask"},{"location":"modules/table/load/","text":"table.load \u00b6 Documentation Load a table object from disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadArrowTable module_name kiara_modules.core.table full_name kiara_modules.core.table.LoadArrowTa\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from pyarrow import feather base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) format = inputs . get_value_data( \"format\" ) if format != \"feather\" : raise NotImplementedError () path = os . path . join(base_path, rel_path) table = feather . read_table(path) outputs . set_value( \"table\" , table) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"load"},{"location":"modules/table/load/#kiara_info.modules.table.load","text":"Documentation Load a table object from disk. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name LoadArrowTable module_name kiara_modules.core.table full_name kiara_modules.core.table.LoadArrowTa\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 from pyarrow import feather base_path = inputs . get_value_data( \"base_path\" ) rel_path = inputs . get_value_data( \"rel_path\" ) format = inputs . get_value_data( \"format\" ) if format != \"feather\" : raise NotImplementedError () path = os . path . join(base_path, rel_path) table = feather . read_table(path) outputs . set_value( \"table\" , table) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.load"},{"location":"modules/table/map_column/","text":"table.map_column \u00b6 Documentation Map the items of one column of a table onto an array, using another module. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. module_type string The name of the yes kiara module to use to filter the input data. module_config object The config for no the kiara filter module. input_name string The name of the no input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input. output_name string The name of the no output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. Module config -- no config -- Python class class_name MapColumnModule module_name kiara_modules.core.table full_name kiara_modules.core.table.MapColumnMo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa table: pa . Table = inputs . get_value_data( \"table\u2026 column_name = inputs . get_value_data( \"column_na\u2026 if column_name not in table . column_names: raise KiaraProcessingException( f\"Table column '{ column_name }' not ava\u2026 ) input_array: pa . Array = table . column(column_na\u2026 init_data: typing . Dict[str, typing . Any] = {} for input_name in self . input_schemas . keys(): if input_name in [ \"table\" , \"column_name\" , \u2026 continue init_data[input_name] = inputs . get_value_o\u2026 result_list = map_with_module( input_array, module_input_name = self . module_input_name, module_obj = self . child_module, init_data = init_data, module_output_name = self . module_output_name, ) outputs . set_value( \"array\" , pa . array(result_lis\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"map_column"},{"location":"modules/table/map_column/#kiara_info.modules.table.map_column","text":"Documentation Map the items of one column of a table onto an array, using another module. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. module_type string The name of the yes kiara module to use to filter the input data. module_config object The config for no the kiara filter module. input_name string The name of the no input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input. output_name string The name of the no output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. Module config -- no config -- Python class class_name MapColumnModule module_name kiara_modules.core.table full_name kiara_modules.core.table.MapColumnMo\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa table: pa . Table = inputs . get_value_data( \"table\u2026 column_name = inputs . get_value_data( \"column_na\u2026 if column_name not in table . column_names: raise KiaraProcessingException( f\"Table column '{ column_name }' not ava\u2026 ) input_array: pa . Array = table . column(column_na\u2026 init_data: typing . Dict[str, typing . Any] = {} for input_name in self . input_schemas . keys(): if input_name in [ \"table\" , \"column_name\" , \u2026 continue init_data[input_name] = inputs . get_value_o\u2026 result_list = map_with_module( input_array, module_input_name = self . module_input_name, module_obj = self . child_module, init_data = init_data, module_output_name = self . module_output_name, ) outputs . set_value( \"array\" , pa . array(result_lis\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.map_column"},{"location":"modules/table/merge/","text":"table.merge \u00b6 Documentation Create a table from other tables and/or arrays. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. input_schema object A dict yes describing the inputs for this merge process. Module config -- no config -- Python class class_name MergeTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.MergeTableM\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa input_schema: typing . Dict[str, typing . Any] = s\u2026 \"input_schema\" ) sources = {} for field_name in input_schema . keys(): sources[field_name] = inputs . get_value_dat\u2026 len_dict = {} arrays = [] column_names = [] for source_key, table_or_column in sources . ite\u2026 if isinstance(table_or_column, pa . Table): rows = table_or_column . num_rows for name in table_or_column . schema . nam\u2026 column = table_or_column . column(na\u2026 arrays . append(column) column_names . append(name) elif isinstance(table_or_column, (pa . Array\u2026 rows = len(table_or_column) arrays . append(table_or_column) column_names . append(source_key) else : raise KiaraProcessingException( f\"Can't merge table: invalid type \u2026 ) len_dict[source_key] = rows all_rows = None for source_key, rows in len_dict . items(): if all_rows is None : all_rows = rows else : if all_rows != rows: all_rows = None break if all_rows is None : len_str = \"\" for name, rows in len_dict . items(): len_str = f\" { name } ({ rows })\" raise KiaraProcessingException( f\"Can't merge table, sources have diff\u2026 ) table = pa . Table . from_arrays(arrays = arrays, na\u2026 outputs . set_value( \"table\" , table) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"merge"},{"location":"modules/table/merge/#kiara_info.modules.table.merge","text":"Documentation Create a table from other tables and/or arrays. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. input_schema object A dict yes describing the inputs for this merge process. Module config -- no config -- Python class class_name MergeTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.MergeTableM\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa input_schema: typing . Dict[str, typing . Any] = s\u2026 \"input_schema\" ) sources = {} for field_name in input_schema . keys(): sources[field_name] = inputs . get_value_dat\u2026 len_dict = {} arrays = [] column_names = [] for source_key, table_or_column in sources . ite\u2026 if isinstance(table_or_column, pa . Table): rows = table_or_column . num_rows for name in table_or_column . schema . nam\u2026 column = table_or_column . column(na\u2026 arrays . append(column) column_names . append(name) elif isinstance(table_or_column, (pa . Array\u2026 rows = len(table_or_column) arrays . append(table_or_column) column_names . append(source_key) else : raise KiaraProcessingException( f\"Can't merge table: invalid type \u2026 ) len_dict[source_key] = rows all_rows = None for source_key, rows in len_dict . items(): if all_rows is None : all_rows = rows else : if all_rows != rows: all_rows = None break if all_rows is None : len_str = \"\" for name, rows in len_dict . items(): len_str = f\" { name } ({ rows })\" raise KiaraProcessingException( f\"Can't merge table, sources have diff\u2026 ) table = pa . Table . from_arrays(arrays = arrays, na\u2026 outputs . set_value( \"table\" , table) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.merge"},{"location":"modules/table/metadata/","text":"table.metadata \u00b6 Documentation Extract metadata from a table object. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name TableMetadataModule module_name kiara_modules.core.table full_name kiara_modules.core.table.TableMetada\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"metadata"},{"location":"modules/table/metadata/#kiara_info.modules.table.metadata","text":"Documentation Extract metadata from a table object. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The data type this yes module will be used for. Module config -- no config -- Python class class_name TableMetadataModule module_name kiara_modules.core.table full_name kiara_modules.core.table.TableMetada\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 input_name = self . value_type if input_name == \"any\" : input_name = \"value_item\" value = inputs . get_value_obj(input_name) if self . value_type != \"any\" and value . type_nam\u2026 raise KiaraProcessingException( f\"Can't extract metadata for value of \u2026 ) # TODO: if type 'any', validate that the data \u2026 outputs . set_value( \"metadata_item_schema\" , self \u2026 metadata = self . extract_metadata(value) if isinstance(metadata, BaseModel): metadata = metadata . dict(exclude_none = True ) # TODO: validate metadata? outputs . set_value( \"metadata_item\" , metadata) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.metadata"},{"location":"modules/table/query/","text":"table.query.graphql \u00b6 Documentation Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 { \u2502 \u2502 df(where: { \u2502 \u2502 Language: {_eq: \"German\"} \u2502 \u2502 } ) { \u2502 \u2502 \u2502 \u2502 row(limit: 10) { \u2502 \u2502 Label \u2502 \u2502 City \u2502 \u2502 } \u2502 \u2502 } \u2502 \u2502 } \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name QueryTableGraphQL module_name kiara_modules.core.table.query full_name kiara_modules.core.table.query.Query\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import vaex table = inputs . get_value_data( \"table\" ) query = inputs . get_value_data( \"query\" ) df = vaex . from_arrow_table(table) result = df . graphql . execute(query) outputs . set_value( \"query_result\" , result . to_di\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 table.query.sql \u00b6 Documentation Execute a sql query against an (Arrow) table. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. query string The query to no execute. If not specified, the user will be able to provide their own. relation_name string The name the no table is referred to in the sql query. If not specified, the user will be able to provide their own. Module config -- no config -- Python class class_name QueryTableSQL module_name kiara_modules.core.table.query full_name kiara_modules.core.table.query.Query\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import duckdb if self . get_config_value( \"query\" ) is None : _query: str = inputs . get_value_data( \"query\u2026 _relation_name: str = inputs . get_value_dat\u2026 else : _query = self . get_config_value( \"query\" ) _relation_name = self . get_config_value( \"re\u2026 if _relation_name . upper() in RESERVED_SQL_KEYW\u2026 raise KiaraProcessingException( f\"Invalid relation name '{ _relation_na\u2026 ) _table = inputs . get_value_data( \"table\" ) rel_from_arrow = duckdb . arrow(_table) result: duckdb . DuckDBPyResult = rel_from_arrow \u2026 outputs . set_value( \"query_result\" , result . fetch\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"query"},{"location":"modules/table/query/#kiara_info.modules.table.query.graphql","text":"Documentation Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 { \u2502 \u2502 df(where: { \u2502 \u2502 Language: {_eq: \"German\"} \u2502 \u2502 } ) { \u2502 \u2502 \u2502 \u2502 row(limit: 10) { \u2502 \u2502 Label \u2502 \u2502 City \u2502 \u2502 } \u2502 \u2502 } \u2502 \u2502 } \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for no this module. defaults object Value defaults for no this module. Module config -- no config -- Python class class_name QueryTableGraphQL module_name kiara_modules.core.table.query full_name kiara_modules.core.table.query.Query\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import vaex table = inputs . get_value_data( \"table\" ) query = inputs . get_value_data( \"query\" ) df = vaex . from_arrow_table(table) result = df . graphql . execute(query) outputs . set_value( \"query_result\" , result . to_di\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.query.graphql"},{"location":"modules/table/query/#kiara_info.modules.table.query.sql","text":"Documentation Execute a sql query against an (Arrow) table. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. query string The query to no execute. If not specified, the user will be able to provide their own. relation_name string The name the no table is referred to in the sql query. If not specified, the user will be able to provide their own. Module config -- no config -- Python class class_name QueryTableSQL module_name kiara_modules.core.table.query full_name kiara_modules.core.table.query.Query\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import duckdb if self . get_config_value( \"query\" ) is None : _query: str = inputs . get_value_data( \"query\u2026 _relation_name: str = inputs . get_value_dat\u2026 else : _query = self . get_config_value( \"query\" ) _relation_name = self . get_config_value( \"re\u2026 if _relation_name . upper() in RESERVED_SQL_KEYW\u2026 raise KiaraProcessingException( f\"Invalid relation name '{ _relation_na\u2026 ) _table = inputs . get_value_data( \"table\" ) rel_from_arrow = duckdb . arrow(_table) result: duckdb . DuckDBPyResult = rel_from_arrow \u2026 outputs . set_value( \"query_result\" , result . fetch\u2026 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.query.sql"},{"location":"modules/table/sample/","text":"table.sample \u00b6 Documentation Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. sample_type string The sample yes method. Module config -- no config -- Python class class_name SampleTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.SampleTable\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 sample_size: int = inputs . get_value_data( \"samp\u2026 sample_type: str = self . get_config_value( \"samp\u2026 if sample_size < 0 : raise KiaraProcessingException( f\"Invalid sample size '{ sample_size }':\u2026 ) input_name = self . get_value_type() if input_name == \"any\" : input_name = \"value_item\" value: Value = inputs . get_value_obj(input_name) func = getattr(self, f\"sample_{ sample_type }\" ) result = func(value = value, sample_size = sample_\u2026 outputs . set_value( \"sampled_value\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"sample"},{"location":"modules/table/sample/#kiara_info.modules.table.sample","text":"Documentation Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. sample_type string The sample yes method. Module config -- no config -- Python class class_name SampleTableModule module_name kiara_modules.core.table full_name kiara_modules.core.table.SampleTable\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 sample_size: int = inputs . get_value_data( \"samp\u2026 sample_type: str = self . get_config_value( \"samp\u2026 if sample_size < 0 : raise KiaraProcessingException( f\"Invalid sample size '{ sample_size }':\u2026 ) input_name = self . get_value_type() if input_name == \"any\" : input_name = \"value_item\" value: Value = inputs . get_value_obj(input_name) func = getattr(self, f\"sample_{ sample_type }\" ) result = func(value = value, sample_size = sample_\u2026 outputs . set_value( \"sampled_value\" , result) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.sample"},{"location":"modules/table/store/","text":"table.store \u00b6 Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. value_type string The type of the yes value to save. compression string The compression no to use when saving the table. Module config -- no config -- Python class class_name StoreArrowTable module_name kiara_modules.core.table full_name kiara_modules.core.table.StoreArrowT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"store"},{"location":"modules/table/store/#kiara_info.modules.table.store","text":"Documentation -- n/a -- Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. value_type string The type of the yes value to save. compression string The compression no to use when saving the table. Module config -- no config -- Python class class_name StoreArrowTable module_name kiara_modules.core.table full_name kiara_modules.core.table.StoreArrowT\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value_id: str = inputs . get_value_data( \"value_i\u2026 if not value_id: raise KiaraProcessingException( \"No value i\u2026 field_name = self . get_config_value( \"value_type\u2026 if field_name == \"any\" : field_name = \"value_item\" value_obj: Value = inputs . get_value_obj(field_\u2026 base_path: str = inputs . get_value_data( \"base_p\u2026 result = self . store_value(value = value_obj, bas\u2026 if isinstance(result, typing . Mapping): load_config = result result_value = value_obj elif isinstance(result, tuple): load_config = result[ 0 ] if result[ 1 ]: result_value = result[ 1 ] else : result_value = value_obj else : raise KiaraProcessingException( f\"Invalid result type for 'store_value\u2026 ) load_config[ \"value_id\" ] = value_id lc = LoadConfig( ** load_config) if lc . base_path_input_name and lc . base_path_in\u2026 raise KiaraProcessingException( f\"Invalid load config: base path '{ lc . \u2026 ) outputs . set_values( metadata = None , lineage = None , ** { \"load_conf\u2026 ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"table.store"},{"location":"modules/value/","text":"value.data_profile \u00b6 Documentation Generate a data profile report for a dataset. This uses the DataProfiler Python library, check out its documentation for more details. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type to yes profile. Module config -- no config -- Python class class_name DataProfilerModule module_name kiara_modules.core.value full_name kiara_modules.core.value.DataProfile\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa from dataprofiler import Data, Profiler, Profi\u2026 set_verbosity(logging . WARNING) value_type = self . get_config_value( \"value_type\u2026 profile_options = ProfilerOptions() profile_options . structured_options . data_labele\u2026 profile_options . unstructured_options . data_labe\u2026 if value_type == \"table\" : table_item: pa . Table = inputs . get_value_da\u2026 pd = table_item . to_pandas() profile = Profiler( pd, options = profile_options ) # Calculate Statistics, Entity Recognit\u2026 report = profile . report() elif value_type == \"file\" : file_item: KiaraFile = inputs . get_value_da\u2026 data = Data(file_item . path) profile = Profiler(data, options = profile_o\u2026 report = profile . report() else : raise KiaraProcessingException( f\"Data profiling of value type '{ value\u2026 ) outputs . set_value( \"report\" , report) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"value"},{"location":"modules/value/#kiara_info.modules.value.data_profile","text":"Documentation Generate a data profile report for a dataset. This uses the DataProfiler Python library, check out its documentation for more details. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults for no this module. value_type string The value type to yes profile. Module config -- no config -- Python class class_name DataProfilerModule module_name kiara_modules.core.value full_name kiara_modules.core.value.DataProfile\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 import pyarrow as pa from dataprofiler import Data, Profiler, Profi\u2026 set_verbosity(logging . WARNING) value_type = self . get_config_value( \"value_type\u2026 profile_options = ProfilerOptions() profile_options . structured_options . data_labele\u2026 profile_options . unstructured_options . data_labe\u2026 if value_type == \"table\" : table_item: pa . Table = inputs . get_value_da\u2026 pd = table_item . to_pandas() profile = Profiler( pd, options = profile_options ) # Calculate Statistics, Entity Recognit\u2026 report = profile . report() elif value_type == \"file\" : file_item: KiaraFile = inputs . get_value_da\u2026 data = Data(file_item . path) profile = Profiler(data, options = profile_o\u2026 report = profile . report() else : raise KiaraProcessingException( f\"Data profiling of value type '{ value\u2026 ) outputs . set_value( \"report\" , report) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"value.data_profile"},{"location":"modules/yaml/","text":"yaml.to_yaml \u00b6 Documentation Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. source_type string The source type. yes target_type string The target type. yes Module config -- no config -- Python class class_name ToYamlModuleOld module_name kiara_modules.core.yaml full_name kiara_modules.core.yaml.ToYamlModule\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value = inputs . get_value_obj( \"source_value\" ) if value . value_schema . type != self . source_type: raise KiaraProcessingException( f\"Can't convert value of source type '\u2026 ) config = inputs . get_value_data( \"config\" ) if config is None : config = {} target_value = self . convert(value = value, confi\u2026 # TODO: validate value? outputs . set_value( \"target_value\" , target_value) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"yaml"},{"location":"modules/yaml/#kiara_info.modules.yaml.to_yaml","text":"Documentation Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. Origin Authors Markus Binsteiner (markus@frkl.io) Context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kia\u2026 documentation : https://dharpa.org/kiara_modules.core/ module_doc : https://dharpa.org/kiara_modules.core\u2026 source_url : https://github.com/DHARPA-Project/kia\u2026 Module config Field Type Description Required \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants no for this module. defaults object Value defaults no for this module. source_type string The source type. yes target_type string The target type. yes Module config -- no config -- Python class class_name ToYamlModuleOld module_name kiara_modules.core.yaml full_name kiara_modules.core.yaml.ToYamlModule\u2026 Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueSet, outputs: Value\u2026 value = inputs . get_value_obj( \"source_value\" ) if value . value_schema . type != self . source_type: raise KiaraProcessingException( f\"Can't convert value of source type '\u2026 ) config = inputs . get_value_data( \"config\" ) if config is None : config = {} target_value = self . convert(value = value, confi\u2026 # TODO: validate value? outputs . set_value( \"target_value\" , target_value) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"yaml.to_yaml"},{"location":"operation_types/","text":"xxxxxxx","title":"Index"},{"location":"operation_types/SUMMARY/","text":"data_profile","title":"SUMMARY"},{"location":"operation_types/data_profile/","text":"data_profile \u00b6 type_name data_profile documentation -- n/a -- origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DataProfileOperationType module_name kiara_modules.core.operations full_name kiara_modules.core.operations.DataProfile\u2026","title":"data_profile"},{"location":"operation_types/data_profile/#kiara_info.operation_types.data_profile","text":"type_name data_profile documentation -- n/a -- origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DataProfileOperationType module_name kiara_modules.core.operations full_name kiara_modules.core.operations.DataProfile\u2026","title":"data_profile"},{"location":"pipelines/","text":"xxxxxxx","title":"Index"},{"location":"pipelines/SUMMARY/","text":"array logic table filter","title":"SUMMARY"},{"location":"pipelines/array/","text":"array.restore \u00b6 class kiara_modules.core.array.ArrayRestorePipelineModule is pipeline yes doc Load a column from a table object, returning an array. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs base_path : type : string doc : The path to the folder that contains the table f\u2026 rel_path : type : string doc : The relative path to the table file within base_\u2026 format : type : string doc : The format of the table file ('feather' or 'parq\u2026 column_name : type : string doc : The name of the column to extract. pipeline outputs array : type : array doc : The column. processing stages stage 0 : load_table : module : table.load desc : Load a table object from disk. inputs : - base_path \u2190 __pipeline__.base_path - rel_path \u2190 __pipeline__.rel_path - format \u2190 __pipeline__.format outputs : - table stage 1 : cut_column : module : table.cut_column desc : Cut off one column from a table, returning an\u2026 inputs : - table \u2190 load_table.table - column_name \u2190 __pipeline__.column_name outputs : - array \u2192 __pipeline__.array","title":"array"},{"location":"pipelines/array/#kiara_info.modules.array.restore","text":"class kiara_modules.core.array.ArrayRestorePipelineModule is pipeline yes doc Load a column from a table object, returning an array. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs base_path : type : string doc : The path to the folder that contains the table f\u2026 rel_path : type : string doc : The relative path to the table file within base_\u2026 format : type : string doc : The format of the table file ('feather' or 'parq\u2026 column_name : type : string doc : The name of the column to extract. pipeline outputs array : type : array doc : The column. processing stages stage 0 : load_table : module : table.load desc : Load a table object from disk. inputs : - base_path \u2190 __pipeline__.base_path - rel_path \u2190 __pipeline__.rel_path - format \u2190 __pipeline__.format outputs : - table stage 1 : cut_column : module : table.cut_column desc : Cut off one column from a table, returning an\u2026 inputs : - table \u2190 load_table.table - column_name \u2190 __pipeline__.column_name outputs : - array \u2192 __pipeline__.array","title":"array.restore"},{"location":"pipelines/logic/","text":"logic.nand \u00b6 class kiara_modules.core.logic.LogicNandPipelineModule is pipeline yes doc Returns 'False' if both inputs are 'True'. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs a : type : boolean doc : A boolean describing this input state. b : type : boolean doc : A boolean describing this input state. pipeline outputs y : type : boolean doc : A boolean describing the module output state. processing stages stage 0 : and : module : logic.and desc : Returns 'True' if both inputs are 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y stage 1 : not : module : logic.not desc : Negates the input. inputs : - a \u2190 and.y outputs : - y \u2192 __pipeline__.y logic.nor \u00b6 class kiara_modules.core.logic.LogicNorPipelineModule is pipeline yes doc Returns 'True' if both inputs are 'False'. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs a : type : boolean doc : A boolean describing this input state. b : type : boolean doc : A boolean describing this input state. pipeline outputs y : type : boolean doc : A boolean describing the module output state. processing stages stage 0 : or : module : logic.or desc : Returns 'True' if one of the inputs is 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y stage 1 : not : module : logic.not desc : Negates the input. inputs : - a \u2190 or.y outputs : - y \u2192 __pipeline__.y logic.xor \u00b6 class kiara_modules.core.logic.LogicXorPipelineModule is pipeline yes doc Returns 'True' if exactly one of it's two inputs is 'True'. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs a : type : boolean doc : A boolean describing this input state. b : type : boolean doc : A boolean describing this input state. pipeline outputs y : type : boolean doc : A boolean describing the module output state. processing stages stage 0 : or : module : logic.or desc : Returns 'True' if one of the inputs is 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y nand : module : logic.nand desc : Returns 'False' if both inputs are 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y stage 1 : and : module : logic.and desc : Returns 'True' if both inputs are 'True'. inputs : - a \u2190 or.y - b \u2190 nand.y outputs : - y \u2192 __pipeline__.y","title":"logic"},{"location":"pipelines/logic/#kiara_info.modules.logic.nand","text":"class kiara_modules.core.logic.LogicNandPipelineModule is pipeline yes doc Returns 'False' if both inputs are 'True'. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs a : type : boolean doc : A boolean describing this input state. b : type : boolean doc : A boolean describing this input state. pipeline outputs y : type : boolean doc : A boolean describing the module output state. processing stages stage 0 : and : module : logic.and desc : Returns 'True' if both inputs are 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y stage 1 : not : module : logic.not desc : Negates the input. inputs : - a \u2190 and.y outputs : - y \u2192 __pipeline__.y","title":"logic.nand"},{"location":"pipelines/logic/#kiara_info.modules.logic.nor","text":"class kiara_modules.core.logic.LogicNorPipelineModule is pipeline yes doc Returns 'True' if both inputs are 'False'. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs a : type : boolean doc : A boolean describing this input state. b : type : boolean doc : A boolean describing this input state. pipeline outputs y : type : boolean doc : A boolean describing the module output state. processing stages stage 0 : or : module : logic.or desc : Returns 'True' if one of the inputs is 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y stage 1 : not : module : logic.not desc : Negates the input. inputs : - a \u2190 or.y outputs : - y \u2192 __pipeline__.y","title":"logic.nor"},{"location":"pipelines/logic/#kiara_info.modules.logic.xor","text":"class kiara_modules.core.logic.LogicXorPipelineModule is pipeline yes doc Returns 'True' if exactly one of it's two inputs is 'True'. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs a : type : boolean doc : A boolean describing this input state. b : type : boolean doc : A boolean describing this input state. pipeline outputs y : type : boolean doc : A boolean describing the module output state. processing stages stage 0 : or : module : logic.or desc : Returns 'True' if one of the inputs is 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y nand : module : logic.nand desc : Returns 'False' if both inputs are 'True'. inputs : - a \u2190 __pipeline__.a - b \u2190 __pipeline__.b outputs : - y stage 1 : and : module : logic.and desc : Returns 'True' if both inputs are 'True'. inputs : - a \u2190 or.y - b \u2190 nand.y outputs : - y \u2192 __pipeline__.y","title":"logic.xor"},{"location":"pipelines/table/","text":"","title":"table"},{"location":"pipelines/table/filter/","text":"table.filter.by_date \u00b6 class kiara_modules.core.table.TableFilterByDatePipelineModule is pipeline yes doc Filter a table by a date or date range. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs table : type : table doc : The table to use as input. column_name : type : string doc : The name of the table column to run the mapping \u2026 earliest : type : date doc : The earliest date that is allowed. latest : type : date doc : The latest date that is allowed. pipeline outputs table : type : table doc : The filtered table. processing stages stage 0 : create_filter_mask : module : table.map_column desc : Map the items of one column of a table onto a\u2026 inputs : - table \u2190 __pipeline__.table - column_name \u2190 __pipeline__.column_name - earliest \u2190 __pipeline__.earliest - latest \u2190 __pipeline__.latest outputs : - array stage 1 : filtered_table : module : table.filter.with_mask desc : Filter a table using a mask array. inputs : - table \u2190 __pipeline__.table - mask \u2190 create_filter_mask.array outputs : - table \u2192 __pipeline__.table","title":"filter"},{"location":"pipelines/table/filter/#kiara_info.modules.table.filter.by_date","text":"class kiara_modules.core.table.TableFilterByDatePipelineModule is pipeline yes doc Filter a table by a date or date range. config class kiara.pipeline.config.PipelineConfig config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. defaults object Value defaults for this module. documentation string Documentation about what the pipeline does. context object Metadata for this workflow. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 pipeline inputs table : type : table doc : The table to use as input. column_name : type : string doc : The name of the table column to run the mapping \u2026 earliest : type : date doc : The earliest date that is allowed. latest : type : date doc : The latest date that is allowed. pipeline outputs table : type : table doc : The filtered table. processing stages stage 0 : create_filter_mask : module : table.map_column desc : Map the items of one column of a table onto a\u2026 inputs : - table \u2190 __pipeline__.table - column_name \u2190 __pipeline__.column_name - earliest \u2190 __pipeline__.earliest - latest \u2190 __pipeline__.latest outputs : - array stage 1 : filtered_table : module : table.filter.with_mask desc : Filter a table using a mask array. inputs : - table \u2190 __pipeline__.table - mask \u2190 create_filter_mask.array outputs : - table \u2192 __pipeline__.table","title":"table.filter.by_date"},{"location":"reference/SUMMARY/","text":"kiara_modules core array utils boolean bytes msgpack database query utils date defaults dev dict file file_bundle generic import json list logic metadata_models operations pipelines python string table filter query utils value value_types yaml","title":"SUMMARY"},{"location":"reference/kiara_modules/core/__init__/","text":"Top-level package for kiara_modules.core. array special \u00b6 ArrayMetadataModule ( ExtractMetadataModule ) \u00b6 Extract metadata from an 'array' value. Source code in core/array/__init__.py class ArrayMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from an 'array' value.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"array\" @classmethod def get_metadata_key ( cls ) -> str : return \"array\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return ArrayMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa array : pa . Array = value . get_value_data () return { \"length\" : len ( array ), \"size\" : array . nbytes , } MapModule ( KiaraModule ) \u00b6 Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another kiara module. This 'child' module will then be used to compute the array items of the result. Source code in core/array/__init__.py class MapModule ( KiaraModule ): \"\"\"Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another *kiara* module. This 'child' module will then be used to compute the array items of the result. \"\"\" _config_cls = MapModuleConfig def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( id = \"map_module_child\" , module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_array : pa . Array = inputs . get_value_data ( \"array\" ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"array\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list )) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs module_instance_doc ( self ) \u00b6 Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/array/__init__.py def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result MapModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/array/__init__.py class MapModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , ) input_name : str pydantic-field \u00b6 The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input. module_config : Dict [ str , Any ] pydantic-field \u00b6 The config for the kiara filter module. module_type : str pydantic-field required \u00b6 The name of the kiara module to use to filter the input data. output_name : str pydantic-field \u00b6 The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. SampleArrayModule ( SampleValueModule ) \u00b6 Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/array/__init__.py class SampleArrayModule ( SampleValueModule ): \"\"\"Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"array\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= 100 : return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( 0 , sample_size ) return result_array def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( len ( array ) - sample_size ) return result_array get_value_type () classmethod \u00b6 Return the value type for this sample module. Source code in core/array/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"array\" StoreArrayTypeModule ( StoreValueTypeModule ) \u00b6 Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with kira to re-assemble the array object from disk. Source code in core/array/__init__.py class StoreArrayTypeModule ( StoreValueTypeModule ): \"\"\"Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with *kira* to re-assemble the array object from disk. \"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"array\" def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/array/__init__.py def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config bytes special \u00b6 LoadBytesModule ( KiaraModule ) \u00b6 Source code in core/bytes/__init__.py class LoadBytesModule ( KiaraModule ): _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) if not os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't read file, path does not exist: { path } \" ) with open ( path , \"rb\" ) as f : content = f . read () outputs . set_value ( \"bytes\" , content ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }} StoreBytesTypeModule ( StoreValueTypeModule ) \u00b6 Source code in core/bytes/__init__.py class StoreBytesTypeModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"bytes\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/bytes/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config msgpack \u00b6 DeserializeFromMsgPackModule ( KiaraModule ) \u00b6 Source code in core/bytes/msgpack.py class DeserializeFromMsgPackModule ( KiaraModule ): _module_type_name = \"to_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack msg = inputs . get_value_data ( \"bytes\" ) unpacked = msgpack . unpackb ( msg , raw = False ) value_type = unpacked [ \"value_type\" ] outputs . set_value ( \"value_type\" , value_type ) metadata = unpacked [ \"metadata\" ] outputs . set_value ( \"value_metadata\" , metadata ) new_data = unpacked [ \"data\" ] if not hasattr ( self , f \"to_ { value_type } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack deserialization: { value_type } \" ) func = getattr ( self , f \"to_ { value_type } \" ) obj = func ( data = new_data ) outputs . set_value ( \"value_data\" , obj ) def to_table ( self , data : bytes ) -> typing . Any : import pyarrow as pa reader = pa . ipc . open_stream ( data ) batches = [ b for b in reader ] new_table = pa . Table . from_batches ( batches ) return new_table def to_boolean ( self , data : bytes ): return data create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } SerializeToMsgPackModule ( KiaraModule ) \u00b6 Source code in core/bytes/msgpack.py class SerializeToMsgPackModule ( KiaraModule ): _module_type_name = \"from_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack type_name : str = self . get_config_value ( \"value_type\" ) if not hasattr ( self , f \"from_ { type_name } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack serialization: { type_name } \" ) func = getattr ( self , f \"from_ { type_name } \" ) value = inputs . get_value_obj ( \"value_item\" ) metadata = value . get_metadata ( also_return_schema = True ) msg = func ( value = value ) data = { \"value_type\" : value . type_name , \"metadata\" : metadata , \"data\" : msg } msg = msgpack . packb ( data , use_bin_type = True ) outputs . set_value ( \"bytes\" , msg ) def from_table ( self , value : Value ) -> bytes : import pyarrow as pa table_val : Value = value table : pa . Table = table_val . get_value_data () sink = pa . BufferOutputStream () writer = pa . ipc . new_stream ( sink , table . schema ) writer . write ( table ) writer . close () buf : pa . Buffer = sink . getvalue () return memoryview ( buf ) def from_boolean ( self , value : Value ) -> bytes : return value . get_value_data () create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/bytes/msgpack.py class SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to serialize/deserialize.\" ) value_type : str pydantic-field required \u00b6 The value type to serialize/deserialize. database special \u00b6 BaseDatabaseInfoMetadataModule ( ExtractMetadataModule ) \u00b6 Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class BaseDatabaseInfoMetadataModule ( ExtractMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> BaseModel : from sqlalchemy import inspect , text database : KiaraDatabase = value . get_value_data () inspector : Inspector = inspect ( database . get_sqlalchemy_engine ()) table_names = inspector . get_table_names () view_names = inspector . get_view_names () table_infos = {} for table in table_names : columns = inspector . get_columns ( table_name = table ) columns_info = {} with database . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { table } \" )) num_rows = result . fetchone ()[ 0 ] try : result = con . execute ( text ( f 'SELECT SUM(\"pgsize\") FROM \"dbstat\" WHERE name=\" { table } \"' ) ) table_size = result . fetchone ()[ 0 ] except Exception : table_size = None for column in columns : column_name = column [ \"name\" ] cs = ColumnSchema ( type_name = column [ \"type\" ] . __visit_name__ , metadata = { \"is_primary_key\" : column [ \"primary_key\" ] == 1 , \"nullable\" : column [ \"nullable\" ], }, ) columns_info [ column_name ] = cs table_infos [ table ] = TableMetadata ( column_names = list ( columns_info . keys ()), column_schema = columns_info , rows = num_rows , size = table_size , ) file_stats = os . stat ( database . db_file_path ) size = file_stats . st_size kdi = KiaraDatabaseInfo ( table_names = table_names , view_names = view_names , tables = table_infos , size = size , ) return kdi BaseDatabaseMetadataModule ( ExtractMetadataModule ) \u00b6 Extract basic metadata from a database object. Source code in core/database/__init__.py class BaseDatabaseMetadataModule ( ExtractMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> KiaraDatabase : database : KiaraDatabase = value . get_value_data () return database ConvertToDatabaseModule ( CreateValueModule ) \u00b6 Create a database from files, file_bundles, etc. Source code in core/database/__init__.py class ConvertToDatabaseModule ( CreateValueModule ): \"\"\"Create a database from files, file_bundles, etc.\"\"\" _module_type_name = \"create\" _config_cls = DatabaseConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"database\" def from_table ( self , value : Value ): import pyarrow as pa from sqlalchemy import MetaData , Table from kiara_modules.core.table.utils import ( create_sqlite_schema_data_from_arrow_table , ) table : pa . Table = value . get_value_data () # maybe we could check the values lineage, to find the best table name? table_name = value . id . replace ( \"-\" , \"_\" ) index_columns = [] for cn in table . column_names : if cn . lower () == \"id\" : index_columns . append ( cn ) column_info : SqliteTableSchema = create_sqlite_schema_data_from_arrow_table ( table = table , index_columns = index_columns ) init_sql = create_table_init_sql ( table_name = table_name , table_schema = column_info ) db = KiaraDatabase . create_in_temp_dir ( init_sql = init_sql ) nodes_column_map : typing . Dict [ str , typing . Any ] = {} for batch in table . to_batches ( DEFAULT_DB_CHUNK_SIZE ): batch_dict = batch . to_pydict () for k , v in nodes_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] engine = db . get_sqlalchemy_engine () _metadata_obj = MetaData () sqlite_table = Table ( table_name , _metadata_obj , autoload_with = engine ) with engine . connect () as conn : with conn . begin (): conn . execute ( sqlite_table . insert (), data ) return db def from_csv_file ( self , value : Value ): f = tempfile . mkdtemp () db_path = os . path . join ( f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( f , ignore_errors = True ) atexit . register ( cleanup ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = value . get_value_data () ) return db_path def from_csv_file_bundle ( self , value : Value ): include_file_information : bool = True include_raw_content_in_file_info : bool = False temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = KiaraDatabase ( db_file_path = db_path ) db . create_if_not_exists () bundle : KiaraFileBundle = value . get_value_data () table_names : typing . List [ str ] = [] for rel_path in sorted ( bundle . included_files . keys ()): file_item = bundle . included_files [ rel_path ] table_name = find_free_id ( stem = file_item . file_name_without_extension , current_ids = table_names ) try : table_names . append ( table_name ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = file_item , table_name = table_name ) except Exception as e : if self . get_config_value ( \"ignore_errors\" ) is True or True : log_message ( f \"Ignoring file ' { rel_path } ': could not import data from file -- { e } \" ) continue raise KiaraProcessingException ( e ) if include_file_information : create_table_from_file_bundle ( file_bundle = value . get_value_data (), db_file_path = db_path , table_name = \"source_files_metadata\" , include_content = include_raw_content_in_file_info , ) return db_path def from_text_file_bundle ( self , value : Value ): return create_table_from_file_bundle ( file_bundle = value . get_value_data (), include_content = True ) DatabaseConversionModuleConfig ( CreateValueModuleConfig ) pydantic-model \u00b6 Source code in core/database/__init__.py class DatabaseConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , ) ignore_errors : bool pydantic-field \u00b6 Whether to ignore convert errors and omit the failed items. DatabaseInfoMetadataModule ( BaseDatabaseInfoMetadataModule ) \u00b6 Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class DatabaseInfoMetadataModule ( BaseDatabaseInfoMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" _module_type_name = \"info\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database_info\" DatabaseMetadataModule ( BaseDatabaseMetadataModule ) \u00b6 Extract basic metadata from a database object. Source code in core/database/__init__.py class DatabaseMetadataModule ( BaseDatabaseMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database\" LoadDatabaseConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/database/__init__.py class LoadDatabaseConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The type of the value to be stored (if database sub-type).\" , default = \"database\" , ) value_type : str pydantic-field \u00b6 The type of the value to be stored (if database sub-type). LoadDatabaseModule ( KiaraModule ) \u00b6 Source code in core/database/__init__.py class LoadDatabaseModule ( KiaraModule ): _module_type_name = \"load\" _config_cls = LoadDatabaseConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) outputs . set_value ( \"database\" , path ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs StoreDatabaseTypeModule ( StoreValueTypeModule ) \u00b6 Save an sqlite database to a file. Source code in core/database/__init__.py class StoreDatabaseTypeModule ( StoreValueTypeModule ): \"\"\"Save an sqlite database to a file.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"database\" def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db ) store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/database/__init__.py def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db ) query \u00b6 QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/database/query.py class QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) query : str pydantic-field \u00b6 The query to execute. If not specified, the user will be able to provide their own. QueryTableSQL ( KiaraModule ) \u00b6 Execute a sql query against an (Arrow) table. Source code in core/database/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryDatabaseSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pandas as pd import pyarrow as pa if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) else : _query = self . get_config_value ( \"query\" ) _database : KiaraDatabase = inputs . get_value_data ( \"database\" ) # can't re-use the default engine, because pandas does not support having the 'future' flag set to 'True' engine = create_engine ( _database . db_url ) df = pd . read_sql ( _query , con = engine ) table = pa . Table . from_pandas ( df ) outputs . set_value ( \"query_result\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} utils \u00b6 SqliteColumnAttributes ( BaseModel ) pydantic-model \u00b6 Source code in core/database/utils.py class SqliteColumnAttributes ( BaseModel ): data_type : str = Field ( description = \"The type of the data in this column.\" , default = \"ANY\" ) extra_column_info : typing . List [ str ] = Field ( description = \"Additional init information for the column.\" , default_factory = list ) create_index : bool = Field ( description = \"Whether to create an index for this column or not.\" , default = False ) create_index : bool pydantic-field \u00b6 Whether to create an index for this column or not. data_type : str pydantic-field \u00b6 The type of the data in this column. extra_column_info : List [ str ] pydantic-field \u00b6 Additional init information for the column. SqliteTableSchema ( BaseModel ) pydantic-model \u00b6 Source code in core/database/utils.py class SqliteTableSchema ( BaseModel ): columns : typing . Dict [ str , SqliteColumnAttributes ] = Field ( description = \"The table columns and their attributes.\" ) extra_schema : typing . List [ str ] = Field ( description = \"Extra schema information for this table.\" , default_factory = list ) column_map : typing . Dict [ str , str ] = Field ( description = \"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.\" , default_factory = dict , ) column_map : Dict [ str , str ] pydantic-field \u00b6 A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute. columns : Dict [ str , kiara_modules . core . database . utils . SqliteColumnAttributes ] pydantic-field required \u00b6 The table columns and their attributes. extra_schema : List [ str ] pydantic-field \u00b6 Extra schema information for this table. create_table_init_sql ( table_name , table_schema , schema_template_str = None ) \u00b6 Create an sql script to initialize a table. Parameters: Name Type Description Default column_attrs a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values required Source code in core/database/utils.py def create_table_init_sql ( table_name : str , table_schema : SqliteTableSchema , schema_template_str : typing . Optional [ str ] = None , ): \"\"\"Create an sql script to initialize a table. Arguments: column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values \"\"\" if schema_template_str is None : template_path = Path ( TEMPLATES_FOLDER ) / \"sqlite_schama.sql.j2\" schema_template_str = template_path . read_text () template = Environment ( loader = BaseLoader ()) . from_string ( schema_template_str ) edges_columns = [] edge_indexes = [] lines = [] for cn , details in table_schema . columns . items (): cn_type = details . data_type cn_extra = details . extra_column_info line = f \" { cn } { cn_type } \" if cn_extra : line = f \" { line } { ' ' . join ( cn_extra ) } \" edges_columns . append ( line ) if details . create_index : edge_indexes . append ( cn ) lines . append ( line ) lines . extend ( table_schema . extra_schema ) rendered = template . render ( table_name = table_name , column_info = lines , index_columns = edge_indexes ) return rendered date \u00b6 A collection of date related modules. Most of those are very bare-bones, not really dealing with more advanced (but very important) concepts like timezones and resolution yet. DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"range_check\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser d = inputs . get_value_data ( \"date\" ) earliest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if hasattr ( d , \"as_py\" ): d = d . as_py () if isinstance ( d , str ): d = parser . parse ( d ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"extract_from_string\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) date_match = re . findall ( r \"_(\\d {4} -\\d {2} -\\d {2} )_\" , text ) assert date_match d_obj = parser . parse ( date_match [ 0 ]) # type: ignore outputs . set_value ( \"date\" , d_obj ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } defaults \u00b6 KIARA_MODULES_CORE_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_MODULES_CORE_RESOURCES_FOLDER \u00b6 Default resources folder for this package. dev \u00b6 Modules that are useful for kiara as well as pipeline-development, as well as testing. DummyModule ( KiaraModule ) \u00b6 Module that simulates processing, but uses hard-coded outputs as a result. Source code in core/dev.py class DummyModule ( KiaraModule ): \"\"\"Module that simulates processing, but uses hard-coded outputs as a result.\"\"\" _config_cls = DummyProcessingModuleConfig def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) # def _get_doc(self) -> str: # # doc = self.config.get(\"doc\", None) # # if doc: # return self.config[\"doc\"] # else: # return super()._get_doc() create_input_schema ( self ) \u00b6 The input schema for the dummy module is created at object creation time from the input_schemas config parameter. Source code in core/dev.py def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result create_output_schema ( self ) \u00b6 The output schema for the dummy module is created at object creation time from the output_schemas config parameter. Source code in core/dev.py def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result process ( self , inputs , outputs ) \u00b6 Returns the hardcoded output values that are set in the outputs config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the delay config parameter). Source code in core/dev.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) DummyProcessingModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Configuration for the 'dummy' processing module. Source code in core/dev.py class DummyProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Configuration for the 'dummy' processing module.\"\"\" documentation : typing . Optional [ str ] = None input_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The input schema for this module.\" ) output_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The output schema for this module.\" ) outputs : typing . Dict [ str , typing . Any ] = Field ( description = \"The (dummy) output for this module.\" , default_factory = dict ) delay : float = Field ( description = \"The delay in seconds from processing start to when the (dummy) outputs are returned.\" , default = 0 , ) delay : float pydantic-field \u00b6 The delay in seconds from processing start to when the (dummy) outputs are returned. input_schema : Dict [ str , Dict ] pydantic-field required \u00b6 The input schema for this module. output_schema : Dict [ str , Dict ] pydantic-field required \u00b6 The output schema for this module. outputs : Dict [ str , Any ] pydantic-field \u00b6 The (dummy) output for this module. dict \u00b6 SaveDictModule ( StoreValueTypeModule ) \u00b6 Source code in core/dict.py class SaveDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"dict\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/dict.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config file \u00b6 DefaultFileImportModule ( FileImportModule ) \u00b6 Import an external file into a kiara session. Source code in core/file.py class DefaultFileImportModule ( FileImportModule ): \"\"\"Import an external file into a kiara session.\"\"\" _module_type_name = \"import\" def import_from__file_path__string ( self , source : str ) -> KiaraFile : file_model = KiaraFile . load_file ( source ) return file_model LoadLocalFileModule ( KiaraModule ) \u00b6 Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. Source code in core/file.py class LoadLocalFileModule ( KiaraModule ): \"\"\"Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. \"\"\" # _config_cls = ImportLocalPathConfig _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) file_model = KiaraFile . load_file ( path ) outputs . set_value ( \"file\" , file_model ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } StoreFileTypeModule ( StoreValueTypeModule ) \u00b6 Save a file to disk. Source code in core/file.py class StoreFileTypeModule ( StoreValueTypeModule ): \"\"\"Save a file to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm ) store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/file.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm ) file_bundle \u00b6 DefaultFileBundleImportModule ( FileBundleImportModule ) \u00b6 Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. Source code in core/file_bundle.py class DefaultFileBundleImportModule ( FileBundleImportModule ): \"\"\"Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. \"\"\" _module_type_name = \"import\" def import_from__folder_path__string ( self , source : str ) -> KiaraFileBundle : file_bundle_model = KiaraFileBundle . import_folder ( source ) return file_bundle_model LoadFileBundleModule ( KiaraModule ) \u00b6 Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. Source code in core/file_bundle.py class LoadFileBundleModule ( KiaraModule ): \"\"\"Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. \"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) included_files = inputs . get_value_data ( \"include_files\" ) excluded_dirs = inputs . get_value_data ( \"exclude_dirs\" ) excluded_files = inputs . get_value_data ( \"exclude_files\" ) import_config = FolderImportConfig ( include_files = included_files , exclude_dirs = excluded_dirs , excluded_files = excluded_files , ) bundle = KiaraFileBundle . import_folder ( source = path , import_config = import_config ) outputs . set_values ( file_bundle = bundle ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } StoreFileBundleType ( StoreValueTypeModule ) \u00b6 Save a file bundle to disk. Source code in core/file_bundle.py class StoreFileBundleType ( StoreValueTypeModule ): \"\"\"Save a file bundle to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file_bundle\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb ) store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/file_bundle.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb ) generic \u00b6 JsonSerializationConfig ( StoreValueModuleConfig ) pydantic-model \u00b6 Source code in core/generic.py class JsonSerializationConfig ( StoreValueModuleConfig ): options : int = Field ( description = \"The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details.\" , default = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) file_name : str = Field ( description = \"The name of the serialized file.\" , default = \"dict.json\" ) file_name : str pydantic-field \u00b6 The name of the serialized file. options : int pydantic-field \u00b6 The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details. RestoreFromJsonDictModule ( KiaraModule ) \u00b6 Source code in core/generic.py class RestoreFromJsonDictModule ( KiaraModule ): _module_type_name = \"restore_from_json\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) file_name = inputs . get_value_data ( \"file_name\" ) full_path = os . path . join ( base_path , file_name ) if not os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't deserialize dict, path to file does not exist: { full_path } \" ) if not os . path . isfile ( os . path . realpath ( full_path )): raise KiaraProcessingException ( f \"Can't deserialize dict, path is not a file: { full_path } \" ) with open ( full_path , \"r\" ) as f : content = f . read () data = orjson . loads ( content ) outputs . set_value ( \"value_item\" , data ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }} RestoreScalarModule ( KiaraModule ) \u00b6 Utility module, only used internally. Source code in core/generic.py class RestoreScalarModule ( KiaraModule ): \"\"\"Utility module, only used internally.\"\"\" _module_type_name = \"restore_scalar\" _config_cls = RestoreScalarModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : data = inputs . get_value_obj ( \"scalar_data\" ) outputs . set_value ( \"value_item\" , data ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } } RestoreScalarModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/generic.py class RestoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to load.\" ) value_type : str pydantic-field required \u00b6 The value type of the scalar to load. StoreScalarModule ( StoreValueTypeModule ) \u00b6 Source code in core/generic.py class StoreScalarModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return [ \"boolean\" , \"integer\" , \"float\" , \"string\" ] def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/generic.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config StoreScalarModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/generic.py class StoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to store.\" ) value_type : str pydantic-field required \u00b6 The value type of the scalar to store. json \u00b6 ToJsonModuleOld ( OldTypeConversionModule ) \u00b6 Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. Source code in core/json.py class ToJsonModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. \"\"\" _module_type_name = \"to_json\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return JSON_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"json\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_json ( self . _kiara , data = input_value , convert_config = config ) return input_value_str list \u00b6 IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"contains\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs StoreDictModule ( StoreValueTypeModule ) \u00b6 Source code in core/list.py class StoreDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"list\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/list.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config logic \u00b6 AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core/logic.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } LogicProcessingModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core/logic.py class LogicProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core/logic.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) create_input_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_output_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core/logic.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core/logic.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } metadata_models \u00b6 This module contains the metadata models that are used in the kiara_modules.core package. Metadata models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata that is attached to data, as well as kiara modules. It is possible to register metadata using a JSON schema string, but it is recommended to create a metadata model, because it is much easier overall. Metadata models must be a sub-class of kiara.metadata.MetadataModel . ArrayMetadata ( HashedMetadataModel ) pydantic-model \u00b6 Describes properties fo the 'array' type. Source code in core/metadata_models.py class ArrayMetadata ( HashedMetadataModel ): \"\"\"Describes properties fo the 'array' type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"array\" length : int = Field ( description = \"The number of elements the array contains.\" ) size : int = Field ( description = \"Total number of bytes consumed by the elements of the array.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"length\" : self . length , \"size\" : self . size } def get_category_alias ( self ) -> str : return \"instance.metadata.array\" length : int pydantic-field required \u00b6 The number of elements the array contains. size : int pydantic-field required \u00b6 Total number of bytes consumed by the elements of the array. ColumnSchema ( BaseModel ) pydantic-model \u00b6 Describes properties of a single column of the 'table' data type. Source code in core/metadata_models.py class ColumnSchema ( BaseModel ): \"\"\"Describes properties of a single column of the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"column\" type_name : str = Field ( description = \"The type name of the column (backend-specific).\" ) metadata : typing . Dict [ str , typing . Any ] = Field ( description = \"Other metadata for the column.\" , default_factory = dict ) metadata : Dict [ str , Any ] pydantic-field \u00b6 Other metadata for the column. type_name : str pydantic-field required \u00b6 The type name of the column (backend-specific). FolderImportConfig ( BaseModel ) pydantic-model \u00b6 Source code in core/metadata_models.py class FolderImportConfig ( BaseModel ): include_files : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, include all files where the filename ends with that string.\" , default = None , ) exclude_dirs : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, exclude all folders whose name ends with that string.\" , default = None , ) exclude_files : typing . Optional [ typing . List [ str ]] = Field ( description = f \"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } .\" , default = DEFAULT_EXCLUDE_FILES , ) exclude_dirs : List [ str ] pydantic-field \u00b6 A list of strings, exclude all folders whose name ends with that string. exclude_files : List [ str ] pydantic-field \u00b6 A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: ['.DS_Store']. include_files : List [ str ] pydantic-field \u00b6 A list of strings, include all files where the filename ends with that string. KiaraDatabase ( MetadataModel ) pydantic-model \u00b6 Source code in core/metadata_models.py class KiaraDatabase ( MetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database\" @classmethod def create_in_temp_dir ( cls , init_sql : typing . Optional [ str ] = None ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path ) db . create_if_not_exists () if init_sql : db . execute_sql ( sql_script = init_sql , invalidate = True ) return db db_file_path : str = Field ( description = \"The path to the sqlite database file.\" ) _cached_engine = PrivateAttr ( default = None ) _cached_inspector = PrivateAttr ( default = None ) _table_names = PrivateAttr ( default = None ) _table_schemas = PrivateAttr ( default = None ) def get_id ( self ) -> str : return self . db_file_path def get_category_alias ( self ) -> str : return \"instance.metadata.database\" @validator ( \"db_file_path\" , allow_reuse = True ) def ensure_absolute_path ( cls , path : str ): path = os . path . abspath ( path ) if not os . path . exists ( os . path . dirname ( path )): raise ValueError ( f \"Parent folder for database file does not exist: { path } \" ) return path @property def db_url ( self ) -> str : return f \"sqlite:/// { self . db_file_path } \" def get_sqlalchemy_engine ( self ) -> \"Engine\" : if self . _cached_engine is not None : return self . _cached_engine from sqlalchemy import create_engine self . _cached_engine = create_engine ( self . db_url , future = True ) # with self._cached_engine.connect() as con: # con.execute(text(\"PRAGMA query_only = ON\")) return self . _cached_engine def create_if_not_exists ( self ): from sqlalchemy_utils import create_database , database_exists if not database_exists ( self . db_url ): create_database ( self . db_url ) def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None def copy_database_file ( self , target : str ): os . makedirs ( os . path . dirname ( target )) shutil . copy2 ( self . db_file_path , target ) new_db = KiaraDatabase ( db_file_path = target ) return new_db def get_sqlalchemy_inspector ( self ) -> \"Inspector\" : if self . _cached_inspector is not None : return self . _cached_inspector self . _cached_inspector = inspect ( self . get_sqlalchemy_engine ()) return self . _cached_inspector @property def table_names ( self ) -> typing . Iterable [ str ]: if self . _table_names is not None : return self . _table_names self . _table_names = self . get_sqlalchemy_inspector () . get_table_names () return self . _table_names def get_schema_for_table ( self , table_name : str ): if self . _table_schemas is not None : if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ] ts : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} inspector = self . get_sqlalchemy_inspector () for tn in inspector . get_table_names (): columns = self . get_sqlalchemy_inspector () . get_columns ( tn ) ts [ tn ] = {} for c in columns : ts [ tn ][ c [ \"name\" ]] = c self . _table_schemas = ts if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ] db_file_path : str pydantic-field required \u00b6 The path to the sqlite database file. execute_sql ( self , sql_script , invalidate = False ) \u00b6 Execute an sql script. Parameters: Name Type Description Default sql_script str the sql script required invalidate bool whether to invalidate cached values within this object False Source code in core/metadata_models.py def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None KiaraDatabaseInfo ( HashedMetadataModel ) pydantic-model \u00b6 Source code in core/metadata_models.py class KiaraDatabaseInfo ( HashedMetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database_info\" table_names : typing . List [ str ] = Field ( description = \"The names of all tables in this database.\" ) view_names : typing . List [ str ] = Field ( description = \"The names of all views in this database.\" ) tables : typing . Dict [ str , TableMetadata ] = Field ( description = \"Information about the tables within this database.\" ) size : int = Field ( description = \"The size of the database file.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"table_names\" : self . table_names , \"view_names\" : self . view_names , \"tables\" : self . tables , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.database_info\" size : int pydantic-field required \u00b6 The size of the database file. table_names : List [ str ] pydantic-field required \u00b6 The names of all tables in this database. tables : Dict [ str , kiara_modules . core . metadata_models . TableMetadata ] pydantic-field required \u00b6 Information about the tables within this database. view_names : List [ str ] pydantic-field required \u00b6 The names of all views in this database. KiaraFile ( MetadataModel ) pydantic-model \u00b6 Describes properties for the 'file' value type. Source code in core/metadata_models.py class KiaraFile ( MetadataModel ): \"\"\"Describes properties for the 'file' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file\" @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m _file_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_filename : str = Field ( description = \"The original filename of this file at the time of import.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this file at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) mime_type : str = Field ( description = \"The mime type of the file.\" ) file_name : str = Field ( \"The name of the file.\" ) size : int = Field ( description = \"The size of the file.\" ) path : str = Field ( description = \"The archive path of the file.\" ) is_onboarded : bool = Field ( description = \"Whether the file is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file\" def copy_file ( self , target : str , incl_orig_path : bool = False , is_onboarded : bool = False ): fm = KiaraFile . load_file ( self . path , target ) if incl_orig_path : fm . orig_path = self . orig_path else : fm . orig_path = None fm . orig_filename = self . orig_filename fm . import_time = self . import_time if self . _file_hash is not None : fm . _file_hash = self . _file_hash fm . is_onboarded = is_onboarded return fm @property def file_hash ( self ): if self . _file_hash is not None : return self . _file_hash sha256_hash = hashlib . sha3_256 () with open ( self . path , \"rb\" ) as f : # Read and update hash string value in blocks of 4K for byte_block in iter ( lambda : f . read ( 4096 ), b \"\" ): sha256_hash . update ( byte_block ) self . _file_hash = sha256_hash . hexdigest () return self . _file_hash @property def file_name_without_extension ( self ) -> str : return self . file_name . split ( \".\" )[ 0 ] @property def import_time_as_datetime ( self ) -> datetime . datetime : from dateutil import parser return parser . parse ( self . import_time ) def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\" def __str__ ( self ): return self . __repr__ () import_time : str pydantic-field required \u00b6 The time when the file was imported. is_onboarded : bool pydantic-field \u00b6 Whether the file is imported into the kiara data store. mime_type : str pydantic-field required \u00b6 The mime type of the file. orig_filename : str pydantic-field required \u00b6 The original filename of this file at the time of import. orig_path : str pydantic-field \u00b6 The original path to this file at the time of import. path : str pydantic-field required \u00b6 The archive path of the file. size : int pydantic-field required \u00b6 The size of the file. __repr__ ( self ) special \u00b6 Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\" __str__ ( self ) special \u00b6 Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ () load_file ( source , target = None , incl_orig_path = False ) classmethod \u00b6 Utility method to read metadata of a file from disk and optionally move it into a data archive location. Source code in core/metadata_models.py @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m read_content ( self , as_str = True , max_lines =- 1 ) \u00b6 Read the content of a file. Source code in core/metadata_models.py def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content KiaraFileBundle ( MetadataModel ) pydantic-model \u00b6 Describes properties for the 'file_bundle' value type. Source code in core/metadata_models.py class KiaraFileBundle ( MetadataModel ): \"\"\"Describes properties for the 'file_bundle' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file_bundle\" @classmethod def import_folder ( cls , source : str , target : typing . Optional [ str ] = None , import_config : typing . Union [ None , typing . Mapping [ str , typing . Any ], FolderImportConfig ] = None , incl_orig_path : bool = False , ): if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isdir ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) if target and os . path . exists ( target ): raise ValueError ( f \"Target path already exists: { target } \" ) if source . endswith ( os . path . sep ): source = source [ 0 : - 1 ] if target and target . endswith ( os . path . sep ): target = target [ 0 : - 1 ] if import_config is None : _import_config = FolderImportConfig () elif isinstance ( import_config , typing . Mapping ): _import_config = FolderImportConfig ( ** import_config ) elif isinstance ( import_config , FolderImportConfig ): _import_config = import_config else : raise TypeError ( f \"Invalid type for folder import config: { type ( import_config ) } .\" ) included_files : typing . Dict [ str , KiaraFile ] = {} exclude_dirs = _import_config . exclude_dirs invalid_extensions = _import_config . exclude_files valid_extensions = _import_config . include_files sum_size = 0 def include_file ( filename : str ) -> bool : if invalid_extensions and any ( filename . endswith ( ext ) for ext in invalid_extensions ): return False if not valid_extensions : return True else : return any ( filename . endswith ( ext ) for ext in valid_extensions ) for root , dirnames , filenames in os . walk ( source , topdown = True ): if exclude_dirs : dirnames [:] = [ d for d in dirnames if d not in exclude_dirs ] for filename in [ f for f in filenames if os . path . isfile ( os . path . join ( root , f )) and include_file ( f ) ]: full_path = os . path . join ( root , filename ) rel_path = os . path . relpath ( full_path , source ) if target : target_path : typing . Optional [ str ] = os . path . join ( target , rel_path ) else : target_path = None file_model = KiaraFile . load_file ( full_path , target_path , incl_orig_path = incl_orig_path ) sum_size = sum_size + file_model . size included_files [ rel_path ] = file_model orig_bundle_name = os . path . basename ( source ) if incl_orig_path : orig_path : typing . Optional [ str ] = source else : orig_path = None if target : path = target else : path = source return KiaraFileBundle . create_from_file_models ( files = included_files , orig_bundle_name = orig_bundle_name , orig_path = orig_path , path = path , sum_size = sum_size , ) @classmethod def create_from_file_models ( self , files : typing . Mapping [ str , KiaraFile ], orig_bundle_name : str , orig_path : typing . Optional [ str ], path : str , sum_size : typing . Optional [ int ] = None , is_onboarded : bool = False , ): result : typing . Dict [ str , typing . Any ] = {} result [ \"included_files\" ] = files result [ \"orig_path\" ] = orig_path result [ \"path\" ] = path result [ \"import_time\" ] = datetime . datetime . now () . isoformat () result [ \"number_of_files\" ] = len ( files ) result [ \"bundle_name\" ] = os . path . basename ( result [ \"path\" ]) result [ \"orig_bundle_name\" ] = orig_bundle_name result [ \"is_onboarded\" ] = is_onboarded if sum_size is None : sum_size = 0 for f in files . values (): sum_size = sum_size + f . size result [ \"size\" ] = sum_size return KiaraFileBundle ( ** result ) _file_bundle_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_bundle_name : str = Field ( description = \"The original name of this folder at the time of import.\" ) bundle_name : str = Field ( description = \"The name of this bundle.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this folder at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) number_of_files : int = Field ( description = \"How many files are included in this bundle.\" ) included_files : typing . Dict [ str , KiaraFile ] = Field ( description = \"A map of all the included files, incl. their properties. Uses the relative path of each file as key.\" ) size : int = Field ( description = \"The size of all files in this folder, combined.\" ) path : str = Field ( description = \"The archive path of the folder.\" ) is_onboarded : bool = Field ( description = \"Whether this bundle is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file_bundle\" def get_relative_path ( self , file : KiaraFile ): return os . path . relpath ( file . path , self . path ) def read_text_file_contents ( self , ignore_errors : bool = False ) -> typing . Mapping [ str , str ]: content_dict : typing . Dict [ str , str ] = {} def read_file ( rel_path : str , fm : KiaraFile ): with open ( fm . path , encoding = \"utf-8\" ) as f : try : content = f . read () content_dict [ rel_path ] = content # type: ignore except Exception as e : if ignore_errors : log_message ( f \"Can't read file: { e } \" ) log . warning ( f \"Ignoring file: { fm . path } \" ) else : raise Exception ( f \"Can't read file (as text) ' { fm . path } : { e } \" ) # TODO: common ignore files and folders for f in self . included_files . values (): rel_path = self . get_relative_path ( f ) read_file ( rel_path = rel_path , fm = f ) return content_dict @property def file_bundle_hash ( self ): if self . _file_bundle_hash is not None : return self . _file_bundle_hash # hash_format =\"sha3-256\" hashes = \"\" for path in sorted ( self . included_files . keys ()): fm = self . included_files [ path ] hashes = hashes + \"_\" + path + \"_\" + fm . file_hash self . _file_bundle_hash = hashlib . sha3_256 ( hashes . encode ( \"utf-8\" )) . hexdigest () return self . _file_bundle_hash def copy_bundle ( self , target_path : str , incl_orig_path : bool = False , is_onboarded : bool = False ) -> \"KiaraFileBundle\" : if target_path == self . path : raise Exception ( f \"Target path and current path are the same: { target_path } \" ) result = {} for rel_path , item in self . included_files . items (): _target_path = os . path . join ( target_path , rel_path ) new_fm = item . copy_file ( _target_path , is_onboarded = is_onboarded ) result [ rel_path ] = new_fm if incl_orig_path : orig_path = self . orig_path else : orig_path = None fb = KiaraFileBundle . create_from_file_models ( result , orig_bundle_name = self . orig_bundle_name , orig_path = orig_path , path = target_path , sum_size = self . size , is_onboarded = is_onboarded , ) if self . _file_bundle_hash is not None : fb . _file_bundle_hash = self . _file_bundle_hash return fb def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\" def __str__ ( self ): return self . __repr__ () bundle_name : str pydantic-field required \u00b6 The name of this bundle. import_time : str pydantic-field required \u00b6 The time when the file was imported. included_files : Dict [ str , kiara_modules . core . metadata_models . KiaraFile ] pydantic-field required \u00b6 A map of all the included files, incl. their properties. Uses the relative path of each file as key. is_onboarded : bool pydantic-field \u00b6 Whether this bundle is imported into the kiara data store. number_of_files : int pydantic-field required \u00b6 How many files are included in this bundle. orig_bundle_name : str pydantic-field required \u00b6 The original name of this folder at the time of import. orig_path : str pydantic-field \u00b6 The original path to this folder at the time of import. path : str pydantic-field required \u00b6 The archive path of the folder. size : int pydantic-field required \u00b6 The size of all files in this folder, combined. __repr__ ( self ) special \u00b6 Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\" __str__ ( self ) special \u00b6 Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ () TableMetadata ( HashedMetadataModel ) pydantic-model \u00b6 Describes properties for the 'table' data type. Source code in core/metadata_models.py class TableMetadata ( HashedMetadataModel ): \"\"\"Describes properties for the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"table\" column_names : typing . List [ str ] = Field ( description = \"The name of the columns of the table.\" ) column_schema : typing . Dict [ str , ColumnSchema ] = Field ( description = \"The schema description of the table.\" ) rows : int = Field ( description = \"The number of rows the table contains.\" ) size : typing . Optional [ int ] = Field ( description = \"The tables size in bytes.\" , default = None ) def _obj_to_hash ( self ) -> typing . Any : return { \"column_names\" : self . column_names , \"column_schemas\" : { k : v . dict () for k , v in self . column_schema . items ()}, \"rows\" : self . rows , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.table\" column_names : List [ str ] pydantic-field required \u00b6 The name of the columns of the table. column_schema : Dict [ str , kiara_modules . core . metadata_models . ColumnSchema ] pydantic-field required \u00b6 The schema description of the table. rows : int pydantic-field required \u00b6 The number of rows the table contains. size : int pydantic-field \u00b6 The tables size in bytes. pipelines special \u00b6 Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder. string \u00b6 DeserializeStringModule ( KiaraModule ) \u00b6 Source code in core/string.py class DeserializeStringModule ( KiaraModule ): _module_type_name = \"deserialize\" _config_cls = DeserializeStringModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : serialization_type = self . get_config_value ( \"serialization_type\" ) if serialization_type not in [ \"json\" ]: raise KiaraProcessingException ( f \"Can't deserialize string: serialisation type ' { serialization_type } ' not supported.\" ) serialized = inputs . get_value_data ( \"serialized\" ) outputs . set_value ( \"value_item\" , serialized ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }} DeserializeStringModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/string.py class DeserializeStringModuleConfig ( ModuleTypeConfigSchema ): serialization_type : str = Field ( description = \"The serialization type that was used to serialize the value.\" ) serialization_type : str pydantic-field required \u00b6 The serialization type that was used to serialize the value. RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"match_regex\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema RegexModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/string.py class RegexModuleConfig ( ModuleTypeConfigSchema ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/string.py class ReplaceModuleConfig ( ModuleTypeConfigSchema ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} StringManipulationModule ( KiaraModule ) \u00b6 Base module to simplify creating other modules that do string manipulation. Source code in core/string.py class StringManipulationModule ( KiaraModule ): \"\"\"Base module to simplify creating other modules that do string manipulation.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_string = inputs . get_value_data ( \"text\" ) result = self . process_string ( input_string ) outputs . set_value ( \"text\" , result ) @abstractmethod def process_string ( self , text : str ) -> str : pass create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }} table special \u00b6 ConvertToTableModule ( CreateValueModule ) \u00b6 Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: bytes: a memoryview of the byte-representation of the Table string: the base64-encoded byte-representation of the Table Source code in core/table/__init__.py class ConvertToTableModule ( CreateValueModule ): \"\"\"Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: - bytes: a memoryview of the byte-representation of the Table - string: the base64-encoded byte-representation of the Table \"\"\" _module_type_name = \"create\" _config_cls = TableConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"table\" # def to_bytes(self, value: Value) -> bytes: # # import pyarrow as pa # # table_val: Value = value # table: pa.Table = table_val.get_value_data() # # batches = table.to_batches() # # sink = pa.BufferOutputStream() # writer = pa.ipc.new_stream(sink, batches[0].schema) # # for batch in batches: # writer.write_batch(batch) # writer.close() # # buf: pa.Buffer = sink.getvalue() # return memoryview(buf) # # def to_string(self, value: Value): # # _bytes: bytes = self.to_bytes(value) # string = base64.b64encode(_bytes) # return string.decode() # def from_bytes(self, value: Value): # raise NotImplementedError() # # def from_string(self, value: Value): # raise NotImplementedError() def from_csv_file ( self , value : Value ): from pyarrow import csv input_file : KiaraFile = value . get_value_data () imported_data = csv . read_csv ( input_file . path ) return imported_data def from_text_file_bundle ( self , value : Value ): import pyarrow as pa bundle : KiaraFileBundle = value . get_value_data () columns = FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS ignore_errors = self . get_config_value ( \"ignore_errors\" ) file_dict = bundle . read_text_file_contents ( ignore_errors = ignore_errors ) tabular : typing . Dict [ str , typing . List [ typing . Any ]] = {} for column in columns : for index , rel_path in enumerate ( sorted ( file_dict . keys ())): if column == \"content\" : _value : typing . Any = file_dict [ rel_path ] elif column == \"id\" : _value = index elif column == \"rel_path\" : _value = rel_path else : file_model = bundle . included_files [ rel_path ] _value = getattr ( file_model , column ) tabular . setdefault ( column , []) . append ( _value ) table = pa . Table . from_pydict ( tabular ) return table CutColumnModule ( KiaraModule ) \u00b6 Cut off one column from a table, returning an array. Source code in core/table/__init__.py class CutColumnModule ( KiaraModule ): \"\"\"Cut off one column from a table, returning an array.\"\"\" _module_type_name = \"cut_column\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table_value = inputs . get_value_obj ( \"table\" ) column_name : str = inputs . get_value_data ( \"column_name\" ) available = table_value . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if column_name not in available : raise KiaraProcessingException ( f \"Invalid column name ' { column_name } '. Available column names: { available } \" ) table : pa . Table = inputs . get_value_data ( \"table\" ) column = table . column ( column_name ) outputs . set_value ( \"array\" , column ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs ExportArrowTable ( KiaraModule ) \u00b6 Export a table object to disk. Source code in core/table/__init__.py class ExportArrowTable ( KiaraModule ): \"\"\"Export a table object to disk.\"\"\" _module_type_name = \"export\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from pyarrow import feather table : pa . Table = inputs . get_value_data ( \"table\" ) full_path : str = inputs . get_value_data ( \"path\" ) force_overwrite = inputs . get_value_data ( \"force_overwrite\" ) format : str = inputs . get_value_data ( \"format\" ) compression = inputs . get_value_data ( \"compression\" ) if compression not in [ \"zstd\" , \"lz4\" , \"uncompressed\" ]: raise KiaraProcessingException ( f \"Invalid compression format ' { compression } '. Allowed: 'zstd', 'lz4', 'uncompressed'.\" ) if format != \"feather\" : raise KiaraProcessingException ( f \"Can't export table to format ' { format } ': only 'feather' supported at the moment.\" ) if os . path . exists ( full_path ) and not force_overwrite : raise KiaraProcessingException ( f \"Can't write table to file, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : format , }, \"value_id\" : NO_VALUE_ID_MARKER , \"output_name\" : \"table\" , } outputs . set_value ( \"load_config\" , result ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs LoadArrowTable ( KiaraModule ) \u00b6 Load a table object from disk. Source code in core/table/__init__.py class LoadArrowTable ( KiaraModule ): \"\"\"Load a table object from disk.\"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from pyarrow import feather base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) format = inputs . get_value_data ( \"format\" ) if format != \"feather\" : raise NotImplementedError () path = os . path . join ( base_path , rel_path ) table = feather . read_table ( path ) outputs . set_value ( \"table\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs MapColumnModule ( KiaraModule ) \u00b6 Map the items of one column of a table onto an array, using another module. Source code in core/table/__init__.py class MapColumnModule ( KiaraModule ): \"\"\"Map the items of one column of a table onto an array, using another module.\"\"\" _config_cls = MapColumnsModuleConfig _module_type_name = \"map_column\" def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table : pa . Table = inputs . get_value_data ( \"table\" ) column_name = inputs . get_value_data ( \"column_name\" ) if column_name not in table . column_names : raise KiaraProcessingException ( f \"Table column ' { column_name } ' not available in table. Available columns: { ', ' . join ( table . column_names ) } .\" ) input_array : pa . Array = table . column ( column_name ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"table\" , \"column_name\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list )) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs module_instance_doc ( self ) \u00b6 Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/table/__init__.py def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result MapColumnsModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/__init__.py class MapColumnsModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , ) input_name : str pydantic-field \u00b6 The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input. module_config : Dict [ str , Any ] pydantic-field \u00b6 The config for the kiara filter module. module_type : str pydantic-field required \u00b6 The name of the kiara module to use to filter the input data. output_name : str pydantic-field \u00b6 The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. MergeTableModule ( KiaraModule ) \u00b6 Create a table from other tables and/or arrays. Source code in core/table/__init__.py class MergeTableModule ( KiaraModule ): \"\"\"Create a table from other tables and/or arrays.\"\"\" _module_type_name = \"merge\" _config_cls = MergeTableModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_schema : typing . Dict [ str , typing . Any ] = self . get_config_value ( \"input_schema\" ) sources = {} for field_name in input_schema . keys (): sources [ field_name ] = inputs . get_value_data ( field_name ) len_dict = {} arrays = [] column_names = [] for source_key , table_or_column in sources . items (): if isinstance ( table_or_column , pa . Table ): rows = table_or_column . num_rows for name in table_or_column . schema . names : column = table_or_column . column ( name ) arrays . append ( column ) column_names . append ( name ) elif isinstance ( table_or_column , ( pa . Array , pa . ChunkedArray )): rows = len ( table_or_column ) arrays . append ( table_or_column ) column_names . append ( source_key ) else : raise KiaraProcessingException ( f \"Can't merge table: invalid type ' { type ( table_or_column ) } ' for source ' { source_key } '.\" ) len_dict [ source_key ] = rows all_rows = None for source_key , rows in len_dict . items (): if all_rows is None : all_rows = rows else : if all_rows != rows : all_rows = None break if all_rows is None : len_str = \"\" for name , rows in len_dict . items (): len_str = f \" { name } ( { rows } )\" raise KiaraProcessingException ( f \"Can't merge table, sources have different lengths: { len_str } \" ) table = pa . Table . from_arrays ( arrays = arrays , names = column_names ) outputs . set_value ( \"table\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs MergeTableModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/__init__.py class MergeTableModuleConfig ( ModuleTypeConfigSchema ): input_schema : typing . Dict [ str , typing . Any ] = Field ( description = \"A dict describing the inputs for this merge process.\" ) input_schema : Dict [ str , Any ] pydantic-field required \u00b6 A dict describing the inputs for this merge process. SampleTableModule ( SampleValueModule ) \u00b6 Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/table/__init__.py class SampleTableModule ( SampleValueModule ): \"\"\"Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"table\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= 100 : return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( 0 , sample_size ) def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( len ( table ) - sample_size ) get_value_type () classmethod \u00b6 Return the value type for this sample module. Source code in core/table/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"table\" SaveArrowTableConfig ( StoreValueModuleConfig ) pydantic-model \u00b6 Source code in core/table/__init__.py class SaveArrowTableConfig ( StoreValueModuleConfig ): compression : str = Field ( description = \"The compression to use when saving the table.\" , default = \"zstd\" ) compression : str pydantic-field \u00b6 The compression to use when saving the table. StoreArrowTable ( StoreValueTypeModule ) \u00b6 Source code in core/table/__init__.py class StoreArrowTable ( StoreValueTypeModule ): _config_cls = SaveArrowTableConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"table\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/table/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result TableConversionModuleConfig ( CreateValueModuleConfig ) pydantic-model \u00b6 Source code in core/table/__init__.py class TableConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , ) ignore_errors : bool pydantic-field \u00b6 Whether to ignore convert errors and omit the failed items. TableMetadataModule ( ExtractMetadataModule ) \u00b6 Extract metadata from a table object. Source code in core/table/__init__.py class TableMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from a table object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"table\" @classmethod def get_metadata_key ( cls ) -> str : return \"table\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return TableMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa table : pa . Table = value . get_value_data () table_schema = {} for name in table . schema . names : field = table . schema . field ( name ) md = field . metadata _type = field . type if not md : md = { \"arrow_type_id\" : _type . id , } _d = { \"type_name\" : str ( _type ), \"metadata\" : md , } table_schema [ name ] = _d return { \"column_names\" : table . column_names , \"column_schema\" : table_schema , \"rows\" : table . num_rows , \"size\" : table . nbytes , } filter \u00b6 CreateFilteredTableModule ( KiaraModule ) \u00b6 Filter a table using a mask array. Source code in core/table/filter.py class CreateFilteredTableModule ( KiaraModule ): \"\"\"Filter a table using a mask array.\"\"\" _module_type_name = \"with_mask\" _config_cls = TableFilterModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs query \u00b6 QueryTableGraphQL ( KiaraModule ) \u00b6 Execute a graphql aggregation query against an (Arrow) table. References https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } Source code in core/table/query.py class QueryTableGraphQL ( KiaraModule ): \"\"\"Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } \"\"\" _module_type_name = \"graphql\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import vaex table = inputs . get_value_data ( \"table\" ) query = inputs . get_value_data ( \"query\" ) df = vaex . from_arrow_table ( table ) result = df . graphql . execute ( query ) outputs . set_value ( \"query_result\" , result . to_dict ()[ \"data\" ]) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs QueryTableSQL ( KiaraModule ) \u00b6 Execute a sql query against an (Arrow) table. Source code in core/table/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryTableSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import duckdb if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) _relation_name : str = inputs . get_value_data ( \"relation_name\" ) else : _query = self . get_config_value ( \"query\" ) _relation_name = self . get_config_value ( \"relation_name\" ) if _relation_name . upper () in RESERVED_SQL_KEYWORDS : raise KiaraProcessingException ( f \"Invalid relation name ' { _relation_name } ': this is a reserved sql keyword, please select a different name.\" ) _table = inputs . get_value_data ( \"table\" ) rel_from_arrow = duckdb . arrow ( _table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( _relation_name , _query ) outputs . set_value ( \"query_result\" , result . fetch_arrow_table ()) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/query.py class QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) relation_name : typing . Optional [ str ] = Field ( description = \"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\" , default = \"data\" , ) query : str pydantic-field \u00b6 The query to execute. If not specified, the user will be able to provide their own. relation_name : str pydantic-field \u00b6 The name the table is referred to in the sql query. If not specified, the user will be able to provide their own. utils \u00b6 create_sqlite_schema_data_from_arrow_table ( table , column_map = None , index_columns = None , extra_column_info = None ) \u00b6 Create a sql schema statement from an Arrow table object. Parameters: Name Type Description Default table pa.Table the Arrow table object required column_map Optional[Mapping[str, str]] a map that contains column names that should be changed in the new table None index_columns Optional[Iterable[str]] a list of column names (after mapping) to create module_indexes for None extra_column_info Optional[Mapping[str, Iterable[str]]] a list of extra schema instructions per column name (after mapping) None Source code in core/table/utils.py def create_sqlite_schema_data_from_arrow_table ( table : \"pa.Table\" , column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , index_columns : typing . Optional [ typing . Iterable [ str ]] = None , extra_column_info : typing . Optional [ typing . Mapping [ str , typing . Iterable [ str ]] ] = None , ) -> SqliteTableSchema : \"\"\"Create a sql schema statement from an Arrow table object. Arguments: table: the Arrow table object column_map: a map that contains column names that should be changed in the new table index_columns: a list of column names (after mapping) to create module_indexes for extra_column_info: a list of extra schema instructions per column name (after mapping) \"\"\" columns = convert_arrow_column_types_to_sqlite ( table = table ) if column_map is None : column_map = {} if extra_column_info is None : extra_column_info = {} temp : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if index_columns is None : index_columns = [] for cn , data in columns . items (): if cn in column_map . keys (): new_key = column_map [ cn ] else : new_key = cn temp_data = dict ( data ) if new_key in extra_column_info . keys (): temp_data [ \"extra_column_info\" ] = extra_column_info [ new_key ] else : temp_data [ \"extra_column_info\" ] = [ \"\" ] if cn in index_columns : temp_data [ \"create_index\" ] = True temp [ new_key ] = temp_data columns = temp if not columns : raise Exception ( \"Resulting table schema has no columns.\" ) else : for ic in index_columns : if ic not in columns . keys (): raise Exception ( f \"Can't create schema, requested index column name not available: { ic } \" ) return SqliteTableSchema ( columns = columns , column_map = column_map ) value \u00b6 DataProfilerModule ( KiaraModule ) \u00b6 Generate a data profile report for a dataset. This uses the DataProfiler Python library, check out its documentation for more details. Source code in core/value.py class DataProfilerModule ( KiaraModule ): \"\"\"Generate a data profile report for a dataset. This uses the [DataProfiler](https://capitalone.github.io/DataProfiler/docs/0.7.0/html/index.html) Python library, check out its documentation for more details. \"\"\" _module_type_name = \"data_profile\" _config_cls = DataProfilerModuleConfig @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from dataprofiler import Data , Profiler , ProfilerOptions , set_verbosity set_verbosity ( logging . WARNING ) value_type = self . get_config_value ( \"value_type\" ) profile_options = ProfilerOptions () profile_options . structured_options . data_labeler . is_enabled = False profile_options . unstructured_options . data_labeler . is_enabled = False if value_type == \"table\" : table_item : pa . Table = inputs . get_value_data ( \"item\" ) pd = table_item . to_pandas () profile = Profiler ( pd , options = profile_options ) # Calculate Statistics, Entity Recognition, etc report = profile . report () elif value_type == \"file\" : file_item : KiaraFile = inputs . get_value_data ( \"item\" ) data = Data ( file_item . path ) profile = Profiler ( data , options = profile_options ) report = profile . report () else : raise KiaraProcessingException ( f \"Data profiling of value type ' { value_type } ' not supported.\" ) outputs . set_value ( \"report\" , report ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs retrieve_module_profiles ( kiara ) classmethod \u00b6 Retrieve a collection of profiles (pre-set module configs) for this kiara module type. This is used to automatically create generally useful operations (incl. their ids). Source code in core/value.py @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles DataProfilerModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/value.py class DataProfilerModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to profile.\" ) value_type : str pydantic-field required \u00b6 The value type to profile. value_types \u00b6 This module contains the value type classes that are used in the kiara_modules.core package. ArrayType ( AnyType ) \u00b6 An Apache arrow array. Source code in core/value_types.py class ArrayType ( AnyType ): \"\"\"An Apache arrow array.\"\"\" _value_type_name = \"array\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Array @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . ChunkedArray , pa . Table ] def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 ) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) array = value . get_value_data () import pyarrow as pa temp_table = pa . Table . from_arrays ( arrays = [ array ], names = [ \"array\" ]) atw = ArrowTabularWrap ( temp_table ) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 ) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" ) BooleanType ( AnyType ) \u00b6 A boolean. Source code in core/value_types.py class BooleanType ( AnyType ): \"A boolean.\" _value_type_name = \"boolean\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bool @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" ) BytesType ( AnyType ) \u00b6 An array of bytes. Source code in core/value_types.py class BytesType ( AnyType ): \"\"\"An array of bytes.\"\"\" _value_type_name = \"bytes\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bytes @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : bytes = value . get_value_data () return [ data . decode ()] # @classmethod # def get_operations( # cls, # ) -> typing.Mapping[str, typing.Mapping[str, typing.Mapping[str, typing.Any]]]: # # return { # \"save_value\": { # \"default\": { # \"module_type\": \"bytes.save\", # \"input_name\": \"bytes\", # } # } # } calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) DatabaseType ( ComplexModelType ) \u00b6 A database, containing one or several tables. This is backed by sqlite databases. Source code in core/value_types.py class DatabaseType ( ComplexModelType [ KiaraDatabase ]): \"\"\"A database, containing one or several tables. This is backed by sqlite databases. \"\"\" _value_type_name = \"database\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return KiaraDatabase @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraDatabase , str ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : KiaraDatabase = value . get_value_data () from sqlalchemy import inspect inspector = inspect ( db . get_sqlalchemy_engine ()) result : typing . List [ typing . Any ] = [ \"\" ] for table_name in inspector . get_table_names (): atw = SqliteTabularWrap ( db = db , table_name = table_name ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { table_name } [/i]\" ) result . append ( pretty ) return result parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core/value_types.py class DateType ( AnyType ): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _value_type_name = \"date\" @classmethod def backing_python_type ( cls ) -> typing . Type : return datetime . datetime @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value )) def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_typpe ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value )) parse_value ( self , v ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v Any the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime ) DictType ( AnyType ) \u00b6 A dict-like object. Source code in core/value_types.py class DictType ( AnyType ): \"\"\"A dict-like object.\"\"\" _value_type_name = \"dict\" @classmethod def backing_python_type ( cls ) -> typing . Type : return dict @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" ) FileBundleType ( AnyType ) \u00b6 A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileBundleType ( AnyType ): \"\"\"A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file_bundle\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFileBundle @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFileBundle ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_no_included_files = print_config . get ( \"max_no_files\" , 40 ) data : KiaraFileBundle = value . get_value_data () pretty = data . dict ( exclude = { \"included_files\" }) files = list ( data . included_files . keys ()) if max_no_included_files >= 0 : if len ( files ) > max_no_included_files : half = int (( max_no_included_files - 1 ) / 2 ) head = files [ 0 : half ] tail = files [ - 1 * half :] # noqa files = ( head + [ \"..... output skipped .....\" , \"..... output skipped .....\" ] + tail ) pretty [ \"included_files\" ] = files return [ json . dumps ( pretty , indent = 2 )] # return [data.json(indent=2)] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash FileType ( AnyType ) \u00b6 A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileType ( AnyType ): \"\"\"A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFile @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFile ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : KiaraFile = value . get_value_data () max_lines = print_config . get ( \"max_lines\" , 34 ) try : lines = [] with open ( data . path , \"r\" ) as f : for idx , l in enumerate ( f ): if idx > max_lines : lines . append ( \"... \\n \" ) lines . append ( \"...\" ) break lines . append ( l ) # TODO: syntax highlighting return [ \"\" . join ( lines )] except UnicodeDecodeError : # found non-text data return [ \"Binary file or non-utf8 enconding, not printing content...\" , \"\" , \"[b]File metadata:[/b]\" , \"\" , data . json ( indent = 2 ), ] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash FloatType ( AnyType ) \u00b6 A float. Source code in core/value_types.py class FloatType ( AnyType ): \"A float.\" _value_type_name = \"float\" @classmethod def backing_python_type ( cls ) -> typing . Type : return float @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) IntegerType ( AnyType ) \u00b6 An integer. Source code in core/value_types.py class IntegerType ( AnyType ): \"\"\"An integer.\"\"\" _value_type_name = \"integer\" @classmethod def backing_python_type ( cls ) -> typing . Type : return int @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" ) ListType ( AnyType ) \u00b6 A list-like object. Source code in core/value_types.py class ListType ( AnyType ): \"\"\"A list-like object.\"\"\" _value_type_name = \"list\" @classmethod def backing_python_type ( cls ) -> typing . Type : return list @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable ) RenderablesType ( ValueType ) \u00b6 A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. Source code in core/value_types.py class RenderablesType ( ValueType [ object , ValueTypeConfigSchema ]): \"\"\"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. \"\"\" _value_type_name = \"renderables\" @classmethod def backing_python_type ( cls ) -> typing . Type : return object @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , ConsoleRenderable , RichCast ] @classmethod def type_config_cls ( cls ) -> typing . Type [ ValueTypeConfigSchema ]: return ValueTypeConfigSchema StringType ( AnyType ) \u00b6 A string. Source code in core/value_types.py class StringType ( AnyType ): \"\"\"A string.\"\"\" _value_type_name = \"string\" @classmethod def backing_python_type ( cls ) -> typing . Type : return str @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ data ] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" ) TableType ( AnyType ) \u00b6 A table. Internally, this is backed by the Apache Arrow Table class. Source code in core/value_types.py class TableType ( AnyType ): \"\"\"A table. Internally, this is backed by the [Apache Arrow](https://arrow.apache.org) [``Table``](https://arrow.apache.org/docs/python/generated/pyarrow.Table.html) class. \"\"\" _value_type_name = \"table\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Table @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . Table ] @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None # @classmethod # def get_supported_hash_types(cls) -> typing.Iterable[str]: # # return [\"pandas_df_hash\"] # # @classmethod # def calculate_value_hash(cls, value: typing.Any, hash_type: str) -> str: # # import pyarrow as pa # # # this is only for testing, and will be replaced with a native arrow table hush function, once I figure out how to do that efficiently # table: pa.Table = value # from pandas.util import hash_pandas_object # # hash_result = hash_pandas_object(table.to_pandas()).sum() # return str(hash_result) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) atw = ArrowTabularWrap ( value . get_value_data ()) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result check_data ( data ) classmethod \u00b6 Check whether the provided input matches this value type. If it does, return a ValueType object (with the appropriate type configuration). Source code in core/value_types.py @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" ) yaml \u00b6 ToYamlModuleOld ( OldTypeConversionModule ) \u00b6 Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. Source code in core/yaml.py class ToYamlModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. \"\"\" _module_type_name = \"to_yaml\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return YAML_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"yaml\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_yaml ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"core"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array","text":"","title":"array"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.ArrayMetadataModule","text":"Extract metadata from an 'array' value. Source code in core/array/__init__.py class ArrayMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from an 'array' value.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"array\" @classmethod def get_metadata_key ( cls ) -> str : return \"array\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return ArrayMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa array : pa . Array = value . get_value_data () return { \"length\" : len ( array ), \"size\" : array . nbytes , }","title":"ArrayMetadataModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModule","text":"Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another kiara module. This 'child' module will then be used to compute the array items of the result. Source code in core/array/__init__.py class MapModule ( KiaraModule ): \"\"\"Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another *kiara* module. This 'child' module will then be used to compute the array items of the result. \"\"\" _config_cls = MapModuleConfig def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( id = \"map_module_child\" , module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_array : pa . Array = inputs . get_value_data ( \"array\" ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"array\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list ))","title":"MapModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModule.module_instance_doc","text":"Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/array/__init__.py def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result","title":"module_instance_doc()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModuleConfig","text":"Source code in core/array/__init__.py class MapModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , )","title":"MapModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModuleConfig.input_name","text":"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.","title":"input_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModuleConfig.module_config","text":"The config for the kiara filter module.","title":"module_config"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModuleConfig.module_type","text":"The name of the kiara module to use to filter the input data.","title":"module_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.MapModuleConfig.output_name","text":"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.","title":"output_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.SampleArrayModule","text":"Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/array/__init__.py class SampleArrayModule ( SampleValueModule ): \"\"\"Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"array\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= 100 : return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( 0 , sample_size ) return result_array def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( len ( array ) - sample_size ) return result_array","title":"SampleArrayModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.SampleArrayModule.get_value_type","text":"Return the value type for this sample module. Source code in core/array/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"array\"","title":"get_value_type()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.StoreArrayTypeModule","text":"Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with kira to re-assemble the array object from disk. Source code in core/array/__init__.py class StoreArrayTypeModule ( StoreValueTypeModule ): \"\"\"Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with *kira* to re-assemble the array object from disk. \"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"array\" def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config","title":"StoreArrayTypeModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.array.StoreArrayTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/array/__init__.py def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes","text":"","title":"bytes"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.LoadBytesModule","text":"Source code in core/bytes/__init__.py class LoadBytesModule ( KiaraModule ): _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) if not os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't read file, path does not exist: { path } \" ) with open ( path , \"rb\" ) as f : content = f . read () outputs . set_value ( \"bytes\" , content )","title":"LoadBytesModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.LoadBytesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.LoadBytesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.StoreBytesTypeModule","text":"Source code in core/bytes/__init__.py class StoreBytesTypeModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"bytes\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config","title":"StoreBytesTypeModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.StoreBytesTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/bytes/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack","text":"","title":"msgpack"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule","text":"Source code in core/bytes/msgpack.py class DeserializeFromMsgPackModule ( KiaraModule ): _module_type_name = \"to_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack msg = inputs . get_value_data ( \"bytes\" ) unpacked = msgpack . unpackb ( msg , raw = False ) value_type = unpacked [ \"value_type\" ] outputs . set_value ( \"value_type\" , value_type ) metadata = unpacked [ \"metadata\" ] outputs . set_value ( \"value_metadata\" , metadata ) new_data = unpacked [ \"data\" ] if not hasattr ( self , f \"to_ { value_type } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack deserialization: { value_type } \" ) func = getattr ( self , f \"to_ { value_type } \" ) obj = func ( data = new_data ) outputs . set_value ( \"value_data\" , obj ) def to_table ( self , data : bytes ) -> typing . Any : import pyarrow as pa reader = pa . ipc . open_stream ( data ) batches = [ b for b in reader ] new_table = pa . Table . from_batches ( batches ) return new_table def to_boolean ( self , data : bytes ): return data","title":"DeserializeFromMsgPackModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule","text":"Source code in core/bytes/msgpack.py class SerializeToMsgPackModule ( KiaraModule ): _module_type_name = \"from_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack type_name : str = self . get_config_value ( \"value_type\" ) if not hasattr ( self , f \"from_ { type_name } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack serialization: { type_name } \" ) func = getattr ( self , f \"from_ { type_name } \" ) value = inputs . get_value_obj ( \"value_item\" ) metadata = value . get_metadata ( also_return_schema = True ) msg = func ( value = value ) data = { \"value_type\" : value . type_name , \"metadata\" : metadata , \"data\" : msg } msg = msgpack . packb ( data , use_bin_type = True ) outputs . set_value ( \"bytes\" , msg ) def from_table ( self , value : Value ) -> bytes : import pyarrow as pa table_val : Value = value table : pa . Table = table_val . get_value_data () sink = pa . BufferOutputStream () writer = pa . ipc . new_stream ( sink , table . schema ) writer . write ( table ) writer . close () buf : pa . Buffer = sink . getvalue () return memoryview ( buf ) def from_boolean ( self , value : Value ) -> bytes : return value . get_value_data ()","title":"SerializeToMsgPackModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModuleConfig","text":"Source code in core/bytes/msgpack.py class SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to serialize/deserialize.\" )","title":"SerializeToMsgPackModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModuleConfig.value_type","text":"The value type to serialize/deserialize.","title":"value_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database","text":"","title":"database"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.BaseDatabaseInfoMetadataModule","text":"Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class BaseDatabaseInfoMetadataModule ( ExtractMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> BaseModel : from sqlalchemy import inspect , text database : KiaraDatabase = value . get_value_data () inspector : Inspector = inspect ( database . get_sqlalchemy_engine ()) table_names = inspector . get_table_names () view_names = inspector . get_view_names () table_infos = {} for table in table_names : columns = inspector . get_columns ( table_name = table ) columns_info = {} with database . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { table } \" )) num_rows = result . fetchone ()[ 0 ] try : result = con . execute ( text ( f 'SELECT SUM(\"pgsize\") FROM \"dbstat\" WHERE name=\" { table } \"' ) ) table_size = result . fetchone ()[ 0 ] except Exception : table_size = None for column in columns : column_name = column [ \"name\" ] cs = ColumnSchema ( type_name = column [ \"type\" ] . __visit_name__ , metadata = { \"is_primary_key\" : column [ \"primary_key\" ] == 1 , \"nullable\" : column [ \"nullable\" ], }, ) columns_info [ column_name ] = cs table_infos [ table ] = TableMetadata ( column_names = list ( columns_info . keys ()), column_schema = columns_info , rows = num_rows , size = table_size , ) file_stats = os . stat ( database . db_file_path ) size = file_stats . st_size kdi = KiaraDatabaseInfo ( table_names = table_names , view_names = view_names , tables = table_infos , size = size , ) return kdi","title":"BaseDatabaseInfoMetadataModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.BaseDatabaseMetadataModule","text":"Extract basic metadata from a database object. Source code in core/database/__init__.py class BaseDatabaseMetadataModule ( ExtractMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> KiaraDatabase : database : KiaraDatabase = value . get_value_data () return database","title":"BaseDatabaseMetadataModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.ConvertToDatabaseModule","text":"Create a database from files, file_bundles, etc. Source code in core/database/__init__.py class ConvertToDatabaseModule ( CreateValueModule ): \"\"\"Create a database from files, file_bundles, etc.\"\"\" _module_type_name = \"create\" _config_cls = DatabaseConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"database\" def from_table ( self , value : Value ): import pyarrow as pa from sqlalchemy import MetaData , Table from kiara_modules.core.table.utils import ( create_sqlite_schema_data_from_arrow_table , ) table : pa . Table = value . get_value_data () # maybe we could check the values lineage, to find the best table name? table_name = value . id . replace ( \"-\" , \"_\" ) index_columns = [] for cn in table . column_names : if cn . lower () == \"id\" : index_columns . append ( cn ) column_info : SqliteTableSchema = create_sqlite_schema_data_from_arrow_table ( table = table , index_columns = index_columns ) init_sql = create_table_init_sql ( table_name = table_name , table_schema = column_info ) db = KiaraDatabase . create_in_temp_dir ( init_sql = init_sql ) nodes_column_map : typing . Dict [ str , typing . Any ] = {} for batch in table . to_batches ( DEFAULT_DB_CHUNK_SIZE ): batch_dict = batch . to_pydict () for k , v in nodes_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] engine = db . get_sqlalchemy_engine () _metadata_obj = MetaData () sqlite_table = Table ( table_name , _metadata_obj , autoload_with = engine ) with engine . connect () as conn : with conn . begin (): conn . execute ( sqlite_table . insert (), data ) return db def from_csv_file ( self , value : Value ): f = tempfile . mkdtemp () db_path = os . path . join ( f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( f , ignore_errors = True ) atexit . register ( cleanup ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = value . get_value_data () ) return db_path def from_csv_file_bundle ( self , value : Value ): include_file_information : bool = True include_raw_content_in_file_info : bool = False temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = KiaraDatabase ( db_file_path = db_path ) db . create_if_not_exists () bundle : KiaraFileBundle = value . get_value_data () table_names : typing . List [ str ] = [] for rel_path in sorted ( bundle . included_files . keys ()): file_item = bundle . included_files [ rel_path ] table_name = find_free_id ( stem = file_item . file_name_without_extension , current_ids = table_names ) try : table_names . append ( table_name ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = file_item , table_name = table_name ) except Exception as e : if self . get_config_value ( \"ignore_errors\" ) is True or True : log_message ( f \"Ignoring file ' { rel_path } ': could not import data from file -- { e } \" ) continue raise KiaraProcessingException ( e ) if include_file_information : create_table_from_file_bundle ( file_bundle = value . get_value_data (), db_file_path = db_path , table_name = \"source_files_metadata\" , include_content = include_raw_content_in_file_info , ) return db_path def from_text_file_bundle ( self , value : Value ): return create_table_from_file_bundle ( file_bundle = value . get_value_data (), include_content = True )","title":"ConvertToDatabaseModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.DatabaseConversionModuleConfig","text":"Source code in core/database/__init__.py class DatabaseConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , )","title":"DatabaseConversionModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.DatabaseConversionModuleConfig.ignore_errors","text":"Whether to ignore convert errors and omit the failed items.","title":"ignore_errors"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.DatabaseInfoMetadataModule","text":"Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class DatabaseInfoMetadataModule ( BaseDatabaseInfoMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" _module_type_name = \"info\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database_info\"","title":"DatabaseInfoMetadataModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.DatabaseMetadataModule","text":"Extract basic metadata from a database object. Source code in core/database/__init__.py class DatabaseMetadataModule ( BaseDatabaseMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database\"","title":"DatabaseMetadataModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.LoadDatabaseConfig","text":"Source code in core/database/__init__.py class LoadDatabaseConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The type of the value to be stored (if database sub-type).\" , default = \"database\" , )","title":"LoadDatabaseConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.LoadDatabaseConfig.value_type","text":"The type of the value to be stored (if database sub-type).","title":"value_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.LoadDatabaseModule","text":"Source code in core/database/__init__.py class LoadDatabaseModule ( KiaraModule ): _module_type_name = \"load\" _config_cls = LoadDatabaseConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) outputs . set_value ( \"database\" , path )","title":"LoadDatabaseModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.LoadDatabaseModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.LoadDatabaseModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.StoreDatabaseTypeModule","text":"Save an sqlite database to a file. Source code in core/database/__init__.py class StoreDatabaseTypeModule ( StoreValueTypeModule ): \"\"\"Save an sqlite database to a file.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"database\" def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db )","title":"StoreDatabaseTypeModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.StoreDatabaseTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/database/__init__.py def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db )","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.query","text":"","title":"query"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.query.QueryDatabaseSQLModuleConfig","text":"Source code in core/database/query.py class QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , )","title":"QueryDatabaseSQLModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.query.QueryDatabaseSQLModuleConfig.query","text":"The query to execute. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.query.QueryTableSQL","text":"Execute a sql query against an (Arrow) table. Source code in core/database/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryDatabaseSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pandas as pd import pyarrow as pa if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) else : _query = self . get_config_value ( \"query\" ) _database : KiaraDatabase = inputs . get_value_data ( \"database\" ) # can't re-use the default engine, because pandas does not support having the 'future' flag set to 'True' engine = create_engine ( _database . db_url ) df = pd . read_sql ( _query , con = engine ) table = pa . Table . from_pandas ( df ) outputs . set_value ( \"query_result\" , table )","title":"QueryTableSQL"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.query.QueryTableSQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.query.QueryTableSQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils","text":"","title":"utils"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes","text":"Source code in core/database/utils.py class SqliteColumnAttributes ( BaseModel ): data_type : str = Field ( description = \"The type of the data in this column.\" , default = \"ANY\" ) extra_column_info : typing . List [ str ] = Field ( description = \"Additional init information for the column.\" , default_factory = list ) create_index : bool = Field ( description = \"Whether to create an index for this column or not.\" , default = False )","title":"SqliteColumnAttributes"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes.create_index","text":"Whether to create an index for this column or not.","title":"create_index"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes.data_type","text":"The type of the data in this column.","title":"data_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes.extra_column_info","text":"Additional init information for the column.","title":"extra_column_info"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteTableSchema","text":"Source code in core/database/utils.py class SqliteTableSchema ( BaseModel ): columns : typing . Dict [ str , SqliteColumnAttributes ] = Field ( description = \"The table columns and their attributes.\" ) extra_schema : typing . List [ str ] = Field ( description = \"Extra schema information for this table.\" , default_factory = list ) column_map : typing . Dict [ str , str ] = Field ( description = \"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.\" , default_factory = dict , )","title":"SqliteTableSchema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteTableSchema.column_map","text":"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.","title":"column_map"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteTableSchema.columns","text":"The table columns and their attributes.","title":"columns"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.SqliteTableSchema.extra_schema","text":"Extra schema information for this table.","title":"extra_schema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.database.utils.create_table_init_sql","text":"Create an sql script to initialize a table. Parameters: Name Type Description Default column_attrs a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values required Source code in core/database/utils.py def create_table_init_sql ( table_name : str , table_schema : SqliteTableSchema , schema_template_str : typing . Optional [ str ] = None , ): \"\"\"Create an sql script to initialize a table. Arguments: column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values \"\"\" if schema_template_str is None : template_path = Path ( TEMPLATES_FOLDER ) / \"sqlite_schama.sql.j2\" schema_template_str = template_path . read_text () template = Environment ( loader = BaseLoader ()) . from_string ( schema_template_str ) edges_columns = [] edge_indexes = [] lines = [] for cn , details in table_schema . columns . items (): cn_type = details . data_type cn_extra = details . extra_column_info line = f \" { cn } { cn_type } \" if cn_extra : line = f \" { line } { ' ' . join ( cn_extra ) } \" edges_columns . append ( line ) if details . create_index : edge_indexes . append ( cn ) lines . append ( line ) lines . extend ( table_schema . extra_schema ) rendered = template . render ( table_name = table_name , column_info = lines , index_columns = edge_indexes ) return rendered","title":"create_table_init_sql()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date","text":"A collection of date related modules. Most of those are very bare-bones, not really dealing with more advanced (but very important) concepts like timezones and resolution yet.","title":"date"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"range_check\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser d = inputs . get_value_data ( \"date\" ) earliest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if hasattr ( d , \"as_py\" ): d = d . as_py () if isinstance ( d , str ): d = parser . parse ( d ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date.DateRangeCheckModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date.DateRangeCheckModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date.ExtractDateModule","text":"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"extract_from_string\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) date_match = re . findall ( r \"_(\\d {4} -\\d {2} -\\d {2} )_\" , text ) assert date_match d_obj = parser . parse ( date_match [ 0 ]) # type: ignore outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date.ExtractDateModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.date.ExtractDateModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.defaults","text":"","title":"defaults"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.defaults.KIARA_MODULES_CORE_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_MODULES_CORE_BASE_FOLDER"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.defaults.KIARA_MODULES_CORE_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_MODULES_CORE_RESOURCES_FOLDER"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev","text":"Modules that are useful for kiara as well as pipeline-development, as well as testing.","title":"dev"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyModule","text":"Module that simulates processing, but uses hard-coded outputs as a result. Source code in core/dev.py class DummyModule ( KiaraModule ): \"\"\"Module that simulates processing, but uses hard-coded outputs as a result.\"\"\" _config_cls = DummyProcessingModuleConfig def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) # def _get_doc(self) -> str: # # doc = self.config.get(\"doc\", None) # # if doc: # return self.config[\"doc\"] # else: # return super()._get_doc()","title":"DummyModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyModule.create_input_schema","text":"The input schema for the dummy module is created at object creation time from the input_schemas config parameter. Source code in core/dev.py def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyModule.create_output_schema","text":"The output schema for the dummy module is created at object creation time from the output_schemas config parameter. Source code in core/dev.py def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyModule.process","text":"Returns the hardcoded output values that are set in the outputs config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the delay config parameter). Source code in core/dev.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict )","title":"process()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyProcessingModuleConfig","text":"Configuration for the 'dummy' processing module. Source code in core/dev.py class DummyProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Configuration for the 'dummy' processing module.\"\"\" documentation : typing . Optional [ str ] = None input_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The input schema for this module.\" ) output_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The output schema for this module.\" ) outputs : typing . Dict [ str , typing . Any ] = Field ( description = \"The (dummy) output for this module.\" , default_factory = dict ) delay : float = Field ( description = \"The delay in seconds from processing start to when the (dummy) outputs are returned.\" , default = 0 , )","title":"DummyProcessingModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyProcessingModuleConfig.delay","text":"The delay in seconds from processing start to when the (dummy) outputs are returned.","title":"delay"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyProcessingModuleConfig.input_schema","text":"The input schema for this module.","title":"input_schema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyProcessingModuleConfig.output_schema","text":"The output schema for this module.","title":"output_schema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dev.DummyProcessingModuleConfig.outputs","text":"The (dummy) output for this module.","title":"outputs"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dict","text":"","title":"dict"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dict.SaveDictModule","text":"Source code in core/dict.py class SaveDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"dict\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"SaveDictModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.dict.SaveDictModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/dict.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file","text":"","title":"file"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file.DefaultFileImportModule","text":"Import an external file into a kiara session. Source code in core/file.py class DefaultFileImportModule ( FileImportModule ): \"\"\"Import an external file into a kiara session.\"\"\" _module_type_name = \"import\" def import_from__file_path__string ( self , source : str ) -> KiaraFile : file_model = KiaraFile . load_file ( source ) return file_model","title":"DefaultFileImportModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file.LoadLocalFileModule","text":"Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. Source code in core/file.py class LoadLocalFileModule ( KiaraModule ): \"\"\"Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. \"\"\" # _config_cls = ImportLocalPathConfig _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) file_model = KiaraFile . load_file ( path ) outputs . set_value ( \"file\" , file_model )","title":"LoadLocalFileModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file.LoadLocalFileModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file.LoadLocalFileModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file.StoreFileTypeModule","text":"Save a file to disk. Source code in core/file.py class StoreFileTypeModule ( StoreValueTypeModule ): \"\"\"Save a file to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm )","title":"StoreFileTypeModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file.StoreFileTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/file.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm )","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle","text":"","title":"file_bundle"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle.DefaultFileBundleImportModule","text":"Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. Source code in core/file_bundle.py class DefaultFileBundleImportModule ( FileBundleImportModule ): \"\"\"Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. \"\"\" _module_type_name = \"import\" def import_from__folder_path__string ( self , source : str ) -> KiaraFileBundle : file_bundle_model = KiaraFileBundle . import_folder ( source ) return file_bundle_model","title":"DefaultFileBundleImportModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle.LoadFileBundleModule","text":"Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. Source code in core/file_bundle.py class LoadFileBundleModule ( KiaraModule ): \"\"\"Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. \"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) included_files = inputs . get_value_data ( \"include_files\" ) excluded_dirs = inputs . get_value_data ( \"exclude_dirs\" ) excluded_files = inputs . get_value_data ( \"exclude_files\" ) import_config = FolderImportConfig ( include_files = included_files , exclude_dirs = excluded_dirs , excluded_files = excluded_files , ) bundle = KiaraFileBundle . import_folder ( source = path , import_config = import_config ) outputs . set_values ( file_bundle = bundle )","title":"LoadFileBundleModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle.LoadFileBundleModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle.LoadFileBundleModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle.StoreFileBundleType","text":"Save a file bundle to disk. Source code in core/file_bundle.py class StoreFileBundleType ( StoreValueTypeModule ): \"\"\"Save a file bundle to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file_bundle\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb )","title":"StoreFileBundleType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.file_bundle.StoreFileBundleType.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/file_bundle.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb )","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic","text":"","title":"generic"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.JsonSerializationConfig","text":"Source code in core/generic.py class JsonSerializationConfig ( StoreValueModuleConfig ): options : int = Field ( description = \"The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details.\" , default = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) file_name : str = Field ( description = \"The name of the serialized file.\" , default = \"dict.json\" )","title":"JsonSerializationConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.JsonSerializationConfig.file_name","text":"The name of the serialized file.","title":"file_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.JsonSerializationConfig.options","text":"The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details.","title":"options"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreFromJsonDictModule","text":"Source code in core/generic.py class RestoreFromJsonDictModule ( KiaraModule ): _module_type_name = \"restore_from_json\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) file_name = inputs . get_value_data ( \"file_name\" ) full_path = os . path . join ( base_path , file_name ) if not os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't deserialize dict, path to file does not exist: { full_path } \" ) if not os . path . isfile ( os . path . realpath ( full_path )): raise KiaraProcessingException ( f \"Can't deserialize dict, path is not a file: { full_path } \" ) with open ( full_path , \"r\" ) as f : content = f . read () data = orjson . loads ( content ) outputs . set_value ( \"value_item\" , data )","title":"RestoreFromJsonDictModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreFromJsonDictModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreFromJsonDictModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreScalarModule","text":"Utility module, only used internally. Source code in core/generic.py class RestoreScalarModule ( KiaraModule ): \"\"\"Utility module, only used internally.\"\"\" _module_type_name = \"restore_scalar\" _config_cls = RestoreScalarModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : data = inputs . get_value_obj ( \"scalar_data\" ) outputs . set_value ( \"value_item\" , data )","title":"RestoreScalarModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreScalarModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreScalarModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreScalarModuleConfig","text":"Source code in core/generic.py class RestoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to load.\" )","title":"RestoreScalarModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.RestoreScalarModuleConfig.value_type","text":"The value type of the scalar to load.","title":"value_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.StoreScalarModule","text":"Source code in core/generic.py class StoreScalarModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return [ \"boolean\" , \"integer\" , \"float\" , \"string\" ] def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config","title":"StoreScalarModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.StoreScalarModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/generic.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.StoreScalarModuleConfig","text":"Source code in core/generic.py class StoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to store.\" )","title":"StoreScalarModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.generic.StoreScalarModuleConfig.value_type","text":"The value type of the scalar to store.","title":"value_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.json","text":"","title":"json"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.json.ToJsonModuleOld","text":"Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. Source code in core/json.py class ToJsonModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. \"\"\" _module_type_name = \"to_json\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return JSON_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"json\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_json ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"ToJsonModuleOld"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.list","text":"","title":"list"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"contains\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.list.IncludedInListCheckModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.list.IncludedInListCheckModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.list.StoreDictModule","text":"Source code in core/list.py class StoreDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"list\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"StoreDictModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.list.StoreDictModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/list.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic","text":"","title":"logic"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core/logic.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.AndModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.AndModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core/logic.py class LogicProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.LogicProcessingModuleConfig.delay","text":"the delay in seconds from processing start to when the output is returned.","title":"delay"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.NotModule","text":"Negates the input. Source code in core/logic.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.NotModule.create_input_schema","text":"The not module only has one input, a boolean that will be negated by the module. Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.NotModule.create_output_schema","text":"The output of this module is a single boolean, the negated input. Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.NotModule.process","text":"Negates the input boolean. Source code in core/logic.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"process()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core/logic.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.OrModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.logic.OrModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models","text":"This module contains the metadata models that are used in the kiara_modules.core package. Metadata models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata that is attached to data, as well as kiara modules. It is possible to register metadata using a JSON schema string, but it is recommended to create a metadata model, because it is much easier overall. Metadata models must be a sub-class of kiara.metadata.MetadataModel .","title":"metadata_models"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.ArrayMetadata","text":"Describes properties fo the 'array' type. Source code in core/metadata_models.py class ArrayMetadata ( HashedMetadataModel ): \"\"\"Describes properties fo the 'array' type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"array\" length : int = Field ( description = \"The number of elements the array contains.\" ) size : int = Field ( description = \"Total number of bytes consumed by the elements of the array.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"length\" : self . length , \"size\" : self . size } def get_category_alias ( self ) -> str : return \"instance.metadata.array\"","title":"ArrayMetadata"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.ArrayMetadata.length","text":"The number of elements the array contains.","title":"length"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.ArrayMetadata.size","text":"Total number of bytes consumed by the elements of the array.","title":"size"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.ColumnSchema","text":"Describes properties of a single column of the 'table' data type. Source code in core/metadata_models.py class ColumnSchema ( BaseModel ): \"\"\"Describes properties of a single column of the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"column\" type_name : str = Field ( description = \"The type name of the column (backend-specific).\" ) metadata : typing . Dict [ str , typing . Any ] = Field ( description = \"Other metadata for the column.\" , default_factory = dict )","title":"ColumnSchema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.ColumnSchema.metadata","text":"Other metadata for the column.","title":"metadata"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.ColumnSchema.type_name","text":"The type name of the column (backend-specific).","title":"type_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.FolderImportConfig","text":"Source code in core/metadata_models.py class FolderImportConfig ( BaseModel ): include_files : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, include all files where the filename ends with that string.\" , default = None , ) exclude_dirs : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, exclude all folders whose name ends with that string.\" , default = None , ) exclude_files : typing . Optional [ typing . List [ str ]] = Field ( description = f \"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } .\" , default = DEFAULT_EXCLUDE_FILES , )","title":"FolderImportConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.FolderImportConfig.exclude_dirs","text":"A list of strings, exclude all folders whose name ends with that string.","title":"exclude_dirs"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.FolderImportConfig.exclude_files","text":"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: ['.DS_Store'].","title":"exclude_files"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.FolderImportConfig.include_files","text":"A list of strings, include all files where the filename ends with that string.","title":"include_files"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabase","text":"Source code in core/metadata_models.py class KiaraDatabase ( MetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database\" @classmethod def create_in_temp_dir ( cls , init_sql : typing . Optional [ str ] = None ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path ) db . create_if_not_exists () if init_sql : db . execute_sql ( sql_script = init_sql , invalidate = True ) return db db_file_path : str = Field ( description = \"The path to the sqlite database file.\" ) _cached_engine = PrivateAttr ( default = None ) _cached_inspector = PrivateAttr ( default = None ) _table_names = PrivateAttr ( default = None ) _table_schemas = PrivateAttr ( default = None ) def get_id ( self ) -> str : return self . db_file_path def get_category_alias ( self ) -> str : return \"instance.metadata.database\" @validator ( \"db_file_path\" , allow_reuse = True ) def ensure_absolute_path ( cls , path : str ): path = os . path . abspath ( path ) if not os . path . exists ( os . path . dirname ( path )): raise ValueError ( f \"Parent folder for database file does not exist: { path } \" ) return path @property def db_url ( self ) -> str : return f \"sqlite:/// { self . db_file_path } \" def get_sqlalchemy_engine ( self ) -> \"Engine\" : if self . _cached_engine is not None : return self . _cached_engine from sqlalchemy import create_engine self . _cached_engine = create_engine ( self . db_url , future = True ) # with self._cached_engine.connect() as con: # con.execute(text(\"PRAGMA query_only = ON\")) return self . _cached_engine def create_if_not_exists ( self ): from sqlalchemy_utils import create_database , database_exists if not database_exists ( self . db_url ): create_database ( self . db_url ) def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None def copy_database_file ( self , target : str ): os . makedirs ( os . path . dirname ( target )) shutil . copy2 ( self . db_file_path , target ) new_db = KiaraDatabase ( db_file_path = target ) return new_db def get_sqlalchemy_inspector ( self ) -> \"Inspector\" : if self . _cached_inspector is not None : return self . _cached_inspector self . _cached_inspector = inspect ( self . get_sqlalchemy_engine ()) return self . _cached_inspector @property def table_names ( self ) -> typing . Iterable [ str ]: if self . _table_names is not None : return self . _table_names self . _table_names = self . get_sqlalchemy_inspector () . get_table_names () return self . _table_names def get_schema_for_table ( self , table_name : str ): if self . _table_schemas is not None : if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ] ts : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} inspector = self . get_sqlalchemy_inspector () for tn in inspector . get_table_names (): columns = self . get_sqlalchemy_inspector () . get_columns ( tn ) ts [ tn ] = {} for c in columns : ts [ tn ][ c [ \"name\" ]] = c self . _table_schemas = ts if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ]","title":"KiaraDatabase"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabase.db_file_path","text":"The path to the sqlite database file.","title":"db_file_path"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabase.execute_sql","text":"Execute an sql script. Parameters: Name Type Description Default sql_script str the sql script required invalidate bool whether to invalidate cached values within this object False Source code in core/metadata_models.py def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None","title":"execute_sql()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabaseInfo","text":"Source code in core/metadata_models.py class KiaraDatabaseInfo ( HashedMetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database_info\" table_names : typing . List [ str ] = Field ( description = \"The names of all tables in this database.\" ) view_names : typing . List [ str ] = Field ( description = \"The names of all views in this database.\" ) tables : typing . Dict [ str , TableMetadata ] = Field ( description = \"Information about the tables within this database.\" ) size : int = Field ( description = \"The size of the database file.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"table_names\" : self . table_names , \"view_names\" : self . view_names , \"tables\" : self . tables , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.database_info\"","title":"KiaraDatabaseInfo"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.size","text":"The size of the database file.","title":"size"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.table_names","text":"The names of all tables in this database.","title":"table_names"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.tables","text":"Information about the tables within this database.","title":"tables"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.view_names","text":"The names of all views in this database.","title":"view_names"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile","text":"Describes properties for the 'file' value type. Source code in core/metadata_models.py class KiaraFile ( MetadataModel ): \"\"\"Describes properties for the 'file' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file\" @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m _file_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_filename : str = Field ( description = \"The original filename of this file at the time of import.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this file at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) mime_type : str = Field ( description = \"The mime type of the file.\" ) file_name : str = Field ( \"The name of the file.\" ) size : int = Field ( description = \"The size of the file.\" ) path : str = Field ( description = \"The archive path of the file.\" ) is_onboarded : bool = Field ( description = \"Whether the file is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file\" def copy_file ( self , target : str , incl_orig_path : bool = False , is_onboarded : bool = False ): fm = KiaraFile . load_file ( self . path , target ) if incl_orig_path : fm . orig_path = self . orig_path else : fm . orig_path = None fm . orig_filename = self . orig_filename fm . import_time = self . import_time if self . _file_hash is not None : fm . _file_hash = self . _file_hash fm . is_onboarded = is_onboarded return fm @property def file_hash ( self ): if self . _file_hash is not None : return self . _file_hash sha256_hash = hashlib . sha3_256 () with open ( self . path , \"rb\" ) as f : # Read and update hash string value in blocks of 4K for byte_block in iter ( lambda : f . read ( 4096 ), b \"\" ): sha256_hash . update ( byte_block ) self . _file_hash = sha256_hash . hexdigest () return self . _file_hash @property def file_name_without_extension ( self ) -> str : return self . file_name . split ( \".\" )[ 0 ] @property def import_time_as_datetime ( self ) -> datetime . datetime : from dateutil import parser return parser . parse ( self . import_time ) def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\" def __str__ ( self ): return self . __repr__ ()","title":"KiaraFile"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.import_time","text":"The time when the file was imported.","title":"import_time"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.is_onboarded","text":"Whether the file is imported into the kiara data store.","title":"is_onboarded"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.mime_type","text":"The mime type of the file.","title":"mime_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.orig_filename","text":"The original filename of this file at the time of import.","title":"orig_filename"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.orig_path","text":"The original path to this file at the time of import.","title":"orig_path"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.path","text":"The archive path of the file.","title":"path"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.size","text":"The size of the file.","title":"size"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.__repr__","text":"Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\"","title":"__repr__()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.__str__","text":"Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ ()","title":"__str__()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.load_file","text":"Utility method to read metadata of a file from disk and optionally move it into a data archive location. Source code in core/metadata_models.py @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m","title":"load_file()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFile.read_content","text":"Read the content of a file. Source code in core/metadata_models.py def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content","title":"read_content()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle","text":"Describes properties for the 'file_bundle' value type. Source code in core/metadata_models.py class KiaraFileBundle ( MetadataModel ): \"\"\"Describes properties for the 'file_bundle' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file_bundle\" @classmethod def import_folder ( cls , source : str , target : typing . Optional [ str ] = None , import_config : typing . Union [ None , typing . Mapping [ str , typing . Any ], FolderImportConfig ] = None , incl_orig_path : bool = False , ): if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isdir ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) if target and os . path . exists ( target ): raise ValueError ( f \"Target path already exists: { target } \" ) if source . endswith ( os . path . sep ): source = source [ 0 : - 1 ] if target and target . endswith ( os . path . sep ): target = target [ 0 : - 1 ] if import_config is None : _import_config = FolderImportConfig () elif isinstance ( import_config , typing . Mapping ): _import_config = FolderImportConfig ( ** import_config ) elif isinstance ( import_config , FolderImportConfig ): _import_config = import_config else : raise TypeError ( f \"Invalid type for folder import config: { type ( import_config ) } .\" ) included_files : typing . Dict [ str , KiaraFile ] = {} exclude_dirs = _import_config . exclude_dirs invalid_extensions = _import_config . exclude_files valid_extensions = _import_config . include_files sum_size = 0 def include_file ( filename : str ) -> bool : if invalid_extensions and any ( filename . endswith ( ext ) for ext in invalid_extensions ): return False if not valid_extensions : return True else : return any ( filename . endswith ( ext ) for ext in valid_extensions ) for root , dirnames , filenames in os . walk ( source , topdown = True ): if exclude_dirs : dirnames [:] = [ d for d in dirnames if d not in exclude_dirs ] for filename in [ f for f in filenames if os . path . isfile ( os . path . join ( root , f )) and include_file ( f ) ]: full_path = os . path . join ( root , filename ) rel_path = os . path . relpath ( full_path , source ) if target : target_path : typing . Optional [ str ] = os . path . join ( target , rel_path ) else : target_path = None file_model = KiaraFile . load_file ( full_path , target_path , incl_orig_path = incl_orig_path ) sum_size = sum_size + file_model . size included_files [ rel_path ] = file_model orig_bundle_name = os . path . basename ( source ) if incl_orig_path : orig_path : typing . Optional [ str ] = source else : orig_path = None if target : path = target else : path = source return KiaraFileBundle . create_from_file_models ( files = included_files , orig_bundle_name = orig_bundle_name , orig_path = orig_path , path = path , sum_size = sum_size , ) @classmethod def create_from_file_models ( self , files : typing . Mapping [ str , KiaraFile ], orig_bundle_name : str , orig_path : typing . Optional [ str ], path : str , sum_size : typing . Optional [ int ] = None , is_onboarded : bool = False , ): result : typing . Dict [ str , typing . Any ] = {} result [ \"included_files\" ] = files result [ \"orig_path\" ] = orig_path result [ \"path\" ] = path result [ \"import_time\" ] = datetime . datetime . now () . isoformat () result [ \"number_of_files\" ] = len ( files ) result [ \"bundle_name\" ] = os . path . basename ( result [ \"path\" ]) result [ \"orig_bundle_name\" ] = orig_bundle_name result [ \"is_onboarded\" ] = is_onboarded if sum_size is None : sum_size = 0 for f in files . values (): sum_size = sum_size + f . size result [ \"size\" ] = sum_size return KiaraFileBundle ( ** result ) _file_bundle_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_bundle_name : str = Field ( description = \"The original name of this folder at the time of import.\" ) bundle_name : str = Field ( description = \"The name of this bundle.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this folder at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) number_of_files : int = Field ( description = \"How many files are included in this bundle.\" ) included_files : typing . Dict [ str , KiaraFile ] = Field ( description = \"A map of all the included files, incl. their properties. Uses the relative path of each file as key.\" ) size : int = Field ( description = \"The size of all files in this folder, combined.\" ) path : str = Field ( description = \"The archive path of the folder.\" ) is_onboarded : bool = Field ( description = \"Whether this bundle is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file_bundle\" def get_relative_path ( self , file : KiaraFile ): return os . path . relpath ( file . path , self . path ) def read_text_file_contents ( self , ignore_errors : bool = False ) -> typing . Mapping [ str , str ]: content_dict : typing . Dict [ str , str ] = {} def read_file ( rel_path : str , fm : KiaraFile ): with open ( fm . path , encoding = \"utf-8\" ) as f : try : content = f . read () content_dict [ rel_path ] = content # type: ignore except Exception as e : if ignore_errors : log_message ( f \"Can't read file: { e } \" ) log . warning ( f \"Ignoring file: { fm . path } \" ) else : raise Exception ( f \"Can't read file (as text) ' { fm . path } : { e } \" ) # TODO: common ignore files and folders for f in self . included_files . values (): rel_path = self . get_relative_path ( f ) read_file ( rel_path = rel_path , fm = f ) return content_dict @property def file_bundle_hash ( self ): if self . _file_bundle_hash is not None : return self . _file_bundle_hash # hash_format =\"sha3-256\" hashes = \"\" for path in sorted ( self . included_files . keys ()): fm = self . included_files [ path ] hashes = hashes + \"_\" + path + \"_\" + fm . file_hash self . _file_bundle_hash = hashlib . sha3_256 ( hashes . encode ( \"utf-8\" )) . hexdigest () return self . _file_bundle_hash def copy_bundle ( self , target_path : str , incl_orig_path : bool = False , is_onboarded : bool = False ) -> \"KiaraFileBundle\" : if target_path == self . path : raise Exception ( f \"Target path and current path are the same: { target_path } \" ) result = {} for rel_path , item in self . included_files . items (): _target_path = os . path . join ( target_path , rel_path ) new_fm = item . copy_file ( _target_path , is_onboarded = is_onboarded ) result [ rel_path ] = new_fm if incl_orig_path : orig_path = self . orig_path else : orig_path = None fb = KiaraFileBundle . create_from_file_models ( result , orig_bundle_name = self . orig_bundle_name , orig_path = orig_path , path = target_path , sum_size = self . size , is_onboarded = is_onboarded , ) if self . _file_bundle_hash is not None : fb . _file_bundle_hash = self . _file_bundle_hash return fb def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\" def __str__ ( self ): return self . __repr__ ()","title":"KiaraFileBundle"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.bundle_name","text":"The name of this bundle.","title":"bundle_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.import_time","text":"The time when the file was imported.","title":"import_time"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.included_files","text":"A map of all the included files, incl. their properties. Uses the relative path of each file as key.","title":"included_files"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.is_onboarded","text":"Whether this bundle is imported into the kiara data store.","title":"is_onboarded"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.number_of_files","text":"How many files are included in this bundle.","title":"number_of_files"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.orig_bundle_name","text":"The original name of this folder at the time of import.","title":"orig_bundle_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.orig_path","text":"The original path to this folder at the time of import.","title":"orig_path"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.path","text":"The archive path of the folder.","title":"path"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.size","text":"The size of all files in this folder, combined.","title":"size"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.__repr__","text":"Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\"","title":"__repr__()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.KiaraFileBundle.__str__","text":"Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ ()","title":"__str__()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.TableMetadata","text":"Describes properties for the 'table' data type. Source code in core/metadata_models.py class TableMetadata ( HashedMetadataModel ): \"\"\"Describes properties for the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"table\" column_names : typing . List [ str ] = Field ( description = \"The name of the columns of the table.\" ) column_schema : typing . Dict [ str , ColumnSchema ] = Field ( description = \"The schema description of the table.\" ) rows : int = Field ( description = \"The number of rows the table contains.\" ) size : typing . Optional [ int ] = Field ( description = \"The tables size in bytes.\" , default = None ) def _obj_to_hash ( self ) -> typing . Any : return { \"column_names\" : self . column_names , \"column_schemas\" : { k : v . dict () for k , v in self . column_schema . items ()}, \"rows\" : self . rows , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.table\"","title":"TableMetadata"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.TableMetadata.column_names","text":"The name of the columns of the table.","title":"column_names"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.TableMetadata.column_schema","text":"The schema description of the table.","title":"column_schema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.TableMetadata.rows","text":"The number of rows the table contains.","title":"rows"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.metadata_models.TableMetadata.size","text":"The tables size in bytes.","title":"size"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.pipelines","text":"Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder.","title":"pipelines"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string","text":"","title":"string"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.DeserializeStringModule","text":"Source code in core/string.py class DeserializeStringModule ( KiaraModule ): _module_type_name = \"deserialize\" _config_cls = DeserializeStringModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : serialization_type = self . get_config_value ( \"serialization_type\" ) if serialization_type not in [ \"json\" ]: raise KiaraProcessingException ( f \"Can't deserialize string: serialisation type ' { serialization_type } ' not supported.\" ) serialized = inputs . get_value_data ( \"serialized\" ) outputs . set_value ( \"value_item\" , serialized )","title":"DeserializeStringModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.DeserializeStringModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.DeserializeStringModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.DeserializeStringModuleConfig","text":"Source code in core/string.py class DeserializeStringModuleConfig ( ModuleTypeConfigSchema ): serialization_type : str = Field ( description = \"The serialization type that was used to serialize the value.\" )","title":"DeserializeStringModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.DeserializeStringModuleConfig.serialization_type","text":"The serialization type that was used to serialize the value.","title":"serialization_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.RegexModule","text":"Match a string using a regular expression. Source code in core/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"match_regex\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.RegexModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.RegexModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.RegexModuleConfig","text":"Source code in core/string.py class RegexModuleConfig ( ModuleTypeConfigSchema ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.RegexModuleConfig.only_first_match","text":"Whether to only return the first match, or all matches.","title":"only_first_match"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.RegexModuleConfig.regex","text":"The regex to apply.","title":"regex"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.ReplaceModuleConfig","text":"Source code in core/string.py class ReplaceModuleConfig ( ModuleTypeConfigSchema ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.ReplaceModuleConfig.default_value","text":"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.","title":"default_value"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.ReplaceModuleConfig.replacement_map","text":"A map, containing the strings to be replaced as keys, and the replacements as values.","title":"replacement_map"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.ReplaceStringModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.ReplaceStringModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.StringManipulationModule","text":"Base module to simplify creating other modules that do string manipulation. Source code in core/string.py class StringManipulationModule ( KiaraModule ): \"\"\"Base module to simplify creating other modules that do string manipulation.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_string = inputs . get_value_data ( \"text\" ) result = self . process_string ( input_string ) outputs . set_value ( \"text\" , result ) @abstractmethod def process_string ( self , text : str ) -> str : pass","title":"StringManipulationModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.StringManipulationModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.string.StringManipulationModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table","text":"","title":"table"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.ConvertToTableModule","text":"Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: bytes: a memoryview of the byte-representation of the Table string: the base64-encoded byte-representation of the Table Source code in core/table/__init__.py class ConvertToTableModule ( CreateValueModule ): \"\"\"Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: - bytes: a memoryview of the byte-representation of the Table - string: the base64-encoded byte-representation of the Table \"\"\" _module_type_name = \"create\" _config_cls = TableConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"table\" # def to_bytes(self, value: Value) -> bytes: # # import pyarrow as pa # # table_val: Value = value # table: pa.Table = table_val.get_value_data() # # batches = table.to_batches() # # sink = pa.BufferOutputStream() # writer = pa.ipc.new_stream(sink, batches[0].schema) # # for batch in batches: # writer.write_batch(batch) # writer.close() # # buf: pa.Buffer = sink.getvalue() # return memoryview(buf) # # def to_string(self, value: Value): # # _bytes: bytes = self.to_bytes(value) # string = base64.b64encode(_bytes) # return string.decode() # def from_bytes(self, value: Value): # raise NotImplementedError() # # def from_string(self, value: Value): # raise NotImplementedError() def from_csv_file ( self , value : Value ): from pyarrow import csv input_file : KiaraFile = value . get_value_data () imported_data = csv . read_csv ( input_file . path ) return imported_data def from_text_file_bundle ( self , value : Value ): import pyarrow as pa bundle : KiaraFileBundle = value . get_value_data () columns = FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS ignore_errors = self . get_config_value ( \"ignore_errors\" ) file_dict = bundle . read_text_file_contents ( ignore_errors = ignore_errors ) tabular : typing . Dict [ str , typing . List [ typing . Any ]] = {} for column in columns : for index , rel_path in enumerate ( sorted ( file_dict . keys ())): if column == \"content\" : _value : typing . Any = file_dict [ rel_path ] elif column == \"id\" : _value = index elif column == \"rel_path\" : _value = rel_path else : file_model = bundle . included_files [ rel_path ] _value = getattr ( file_model , column ) tabular . setdefault ( column , []) . append ( _value ) table = pa . Table . from_pydict ( tabular ) return table","title":"ConvertToTableModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.CutColumnModule","text":"Cut off one column from a table, returning an array. Source code in core/table/__init__.py class CutColumnModule ( KiaraModule ): \"\"\"Cut off one column from a table, returning an array.\"\"\" _module_type_name = \"cut_column\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table_value = inputs . get_value_obj ( \"table\" ) column_name : str = inputs . get_value_data ( \"column_name\" ) available = table_value . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if column_name not in available : raise KiaraProcessingException ( f \"Invalid column name ' { column_name } '. Available column names: { available } \" ) table : pa . Table = inputs . get_value_data ( \"table\" ) column = table . column ( column_name ) outputs . set_value ( \"array\" , column )","title":"CutColumnModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.CutColumnModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.CutColumnModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.ExportArrowTable","text":"Export a table object to disk. Source code in core/table/__init__.py class ExportArrowTable ( KiaraModule ): \"\"\"Export a table object to disk.\"\"\" _module_type_name = \"export\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from pyarrow import feather table : pa . Table = inputs . get_value_data ( \"table\" ) full_path : str = inputs . get_value_data ( \"path\" ) force_overwrite = inputs . get_value_data ( \"force_overwrite\" ) format : str = inputs . get_value_data ( \"format\" ) compression = inputs . get_value_data ( \"compression\" ) if compression not in [ \"zstd\" , \"lz4\" , \"uncompressed\" ]: raise KiaraProcessingException ( f \"Invalid compression format ' { compression } '. Allowed: 'zstd', 'lz4', 'uncompressed'.\" ) if format != \"feather\" : raise KiaraProcessingException ( f \"Can't export table to format ' { format } ': only 'feather' supported at the moment.\" ) if os . path . exists ( full_path ) and not force_overwrite : raise KiaraProcessingException ( f \"Can't write table to file, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : format , }, \"value_id\" : NO_VALUE_ID_MARKER , \"output_name\" : \"table\" , } outputs . set_value ( \"load_config\" , result )","title":"ExportArrowTable"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.ExportArrowTable.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.ExportArrowTable.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.LoadArrowTable","text":"Load a table object from disk. Source code in core/table/__init__.py class LoadArrowTable ( KiaraModule ): \"\"\"Load a table object from disk.\"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from pyarrow import feather base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) format = inputs . get_value_data ( \"format\" ) if format != \"feather\" : raise NotImplementedError () path = os . path . join ( base_path , rel_path ) table = feather . read_table ( path ) outputs . set_value ( \"table\" , table )","title":"LoadArrowTable"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.LoadArrowTable.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.LoadArrowTable.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnModule","text":"Map the items of one column of a table onto an array, using another module. Source code in core/table/__init__.py class MapColumnModule ( KiaraModule ): \"\"\"Map the items of one column of a table onto an array, using another module.\"\"\" _config_cls = MapColumnsModuleConfig _module_type_name = \"map_column\" def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table : pa . Table = inputs . get_value_data ( \"table\" ) column_name = inputs . get_value_data ( \"column_name\" ) if column_name not in table . column_names : raise KiaraProcessingException ( f \"Table column ' { column_name } ' not available in table. Available columns: { ', ' . join ( table . column_names ) } .\" ) input_array : pa . Array = table . column ( column_name ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"table\" , \"column_name\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list ))","title":"MapColumnModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnModule.module_instance_doc","text":"Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/table/__init__.py def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result","title":"module_instance_doc()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnsModuleConfig","text":"Source code in core/table/__init__.py class MapColumnsModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , )","title":"MapColumnsModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.input_name","text":"The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input.","title":"input_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.module_config","text":"The config for the kiara filter module.","title":"module_config"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.module_type","text":"The name of the kiara module to use to filter the input data.","title":"module_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.output_name","text":"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.","title":"output_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MergeTableModule","text":"Create a table from other tables and/or arrays. Source code in core/table/__init__.py class MergeTableModule ( KiaraModule ): \"\"\"Create a table from other tables and/or arrays.\"\"\" _module_type_name = \"merge\" _config_cls = MergeTableModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_schema : typing . Dict [ str , typing . Any ] = self . get_config_value ( \"input_schema\" ) sources = {} for field_name in input_schema . keys (): sources [ field_name ] = inputs . get_value_data ( field_name ) len_dict = {} arrays = [] column_names = [] for source_key , table_or_column in sources . items (): if isinstance ( table_or_column , pa . Table ): rows = table_or_column . num_rows for name in table_or_column . schema . names : column = table_or_column . column ( name ) arrays . append ( column ) column_names . append ( name ) elif isinstance ( table_or_column , ( pa . Array , pa . ChunkedArray )): rows = len ( table_or_column ) arrays . append ( table_or_column ) column_names . append ( source_key ) else : raise KiaraProcessingException ( f \"Can't merge table: invalid type ' { type ( table_or_column ) } ' for source ' { source_key } '.\" ) len_dict [ source_key ] = rows all_rows = None for source_key , rows in len_dict . items (): if all_rows is None : all_rows = rows else : if all_rows != rows : all_rows = None break if all_rows is None : len_str = \"\" for name , rows in len_dict . items (): len_str = f \" { name } ( { rows } )\" raise KiaraProcessingException ( f \"Can't merge table, sources have different lengths: { len_str } \" ) table = pa . Table . from_arrays ( arrays = arrays , names = column_names ) outputs . set_value ( \"table\" , table )","title":"MergeTableModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MergeTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MergeTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MergeTableModuleConfig","text":"Source code in core/table/__init__.py class MergeTableModuleConfig ( ModuleTypeConfigSchema ): input_schema : typing . Dict [ str , typing . Any ] = Field ( description = \"A dict describing the inputs for this merge process.\" )","title":"MergeTableModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.MergeTableModuleConfig.input_schema","text":"A dict describing the inputs for this merge process.","title":"input_schema"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.SampleTableModule","text":"Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/table/__init__.py class SampleTableModule ( SampleValueModule ): \"\"\"Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"table\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= 100 : return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( 0 , sample_size ) def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( len ( table ) - sample_size )","title":"SampleTableModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.SampleTableModule.get_value_type","text":"Return the value type for this sample module. Source code in core/table/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"table\"","title":"get_value_type()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.SaveArrowTableConfig","text":"Source code in core/table/__init__.py class SaveArrowTableConfig ( StoreValueModuleConfig ): compression : str = Field ( description = \"The compression to use when saving the table.\" , default = \"zstd\" )","title":"SaveArrowTableConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.SaveArrowTableConfig.compression","text":"The compression to use when saving the table.","title":"compression"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.StoreArrowTable","text":"Source code in core/table/__init__.py class StoreArrowTable ( StoreValueTypeModule ): _config_cls = SaveArrowTableConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"table\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result","title":"StoreArrowTable"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.StoreArrowTable.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/table/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result","title":"store_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.TableConversionModuleConfig","text":"Source code in core/table/__init__.py class TableConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , )","title":"TableConversionModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.TableConversionModuleConfig.ignore_errors","text":"Whether to ignore convert errors and omit the failed items.","title":"ignore_errors"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.TableMetadataModule","text":"Extract metadata from a table object. Source code in core/table/__init__.py class TableMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from a table object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"table\" @classmethod def get_metadata_key ( cls ) -> str : return \"table\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return TableMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa table : pa . Table = value . get_value_data () table_schema = {} for name in table . schema . names : field = table . schema . field ( name ) md = field . metadata _type = field . type if not md : md = { \"arrow_type_id\" : _type . id , } _d = { \"type_name\" : str ( _type ), \"metadata\" : md , } table_schema [ name ] = _d return { \"column_names\" : table . column_names , \"column_schema\" : table_schema , \"rows\" : table . num_rows , \"size\" : table . nbytes , }","title":"TableMetadataModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.filter","text":"","title":"filter"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.filter.CreateFilteredTableModule","text":"Filter a table using a mask array. Source code in core/table/filter.py class CreateFilteredTableModule ( KiaraModule ): \"\"\"Filter a table using a mask array.\"\"\" _module_type_name = \"with_mask\" _config_cls = TableFilterModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered )","title":"CreateFilteredTableModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.filter.CreateFilteredTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.filter.CreateFilteredTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query","text":"","title":"query"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableGraphQL","text":"Execute a graphql aggregation query against an (Arrow) table. References https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } Source code in core/table/query.py class QueryTableGraphQL ( KiaraModule ): \"\"\"Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } \"\"\" _module_type_name = \"graphql\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import vaex table = inputs . get_value_data ( \"table\" ) query = inputs . get_value_data ( \"query\" ) df = vaex . from_arrow_table ( table ) result = df . graphql . execute ( query ) outputs . set_value ( \"query_result\" , result . to_dict ()[ \"data\" ])","title":"QueryTableGraphQL"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableGraphQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableGraphQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableSQL","text":"Execute a sql query against an (Arrow) table. Source code in core/table/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryTableSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import duckdb if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) _relation_name : str = inputs . get_value_data ( \"relation_name\" ) else : _query = self . get_config_value ( \"query\" ) _relation_name = self . get_config_value ( \"relation_name\" ) if _relation_name . upper () in RESERVED_SQL_KEYWORDS : raise KiaraProcessingException ( f \"Invalid relation name ' { _relation_name } ': this is a reserved sql keyword, please select a different name.\" ) _table = inputs . get_value_data ( \"table\" ) rel_from_arrow = duckdb . arrow ( _table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( _relation_name , _query ) outputs . set_value ( \"query_result\" , result . fetch_arrow_table ())","title":"QueryTableSQL"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableSQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableSQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableSQLModuleConfig","text":"Source code in core/table/query.py class QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) relation_name : typing . Optional [ str ] = Field ( description = \"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\" , default = \"data\" , )","title":"QueryTableSQLModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableSQLModuleConfig.query","text":"The query to execute. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.query.QueryTableSQLModuleConfig.relation_name","text":"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.","title":"relation_name"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.utils","text":"","title":"utils"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.table.utils.create_sqlite_schema_data_from_arrow_table","text":"Create a sql schema statement from an Arrow table object. Parameters: Name Type Description Default table pa.Table the Arrow table object required column_map Optional[Mapping[str, str]] a map that contains column names that should be changed in the new table None index_columns Optional[Iterable[str]] a list of column names (after mapping) to create module_indexes for None extra_column_info Optional[Mapping[str, Iterable[str]]] a list of extra schema instructions per column name (after mapping) None Source code in core/table/utils.py def create_sqlite_schema_data_from_arrow_table ( table : \"pa.Table\" , column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , index_columns : typing . Optional [ typing . Iterable [ str ]] = None , extra_column_info : typing . Optional [ typing . Mapping [ str , typing . Iterable [ str ]] ] = None , ) -> SqliteTableSchema : \"\"\"Create a sql schema statement from an Arrow table object. Arguments: table: the Arrow table object column_map: a map that contains column names that should be changed in the new table index_columns: a list of column names (after mapping) to create module_indexes for extra_column_info: a list of extra schema instructions per column name (after mapping) \"\"\" columns = convert_arrow_column_types_to_sqlite ( table = table ) if column_map is None : column_map = {} if extra_column_info is None : extra_column_info = {} temp : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if index_columns is None : index_columns = [] for cn , data in columns . items (): if cn in column_map . keys (): new_key = column_map [ cn ] else : new_key = cn temp_data = dict ( data ) if new_key in extra_column_info . keys (): temp_data [ \"extra_column_info\" ] = extra_column_info [ new_key ] else : temp_data [ \"extra_column_info\" ] = [ \"\" ] if cn in index_columns : temp_data [ \"create_index\" ] = True temp [ new_key ] = temp_data columns = temp if not columns : raise Exception ( \"Resulting table schema has no columns.\" ) else : for ic in index_columns : if ic not in columns . keys (): raise Exception ( f \"Can't create schema, requested index column name not available: { ic } \" ) return SqliteTableSchema ( columns = columns , column_map = column_map )","title":"create_sqlite_schema_data_from_arrow_table()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value","text":"","title":"value"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value.DataProfilerModule","text":"Generate a data profile report for a dataset. This uses the DataProfiler Python library, check out its documentation for more details. Source code in core/value.py class DataProfilerModule ( KiaraModule ): \"\"\"Generate a data profile report for a dataset. This uses the [DataProfiler](https://capitalone.github.io/DataProfiler/docs/0.7.0/html/index.html) Python library, check out its documentation for more details. \"\"\" _module_type_name = \"data_profile\" _config_cls = DataProfilerModuleConfig @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from dataprofiler import Data , Profiler , ProfilerOptions , set_verbosity set_verbosity ( logging . WARNING ) value_type = self . get_config_value ( \"value_type\" ) profile_options = ProfilerOptions () profile_options . structured_options . data_labeler . is_enabled = False profile_options . unstructured_options . data_labeler . is_enabled = False if value_type == \"table\" : table_item : pa . Table = inputs . get_value_data ( \"item\" ) pd = table_item . to_pandas () profile = Profiler ( pd , options = profile_options ) # Calculate Statistics, Entity Recognition, etc report = profile . report () elif value_type == \"file\" : file_item : KiaraFile = inputs . get_value_data ( \"item\" ) data = Data ( file_item . path ) profile = Profiler ( data , options = profile_options ) report = profile . report () else : raise KiaraProcessingException ( f \"Data profiling of value type ' { value_type } ' not supported.\" ) outputs . set_value ( \"report\" , report )","title":"DataProfilerModule"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value.DataProfilerModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value.DataProfilerModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value.DataProfilerModule.retrieve_module_profiles","text":"Retrieve a collection of profiles (pre-set module configs) for this kiara module type. This is used to automatically create generally useful operations (incl. their ids). Source code in core/value.py @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles","title":"retrieve_module_profiles()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value.DataProfilerModuleConfig","text":"Source code in core/value.py class DataProfilerModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to profile.\" )","title":"DataProfilerModuleConfig"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value.DataProfilerModuleConfig.value_type","text":"The value type to profile.","title":"value_type"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types","text":"This module contains the value type classes that are used in the kiara_modules.core package.","title":"value_types"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.ArrayType","text":"An Apache arrow array. Source code in core/value_types.py class ArrayType ( AnyType ): \"\"\"An Apache arrow array.\"\"\" _value_type_name = \"array\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Array @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . ChunkedArray , pa . Table ] def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 ) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) array = value . get_value_data () import pyarrow as pa temp_table = pa . Table . from_arrays ( arrays = [ array ], names = [ \"array\" ]) atw = ArrowTabularWrap ( temp_table ) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result","title":"ArrayType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.ArrayType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 )","title":"parse_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.ArrayType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.BooleanType","text":"A boolean. Source code in core/value_types.py class BooleanType ( AnyType ): \"A boolean.\" _value_type_name = \"boolean\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bool @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"BooleanType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.BooleanType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.BooleanType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.BytesType","text":"An array of bytes. Source code in core/value_types.py class BytesType ( AnyType ): \"\"\"An array of bytes.\"\"\" _value_type_name = \"bytes\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bytes @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : bytes = value . get_value_data () return [ data . decode ()] # @classmethod # def get_operations( # cls, # ) -> typing.Mapping[str, typing.Mapping[str, typing.Mapping[str, typing.Any]]]: # # return { # \"save_value\": { # \"default\": { # \"module_type\": \"bytes.save\", # \"input_name\": \"bytes\", # } # } # }","title":"BytesType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.BytesType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DatabaseType","text":"A database, containing one or several tables. This is backed by sqlite databases. Source code in core/value_types.py class DatabaseType ( ComplexModelType [ KiaraDatabase ]): \"\"\"A database, containing one or several tables. This is backed by sqlite databases. \"\"\" _value_type_name = \"database\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return KiaraDatabase @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraDatabase , str ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : KiaraDatabase = value . get_value_data () from sqlalchemy import inspect inspector = inspect ( db . get_sqlalchemy_engine ()) result : typing . List [ typing . Any ] = [ \"\" ] for table_name in inspector . get_table_names (): atw = SqliteTabularWrap ( db = db , table_name = table_name ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { table_name } [/i]\" ) result . append ( pretty ) return result","title":"DatabaseType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DatabaseType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value","title":"parse_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core/value_types.py class DateType ( AnyType ): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _value_type_name = \"date\" @classmethod def backing_python_type ( cls ) -> typing . Type : return datetime . datetime @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value )) def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"DateType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DateType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DateType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v Any the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None","title":"parse_value()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DateType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DictType","text":"A dict-like object. Source code in core/value_types.py class DictType ( AnyType ): \"\"\"A dict-like object.\"\"\" _value_type_name = \"dict\" @classmethod def backing_python_type ( cls ) -> typing . Type : return dict @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )]","title":"DictType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DictType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ])","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.DictType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FileBundleType","text":"A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileBundleType ( AnyType ): \"\"\"A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file_bundle\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFileBundle @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFileBundle ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_no_included_files = print_config . get ( \"max_no_files\" , 40 ) data : KiaraFileBundle = value . get_value_data () pretty = data . dict ( exclude = { \"included_files\" }) files = list ( data . included_files . keys ()) if max_no_included_files >= 0 : if len ( files ) > max_no_included_files : half = int (( max_no_included_files - 1 ) / 2 ) head = files [ 0 : half ] tail = files [ - 1 * half :] # noqa files = ( head + [ \"..... output skipped .....\" , \"..... output skipped .....\" ] + tail ) pretty [ \"included_files\" ] = files return [ json . dumps ( pretty , indent = 2 )] # return [data.json(indent=2)]","title":"FileBundleType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FileBundleType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FileType","text":"A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileType ( AnyType ): \"\"\"A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFile @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFile ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : KiaraFile = value . get_value_data () max_lines = print_config . get ( \"max_lines\" , 34 ) try : lines = [] with open ( data . path , \"r\" ) as f : for idx , l in enumerate ( f ): if idx > max_lines : lines . append ( \"... \\n \" ) lines . append ( \"...\" ) break lines . append ( l ) # TODO: syntax highlighting return [ \"\" . join ( lines )] except UnicodeDecodeError : # found non-text data return [ \"Binary file or non-utf8 enconding, not printing content...\" , \"\" , \"[b]File metadata:[/b]\" , \"\" , data . json ( indent = 2 ), ]","title":"FileType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FileType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FloatType","text":"A float. Source code in core/value_types.py class FloatType ( AnyType ): \"A float.\" _value_type_name = \"float\" @classmethod def backing_python_type ( cls ) -> typing . Type : return float @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"FloatType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FloatType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.FloatType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.IntegerType","text":"An integer. Source code in core/value_types.py class IntegerType ( AnyType ): \"\"\"An integer.\"\"\" _value_type_name = \"integer\" @classmethod def backing_python_type ( cls ) -> typing . Type : return int @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"IntegerType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.IntegerType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.IntegerType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.ListType","text":"A list-like object. Source code in core/value_types.py class ListType ( AnyType ): \"\"\"A list-like object.\"\"\" _value_type_name = \"list\" @classmethod def backing_python_type ( cls ) -> typing . Type : return list @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )]","title":"ListType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.ListType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ])","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.ListType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.RenderablesType","text":"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. Source code in core/value_types.py class RenderablesType ( ValueType [ object , ValueTypeConfigSchema ]): \"\"\"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. \"\"\" _value_type_name = \"renderables\" @classmethod def backing_python_type ( cls ) -> typing . Type : return object @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , ConsoleRenderable , RichCast ] @classmethod def type_config_cls ( cls ) -> typing . Type [ ValueTypeConfigSchema ]: return ValueTypeConfigSchema","title":"RenderablesType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.StringType","text":"A string. Source code in core/value_types.py class StringType ( AnyType ): \"\"\"A string.\"\"\" _value_type_name = \"string\" @classmethod def backing_python_type ( cls ) -> typing . Type : return str @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ data ]","title":"StringType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.StringType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.StringType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.TableType","text":"A table. Internally, this is backed by the Apache Arrow Table class. Source code in core/value_types.py class TableType ( AnyType ): \"\"\"A table. Internally, this is backed by the [Apache Arrow](https://arrow.apache.org) [``Table``](https://arrow.apache.org/docs/python/generated/pyarrow.Table.html) class. \"\"\" _value_type_name = \"table\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Table @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . Table ] @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None # @classmethod # def get_supported_hash_types(cls) -> typing.Iterable[str]: # # return [\"pandas_df_hash\"] # # @classmethod # def calculate_value_hash(cls, value: typing.Any, hash_type: str) -> str: # # import pyarrow as pa # # # this is only for testing, and will be replaced with a native arrow table hush function, once I figure out how to do that efficiently # table: pa.Table = value # from pandas.util import hash_pandas_object # # hash_result = hash_pandas_object(table.to_pandas()).sum() # return str(hash_result) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) atw = ArrowTabularWrap ( value . get_value_data ()) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result","title":"TableType"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.TableType.check_data","text":"Check whether the provided input matches this value type. If it does, return a ValueType object (with the appropriate type configuration). Source code in core/value_types.py @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None","title":"check_data()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.value_types.TableType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" )","title":"validate()"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.yaml","text":"","title":"yaml"},{"location":"reference/kiara_modules/core/__init__/#kiara_modules.core.yaml.ToYamlModuleOld","text":"Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. Source code in core/yaml.py class ToYamlModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. \"\"\" _module_type_name = \"to_yaml\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return YAML_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"yaml\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_yaml ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"ToYamlModuleOld"},{"location":"reference/kiara_modules/core/boolean/","text":"","title":"boolean"},{"location":"reference/kiara_modules/core/date/","text":"A collection of date related modules. Most of those are very bare-bones, not really dealing with more advanced (but very important) concepts like timezones and resolution yet. DateRangeCheckModule ( KiaraModule ) \u00b6 Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"range_check\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser d = inputs . get_value_data ( \"date\" ) earliest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if hasattr ( d , \"as_py\" ): d = d . as_py () if isinstance ( d , str ): d = parser . parse ( d ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs ExtractDateModule ( KiaraModule ) \u00b6 Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"extract_from_string\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) date_match = re . findall ( r \"_(\\d {4} -\\d {2} -\\d {2} )_\" , text ) assert date_match d_obj = parser . parse ( date_match [ 0 ]) # type: ignore outputs . set_value ( \"date\" , d_obj ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"date"},{"location":"reference/kiara_modules/core/date/#kiara_modules.core.date.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return True if that's the case, otherwise False . Source code in core/date.py class DateRangeCheckModule ( KiaraModule ): \"\"\"Check whether a date falls within a specified date range. If none one of the inputs 'earliest' or 'latest' is set, this module will always return 'True'. Return ``True`` if that's the case, otherwise ``False``. \"\"\" _module_type_name = \"range_check\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser d = inputs . get_value_data ( \"date\" ) earliest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if not earliest and not latest : outputs . set_value ( \"within_range\" , True ) return if hasattr ( d , \"as_py\" ): d = d . as_py () if isinstance ( d , str ): d = parser . parse ( d ) if earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"DateRangeCheckModule"},{"location":"reference/kiara_modules/core/date/#kiara_modules.core.date.DateRangeCheckModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/date/#kiara_modules.core.date.DateRangeCheckModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/date/#kiara_modules.core.date.ExtractDateModule","text":"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" Source code in core/date.py class ExtractDateModule ( KiaraModule ): \"\"\"Extract a date object from a string. This module is not really smart yet, currently it uses the following regex to extract a date (which might fail in a lot of cases): r\"_(\\d{4}-\\d{2}-\\d{2})_\" \"\"\" _module_type_name = \"extract_from_string\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from dateutil import parser text = inputs . get_value_data ( \"text\" ) date_match = re . findall ( r \"_(\\d {4} -\\d {2} -\\d {2} )_\" , text ) assert date_match d_obj = parser . parse ( date_match [ 0 ]) # type: ignore outputs . set_value ( \"date\" , d_obj )","title":"ExtractDateModule"},{"location":"reference/kiara_modules/core/date/#kiara_modules.core.date.ExtractDateModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/date/#kiara_modules.core.date.ExtractDateModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/date.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/defaults/","text":"KIARA_MODULES_CORE_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara network module package. KIARA_MODULES_CORE_RESOURCES_FOLDER \u00b6 Default resources folder for this package.","title":"defaults"},{"location":"reference/kiara_modules/core/defaults/#kiara_modules.core.defaults.KIARA_MODULES_CORE_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara network module package.","title":"KIARA_MODULES_CORE_BASE_FOLDER"},{"location":"reference/kiara_modules/core/defaults/#kiara_modules.core.defaults.KIARA_MODULES_CORE_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_MODULES_CORE_RESOURCES_FOLDER"},{"location":"reference/kiara_modules/core/dev/","text":"Modules that are useful for kiara as well as pipeline-development, as well as testing. DummyModule ( KiaraModule ) \u00b6 Module that simulates processing, but uses hard-coded outputs as a result. Source code in core/dev.py class DummyModule ( KiaraModule ): \"\"\"Module that simulates processing, but uses hard-coded outputs as a result.\"\"\" _config_cls = DummyProcessingModuleConfig def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) # def _get_doc(self) -> str: # # doc = self.config.get(\"doc\", None) # # if doc: # return self.config[\"doc\"] # else: # return super()._get_doc() create_input_schema ( self ) \u00b6 The input schema for the dummy module is created at object creation time from the input_schemas config parameter. Source code in core/dev.py def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result create_output_schema ( self ) \u00b6 The output schema for the dummy module is created at object creation time from the output_schemas config parameter. Source code in core/dev.py def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result process ( self , inputs , outputs ) \u00b6 Returns the hardcoded output values that are set in the outputs config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the delay config parameter). Source code in core/dev.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) DummyProcessingModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Configuration for the 'dummy' processing module. Source code in core/dev.py class DummyProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Configuration for the 'dummy' processing module.\"\"\" documentation : typing . Optional [ str ] = None input_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The input schema for this module.\" ) output_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The output schema for this module.\" ) outputs : typing . Dict [ str , typing . Any ] = Field ( description = \"The (dummy) output for this module.\" , default_factory = dict ) delay : float = Field ( description = \"The delay in seconds from processing start to when the (dummy) outputs are returned.\" , default = 0 , ) delay : float pydantic-field \u00b6 The delay in seconds from processing start to when the (dummy) outputs are returned. input_schema : Dict [ str , Dict ] pydantic-field required \u00b6 The input schema for this module. output_schema : Dict [ str , Dict ] pydantic-field required \u00b6 The output schema for this module. outputs : Dict [ str , Any ] pydantic-field \u00b6 The (dummy) output for this module.","title":"dev"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyModule","text":"Module that simulates processing, but uses hard-coded outputs as a result. Source code in core/dev.py class DummyModule ( KiaraModule ): \"\"\"Module that simulates processing, but uses hard-coded outputs as a result.\"\"\" _config_cls = DummyProcessingModuleConfig def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) # def _get_doc(self) -> str: # # doc = self.config.get(\"doc\", None) # # if doc: # return self.config[\"doc\"] # else: # return super()._get_doc()","title":"DummyModule"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyModule.create_input_schema","text":"The input schema for the dummy module is created at object creation time from the input_schemas config parameter. Source code in core/dev.py def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyModule.create_output_schema","text":"The output schema for the dummy module is created at object creation time from the output_schemas config parameter. Source code in core/dev.py def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyModule.process","text":"Returns the hardcoded output values that are set in the outputs config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the delay config parameter). Source code in core/dev.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict )","title":"process()"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyProcessingModuleConfig","text":"Configuration for the 'dummy' processing module. Source code in core/dev.py class DummyProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Configuration for the 'dummy' processing module.\"\"\" documentation : typing . Optional [ str ] = None input_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The input schema for this module.\" ) output_schema : typing . Dict [ str , typing . Dict ] = Field ( description = \"The output schema for this module.\" ) outputs : typing . Dict [ str , typing . Any ] = Field ( description = \"The (dummy) output for this module.\" , default_factory = dict ) delay : float = Field ( description = \"The delay in seconds from processing start to when the (dummy) outputs are returned.\" , default = 0 , )","title":"DummyProcessingModuleConfig"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyProcessingModuleConfig.delay","text":"The delay in seconds from processing start to when the (dummy) outputs are returned.","title":"delay"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyProcessingModuleConfig.input_schema","text":"The input schema for this module.","title":"input_schema"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyProcessingModuleConfig.output_schema","text":"The output schema for this module.","title":"output_schema"},{"location":"reference/kiara_modules/core/dev/#kiara_modules.core.dev.DummyProcessingModuleConfig.outputs","text":"The (dummy) output for this module.","title":"outputs"},{"location":"reference/kiara_modules/core/dict/","text":"SaveDictModule ( StoreValueTypeModule ) \u00b6 Source code in core/dict.py class SaveDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"dict\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/dict.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"dict"},{"location":"reference/kiara_modules/core/dict/#kiara_modules.core.dict.SaveDictModule","text":"Source code in core/dict.py class SaveDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"dict\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"SaveDictModule"},{"location":"reference/kiara_modules/core/dict/#kiara_modules.core.dict.SaveDictModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/dict.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/file/","text":"DefaultFileImportModule ( FileImportModule ) \u00b6 Import an external file into a kiara session. Source code in core/file.py class DefaultFileImportModule ( FileImportModule ): \"\"\"Import an external file into a kiara session.\"\"\" _module_type_name = \"import\" def import_from__file_path__string ( self , source : str ) -> KiaraFile : file_model = KiaraFile . load_file ( source ) return file_model LoadLocalFileModule ( KiaraModule ) \u00b6 Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. Source code in core/file.py class LoadLocalFileModule ( KiaraModule ): \"\"\"Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. \"\"\" # _config_cls = ImportLocalPathConfig _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) file_model = KiaraFile . load_file ( path ) outputs . set_value ( \"file\" , file_model ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } StoreFileTypeModule ( StoreValueTypeModule ) \u00b6 Save a file to disk. Source code in core/file.py class StoreFileTypeModule ( StoreValueTypeModule ): \"\"\"Save a file to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm ) store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/file.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm )","title":"file"},{"location":"reference/kiara_modules/core/file/#kiara_modules.core.file.DefaultFileImportModule","text":"Import an external file into a kiara session. Source code in core/file.py class DefaultFileImportModule ( FileImportModule ): \"\"\"Import an external file into a kiara session.\"\"\" _module_type_name = \"import\" def import_from__file_path__string ( self , source : str ) -> KiaraFile : file_model = KiaraFile . load_file ( source ) return file_model","title":"DefaultFileImportModule"},{"location":"reference/kiara_modules/core/file/#kiara_modules.core.file.LoadLocalFileModule","text":"Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. Source code in core/file.py class LoadLocalFileModule ( KiaraModule ): \"\"\"Load a file and its metadata. This module does not read or load the content of a file, but contains the path to the local representation/version of the file so it can be read by a subsequent process. \"\"\" # _config_cls = ImportLocalPathConfig _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) file_model = KiaraFile . load_file ( path ) outputs . set_value ( \"file\" , file_model )","title":"LoadLocalFileModule"},{"location":"reference/kiara_modules/core/file/#kiara_modules.core.file.LoadLocalFileModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file within the base directory.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/file/#kiara_modules.core.file.LoadLocalFileModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/file/#kiara_modules.core.file.StoreFileTypeModule","text":"Save a file to disk. Source code in core/file.py class StoreFileTypeModule ( StoreValueTypeModule ): \"\"\"Save a file to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm )","title":"StoreFileTypeModule"},{"location":"reference/kiara_modules/core/file/#kiara_modules.core.file.StoreFileTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/file.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: file_obj = value . get_value_data () file_name = file_obj . file_name full_target = os . path . join ( base_path , file_name ) os . makedirs ( os . path . dirname ( full_target ), exist_ok = True ) if os . path . exists ( full_target ): raise KiaraProcessingException ( f \"Can't save file, path already exists: { full_target } \" ) fm = file_obj . copy_file ( full_target , is_onboarded = True ) load_config = { \"module_type\" : \"file.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : file_name }, \"output_name\" : \"file\" , } return ( load_config , fm )","title":"store_value()"},{"location":"reference/kiara_modules/core/file_bundle/","text":"DefaultFileBundleImportModule ( FileBundleImportModule ) \u00b6 Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. Source code in core/file_bundle.py class DefaultFileBundleImportModule ( FileBundleImportModule ): \"\"\"Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. \"\"\" _module_type_name = \"import\" def import_from__folder_path__string ( self , source : str ) -> KiaraFileBundle : file_bundle_model = KiaraFileBundle . import_folder ( source ) return file_bundle_model LoadFileBundleModule ( KiaraModule ) \u00b6 Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. Source code in core/file_bundle.py class LoadFileBundleModule ( KiaraModule ): \"\"\"Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. \"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) included_files = inputs . get_value_data ( \"include_files\" ) excluded_dirs = inputs . get_value_data ( \"exclude_dirs\" ) excluded_files = inputs . get_value_data ( \"exclude_files\" ) import_config = FolderImportConfig ( include_files = included_files , exclude_dirs = excluded_dirs , excluded_files = excluded_files , ) bundle = KiaraFileBundle . import_folder ( source = path , import_config = import_config ) outputs . set_values ( file_bundle = bundle ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } StoreFileBundleType ( StoreValueTypeModule ) \u00b6 Save a file bundle to disk. Source code in core/file_bundle.py class StoreFileBundleType ( StoreValueTypeModule ): \"\"\"Save a file bundle to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file_bundle\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb ) store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/file_bundle.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb )","title":"file_bundle"},{"location":"reference/kiara_modules/core/file_bundle/#kiara_modules.core.file_bundle.DefaultFileBundleImportModule","text":"Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. Source code in core/file_bundle.py class DefaultFileBundleImportModule ( FileBundleImportModule ): \"\"\"Import a file bundle into the kiara data store. This module will support multiple source types and profiles in the future, but at the moment only import from local folder is supported. Thus, requiring the config value 'local' for 'source_profile', and 'folder_path' for 'source_type'. \"\"\" _module_type_name = \"import\" def import_from__folder_path__string ( self , source : str ) -> KiaraFileBundle : file_bundle_model = KiaraFileBundle . import_folder ( source ) return file_bundle_model","title":"DefaultFileBundleImportModule"},{"location":"reference/kiara_modules/core/file_bundle/#kiara_modules.core.file_bundle.LoadFileBundleModule","text":"Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. Source code in core/file_bundle.py class LoadFileBundleModule ( KiaraModule ): \"\"\"Load a file bundle and its metadata. This module does not read or load the content of all included files, but contains the path to the local representation/version of them so they can be read by a subsequent process. \"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) included_files = inputs . get_value_data ( \"include_files\" ) excluded_dirs = inputs . get_value_data ( \"exclude_dirs\" ) excluded_files = inputs . get_value_data ( \"exclude_files\" ) import_config = FolderImportConfig ( include_files = included_files , exclude_dirs = excluded_dirs , excluded_files = excluded_files , ) bundle = KiaraFileBundle . import_folder ( source = path , import_config = import_config ) outputs . set_values ( file_bundle = bundle )","title":"LoadFileBundleModule"},{"location":"reference/kiara_modules/core/file_bundle/#kiara_modules.core.file_bundle.LoadFileBundleModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path where the folder lives.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the folder, within the base path location.\" , }, \"include_files\" : { \"type\" : \"list\" , \"doc\" : \"A list of strings, include all files where the filename ends with one of those strings. \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"optional\" : True , }, \"exclude_dirs\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all folders whose name ends with that string. Defaults to: { DEFAULT_EXCLUDE_DIRS } . \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_DIRS , \"optional\" : True , }, \"exclude_files\" : { \"type\" : \"list\" , \"doc\" : f \"A list of strings, exclude all files that end with that one of those strings (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } \\n\\n Only full string matches are supported at the moment, globs and regex might be in the future.\" , \"default\" : DEFAULT_EXCLUDE_FILES , \"optional\" : True , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/file_bundle/#kiara_modules.core.file_bundle.LoadFileBundleModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/file_bundle.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/file_bundle/#kiara_modules.core.file_bundle.StoreFileBundleType","text":"Save a file bundle to disk. Source code in core/file_bundle.py class StoreFileBundleType ( StoreValueTypeModule ): \"\"\"Save a file bundle to disk.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"file_bundle\" def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb )","title":"StoreFileBundleType"},{"location":"reference/kiara_modules/core/file_bundle/#kiara_modules.core.file_bundle.StoreFileBundleType.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/file_bundle.py def store_value ( self , value : Value , base_path : str ) -> typing . Tuple [ typing . Dict [ str , typing . Any ], typing . Any ]: bundle : KiaraFileBundle = value . get_value_data () rel_path = bundle . bundle_name target_path = os . path . join ( base_path , rel_path ) fb = bundle . copy_bundle ( target_path , is_onboarded = True ) # # the following changes the input value, which is usually not allowed, but the file_bundle type is a special case # bundle.included_files = fb.included_files # bundle.is_onboarded = True # bundle.path = fb.path # for path, f in bundle.included_files.items(): # f.is_onboarded = True load_config = { \"module_type\" : \"file_bundle.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : rel_path }, \"output_name\" : \"file_bundle\" , } return ( load_config , fb )","title":"store_value()"},{"location":"reference/kiara_modules/core/generic/","text":"JsonSerializationConfig ( StoreValueModuleConfig ) pydantic-model \u00b6 Source code in core/generic.py class JsonSerializationConfig ( StoreValueModuleConfig ): options : int = Field ( description = \"The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details.\" , default = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) file_name : str = Field ( description = \"The name of the serialized file.\" , default = \"dict.json\" ) file_name : str pydantic-field \u00b6 The name of the serialized file. options : int pydantic-field \u00b6 The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details. RestoreFromJsonDictModule ( KiaraModule ) \u00b6 Source code in core/generic.py class RestoreFromJsonDictModule ( KiaraModule ): _module_type_name = \"restore_from_json\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) file_name = inputs . get_value_data ( \"file_name\" ) full_path = os . path . join ( base_path , file_name ) if not os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't deserialize dict, path to file does not exist: { full_path } \" ) if not os . path . isfile ( os . path . realpath ( full_path )): raise KiaraProcessingException ( f \"Can't deserialize dict, path is not a file: { full_path } \" ) with open ( full_path , \"r\" ) as f : content = f . read () data = orjson . loads ( content ) outputs . set_value ( \"value_item\" , data ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }} RestoreScalarModule ( KiaraModule ) \u00b6 Utility module, only used internally. Source code in core/generic.py class RestoreScalarModule ( KiaraModule ): \"\"\"Utility module, only used internally.\"\"\" _module_type_name = \"restore_scalar\" _config_cls = RestoreScalarModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : data = inputs . get_value_obj ( \"scalar_data\" ) outputs . set_value ( \"value_item\" , data ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } } RestoreScalarModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/generic.py class RestoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to load.\" ) value_type : str pydantic-field required \u00b6 The value type of the scalar to load. StoreScalarModule ( StoreValueTypeModule ) \u00b6 Source code in core/generic.py class StoreScalarModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return [ \"boolean\" , \"integer\" , \"float\" , \"string\" ] def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/generic.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config StoreScalarModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/generic.py class StoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to store.\" ) value_type : str pydantic-field required \u00b6 The value type of the scalar to store.","title":"generic"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.JsonSerializationConfig","text":"Source code in core/generic.py class JsonSerializationConfig ( StoreValueModuleConfig ): options : int = Field ( description = \"The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details.\" , default = orjson . OPT_NAIVE_UTC | orjson . OPT_SERIALIZE_NUMPY , ) file_name : str = Field ( description = \"The name of the serialized file.\" , default = \"dict.json\" )","title":"JsonSerializationConfig"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.JsonSerializationConfig.file_name","text":"The name of the serialized file.","title":"file_name"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.JsonSerializationConfig.options","text":"The options to use for the json serialization. Check https://github.com/ijl/orjson#quickstart for details.","title":"options"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreFromJsonDictModule","text":"Source code in core/generic.py class RestoreFromJsonDictModule ( KiaraModule ): _module_type_name = \"restore_from_json\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) file_name = inputs . get_value_data ( \"file_name\" ) full_path = os . path . join ( base_path , file_name ) if not os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't deserialize dict, path to file does not exist: { full_path } \" ) if not os . path . isfile ( os . path . realpath ( full_path )): raise KiaraProcessingException ( f \"Can't deserialize dict, path is not a file: { full_path } \" ) with open ( full_path , \"r\" ) as f : content = f . read () data = orjson . loads ( content ) outputs . set_value ( \"value_item\" , data )","title":"RestoreFromJsonDictModule"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreFromJsonDictModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The folder that contains the serialized dict.\" , }, \"file_name\" : { \"type\" : \"string\" , \"doc\" : \"The file name of the serialized dict.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreFromJsonDictModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"dict\" , \"doc\" : \"The deserialized dict value.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreScalarModule","text":"Utility module, only used internally. Source code in core/generic.py class RestoreScalarModule ( KiaraModule ): \"\"\"Utility module, only used internally.\"\"\" _module_type_name = \"restore_scalar\" _config_cls = RestoreScalarModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : data = inputs . get_value_obj ( \"scalar_data\" ) outputs . set_value ( \"value_item\" , data )","title":"RestoreScalarModule"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreScalarModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"scalar_data\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The scalar value.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreScalarModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/generic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : \"The loaded item.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreScalarModuleConfig","text":"Source code in core/generic.py class RestoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to load.\" )","title":"RestoreScalarModuleConfig"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.RestoreScalarModuleConfig.value_type","text":"The value type of the scalar to load.","title":"value_type"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.StoreScalarModule","text":"Source code in core/generic.py class StoreScalarModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return [ \"boolean\" , \"integer\" , \"float\" , \"string\" ] def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config","title":"StoreScalarModule"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.StoreScalarModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/generic.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: data = value . get_value_data () load_config = { \"module_type\" : \"generic.restore_scalar\" , \"module_config\" : { \"value_type\" : self . get_config_value ( \"value_type\" )}, \"base_path_input_name\" : None , \"inputs\" : { \"scalar_data\" : data }, \"output_name\" : \"value_item\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.StoreScalarModuleConfig","text":"Source code in core/generic.py class StoreScalarModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type of the scalar to store.\" )","title":"StoreScalarModuleConfig"},{"location":"reference/kiara_modules/core/generic/#kiara_modules.core.generic.StoreScalarModuleConfig.value_type","text":"The value type of the scalar to store.","title":"value_type"},{"location":"reference/kiara_modules/core/import/","text":"","title":"import"},{"location":"reference/kiara_modules/core/json/","text":"ToJsonModuleOld ( OldTypeConversionModule ) \u00b6 Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. Source code in core/json.py class ToJsonModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. \"\"\" _module_type_name = \"to_json\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return JSON_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"json\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_json ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"json"},{"location":"reference/kiara_modules/core/json/#kiara_modules.core.json.ToJsonModuleOld","text":"Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. Source code in core/json.py class ToJsonModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into json. Very early days for this module, it doesn't support a lot of types yet. \"\"\" _module_type_name = \"to_json\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return JSON_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"json\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_json ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"ToJsonModuleOld"},{"location":"reference/kiara_modules/core/list/","text":"IncludedInListCheckModule ( KiaraModule ) \u00b6 Check whether an element is in a list. Source code in core/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"contains\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs StoreDictModule ( StoreValueTypeModule ) \u00b6 Source code in core/list.py class StoreDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"list\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/list.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"list"},{"location":"reference/kiara_modules/core/list/#kiara_modules.core.list.IncludedInListCheckModule","text":"Check whether an element is in a list. Source code in core/list.py class IncludedInListCheckModule ( KiaraModule ): \"\"\"Check whether an element is in a list.\"\"\" _module_type_name = \"contains\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"IncludedInListCheckModule"},{"location":"reference/kiara_modules/core/list/#kiara_modules.core.list.IncludedInListCheckModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/list/#kiara_modules.core.list.IncludedInListCheckModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/list.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/list/#kiara_modules.core.list.StoreDictModule","text":"Source code in core/list.py class StoreDictModule ( StoreValueTypeModule ): _config_cls = JsonSerializationConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"list\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"StoreDictModule"},{"location":"reference/kiara_modules/core/list/#kiara_modules.core.list.StoreDictModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/list.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import orjson options = self . get_config_value ( \"options\" ) file_name = self . get_config_value ( \"file_name\" ) json_str = orjson . dumps ( value . get_value_data (), option = options ) bp = Path ( base_path ) bp . mkdir ( parents = True , exist_ok = True ) full_path = bp / file_name full_path . write_bytes ( json_str ) load_config = { \"module_type\" : \"generic.restore_from_json\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : base_path , \"file_name\" : self . get_config_value ( \"file_name\" ), }, \"output_name\" : \"value_item\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/logic/","text":"AndModule ( LogicProcessingModule ) \u00b6 Returns 'True' if both inputs are 'True'. Source code in core/logic.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } LogicProcessingModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Config class for all the 'logic'-related modules. Source code in core/logic.py class LogicProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , ) delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule ( LogicProcessingModule ) \u00b6 Negates the input. Source code in core/logic.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) create_input_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_output_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in core/logic.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule ( LogicProcessingModule ) \u00b6 Returns 'True' if one of the inputs is 'True'. Source code in core/logic.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" )) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"logic"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.AndModule","text":"Returns 'True' if both inputs are 'True'. Source code in core/logic.py class AndModule ( LogicProcessingModule ): \"\"\"Returns 'True' if both inputs are 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"AndModule"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.AndModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.AndModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules. Source code in core/logic.py class LogicProcessingModuleConfig ( ModuleTypeConfigSchema ): \"\"\"Config class for all the 'logic'-related modules.\"\"\" delay : float = Field ( default = 0 , description = \"the delay in seconds from processing start to when the output is returned.\" , )","title":"LogicProcessingModuleConfig"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.LogicProcessingModuleConfig.delay","text":"the delay in seconds from processing start to when the output is returned.","title":"delay"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.NotModule","text":"Negates the input. Source code in core/logic.py class NotModule ( LogicProcessingModule ): \"\"\"Negates the input.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"NotModule"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.NotModule.create_input_schema","text":"The not module only has one input, a boolean that will be negated by the module. Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.NotModule.create_output_schema","text":"The output of this module is a single boolean, the negated input. Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.NotModule.process","text":"Negates the input boolean. Source code in core/logic.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"process()"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.OrModule","text":"Returns 'True' if one of the inputs is 'True'. Source code in core/logic.py class OrModule ( LogicProcessingModule ): \"\"\"Returns 'True' if one of the inputs is 'True'.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"OrModule"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.OrModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/logic/#kiara_modules.core.logic.OrModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/logic.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/metadata_models/","text":"This module contains the metadata models that are used in the kiara_modules.core package. Metadata models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata that is attached to data, as well as kiara modules. It is possible to register metadata using a JSON schema string, but it is recommended to create a metadata model, because it is much easier overall. Metadata models must be a sub-class of kiara.metadata.MetadataModel . ArrayMetadata ( HashedMetadataModel ) pydantic-model \u00b6 Describes properties fo the 'array' type. Source code in core/metadata_models.py class ArrayMetadata ( HashedMetadataModel ): \"\"\"Describes properties fo the 'array' type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"array\" length : int = Field ( description = \"The number of elements the array contains.\" ) size : int = Field ( description = \"Total number of bytes consumed by the elements of the array.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"length\" : self . length , \"size\" : self . size } def get_category_alias ( self ) -> str : return \"instance.metadata.array\" length : int pydantic-field required \u00b6 The number of elements the array contains. size : int pydantic-field required \u00b6 Total number of bytes consumed by the elements of the array. ColumnSchema ( BaseModel ) pydantic-model \u00b6 Describes properties of a single column of the 'table' data type. Source code in core/metadata_models.py class ColumnSchema ( BaseModel ): \"\"\"Describes properties of a single column of the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"column\" type_name : str = Field ( description = \"The type name of the column (backend-specific).\" ) metadata : typing . Dict [ str , typing . Any ] = Field ( description = \"Other metadata for the column.\" , default_factory = dict ) metadata : Dict [ str , Any ] pydantic-field \u00b6 Other metadata for the column. type_name : str pydantic-field required \u00b6 The type name of the column (backend-specific). FolderImportConfig ( BaseModel ) pydantic-model \u00b6 Source code in core/metadata_models.py class FolderImportConfig ( BaseModel ): include_files : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, include all files where the filename ends with that string.\" , default = None , ) exclude_dirs : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, exclude all folders whose name ends with that string.\" , default = None , ) exclude_files : typing . Optional [ typing . List [ str ]] = Field ( description = f \"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } .\" , default = DEFAULT_EXCLUDE_FILES , ) exclude_dirs : List [ str ] pydantic-field \u00b6 A list of strings, exclude all folders whose name ends with that string. exclude_files : List [ str ] pydantic-field \u00b6 A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: ['.DS_Store']. include_files : List [ str ] pydantic-field \u00b6 A list of strings, include all files where the filename ends with that string. KiaraDatabase ( MetadataModel ) pydantic-model \u00b6 Source code in core/metadata_models.py class KiaraDatabase ( MetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database\" @classmethod def create_in_temp_dir ( cls , init_sql : typing . Optional [ str ] = None ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path ) db . create_if_not_exists () if init_sql : db . execute_sql ( sql_script = init_sql , invalidate = True ) return db db_file_path : str = Field ( description = \"The path to the sqlite database file.\" ) _cached_engine = PrivateAttr ( default = None ) _cached_inspector = PrivateAttr ( default = None ) _table_names = PrivateAttr ( default = None ) _table_schemas = PrivateAttr ( default = None ) def get_id ( self ) -> str : return self . db_file_path def get_category_alias ( self ) -> str : return \"instance.metadata.database\" @validator ( \"db_file_path\" , allow_reuse = True ) def ensure_absolute_path ( cls , path : str ): path = os . path . abspath ( path ) if not os . path . exists ( os . path . dirname ( path )): raise ValueError ( f \"Parent folder for database file does not exist: { path } \" ) return path @property def db_url ( self ) -> str : return f \"sqlite:/// { self . db_file_path } \" def get_sqlalchemy_engine ( self ) -> \"Engine\" : if self . _cached_engine is not None : return self . _cached_engine from sqlalchemy import create_engine self . _cached_engine = create_engine ( self . db_url , future = True ) # with self._cached_engine.connect() as con: # con.execute(text(\"PRAGMA query_only = ON\")) return self . _cached_engine def create_if_not_exists ( self ): from sqlalchemy_utils import create_database , database_exists if not database_exists ( self . db_url ): create_database ( self . db_url ) def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None def copy_database_file ( self , target : str ): os . makedirs ( os . path . dirname ( target )) shutil . copy2 ( self . db_file_path , target ) new_db = KiaraDatabase ( db_file_path = target ) return new_db def get_sqlalchemy_inspector ( self ) -> \"Inspector\" : if self . _cached_inspector is not None : return self . _cached_inspector self . _cached_inspector = inspect ( self . get_sqlalchemy_engine ()) return self . _cached_inspector @property def table_names ( self ) -> typing . Iterable [ str ]: if self . _table_names is not None : return self . _table_names self . _table_names = self . get_sqlalchemy_inspector () . get_table_names () return self . _table_names def get_schema_for_table ( self , table_name : str ): if self . _table_schemas is not None : if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ] ts : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} inspector = self . get_sqlalchemy_inspector () for tn in inspector . get_table_names (): columns = self . get_sqlalchemy_inspector () . get_columns ( tn ) ts [ tn ] = {} for c in columns : ts [ tn ][ c [ \"name\" ]] = c self . _table_schemas = ts if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ] db_file_path : str pydantic-field required \u00b6 The path to the sqlite database file. execute_sql ( self , sql_script , invalidate = False ) \u00b6 Execute an sql script. Parameters: Name Type Description Default sql_script str the sql script required invalidate bool whether to invalidate cached values within this object False Source code in core/metadata_models.py def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None KiaraDatabaseInfo ( HashedMetadataModel ) pydantic-model \u00b6 Source code in core/metadata_models.py class KiaraDatabaseInfo ( HashedMetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database_info\" table_names : typing . List [ str ] = Field ( description = \"The names of all tables in this database.\" ) view_names : typing . List [ str ] = Field ( description = \"The names of all views in this database.\" ) tables : typing . Dict [ str , TableMetadata ] = Field ( description = \"Information about the tables within this database.\" ) size : int = Field ( description = \"The size of the database file.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"table_names\" : self . table_names , \"view_names\" : self . view_names , \"tables\" : self . tables , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.database_info\" size : int pydantic-field required \u00b6 The size of the database file. table_names : List [ str ] pydantic-field required \u00b6 The names of all tables in this database. tables : Dict [ str , kiara_modules . core . metadata_models . TableMetadata ] pydantic-field required \u00b6 Information about the tables within this database. view_names : List [ str ] pydantic-field required \u00b6 The names of all views in this database. KiaraFile ( MetadataModel ) pydantic-model \u00b6 Describes properties for the 'file' value type. Source code in core/metadata_models.py class KiaraFile ( MetadataModel ): \"\"\"Describes properties for the 'file' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file\" @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m _file_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_filename : str = Field ( description = \"The original filename of this file at the time of import.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this file at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) mime_type : str = Field ( description = \"The mime type of the file.\" ) file_name : str = Field ( \"The name of the file.\" ) size : int = Field ( description = \"The size of the file.\" ) path : str = Field ( description = \"The archive path of the file.\" ) is_onboarded : bool = Field ( description = \"Whether the file is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file\" def copy_file ( self , target : str , incl_orig_path : bool = False , is_onboarded : bool = False ): fm = KiaraFile . load_file ( self . path , target ) if incl_orig_path : fm . orig_path = self . orig_path else : fm . orig_path = None fm . orig_filename = self . orig_filename fm . import_time = self . import_time if self . _file_hash is not None : fm . _file_hash = self . _file_hash fm . is_onboarded = is_onboarded return fm @property def file_hash ( self ): if self . _file_hash is not None : return self . _file_hash sha256_hash = hashlib . sha3_256 () with open ( self . path , \"rb\" ) as f : # Read and update hash string value in blocks of 4K for byte_block in iter ( lambda : f . read ( 4096 ), b \"\" ): sha256_hash . update ( byte_block ) self . _file_hash = sha256_hash . hexdigest () return self . _file_hash @property def file_name_without_extension ( self ) -> str : return self . file_name . split ( \".\" )[ 0 ] @property def import_time_as_datetime ( self ) -> datetime . datetime : from dateutil import parser return parser . parse ( self . import_time ) def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\" def __str__ ( self ): return self . __repr__ () import_time : str pydantic-field required \u00b6 The time when the file was imported. is_onboarded : bool pydantic-field \u00b6 Whether the file is imported into the kiara data store. mime_type : str pydantic-field required \u00b6 The mime type of the file. orig_filename : str pydantic-field required \u00b6 The original filename of this file at the time of import. orig_path : str pydantic-field \u00b6 The original path to this file at the time of import. path : str pydantic-field required \u00b6 The archive path of the file. size : int pydantic-field required \u00b6 The size of the file. __repr__ ( self ) special \u00b6 Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\" __str__ ( self ) special \u00b6 Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ () load_file ( source , target = None , incl_orig_path = False ) classmethod \u00b6 Utility method to read metadata of a file from disk and optionally move it into a data archive location. Source code in core/metadata_models.py @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m read_content ( self , as_str = True , max_lines =- 1 ) \u00b6 Read the content of a file. Source code in core/metadata_models.py def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content KiaraFileBundle ( MetadataModel ) pydantic-model \u00b6 Describes properties for the 'file_bundle' value type. Source code in core/metadata_models.py class KiaraFileBundle ( MetadataModel ): \"\"\"Describes properties for the 'file_bundle' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file_bundle\" @classmethod def import_folder ( cls , source : str , target : typing . Optional [ str ] = None , import_config : typing . Union [ None , typing . Mapping [ str , typing . Any ], FolderImportConfig ] = None , incl_orig_path : bool = False , ): if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isdir ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) if target and os . path . exists ( target ): raise ValueError ( f \"Target path already exists: { target } \" ) if source . endswith ( os . path . sep ): source = source [ 0 : - 1 ] if target and target . endswith ( os . path . sep ): target = target [ 0 : - 1 ] if import_config is None : _import_config = FolderImportConfig () elif isinstance ( import_config , typing . Mapping ): _import_config = FolderImportConfig ( ** import_config ) elif isinstance ( import_config , FolderImportConfig ): _import_config = import_config else : raise TypeError ( f \"Invalid type for folder import config: { type ( import_config ) } .\" ) included_files : typing . Dict [ str , KiaraFile ] = {} exclude_dirs = _import_config . exclude_dirs invalid_extensions = _import_config . exclude_files valid_extensions = _import_config . include_files sum_size = 0 def include_file ( filename : str ) -> bool : if invalid_extensions and any ( filename . endswith ( ext ) for ext in invalid_extensions ): return False if not valid_extensions : return True else : return any ( filename . endswith ( ext ) for ext in valid_extensions ) for root , dirnames , filenames in os . walk ( source , topdown = True ): if exclude_dirs : dirnames [:] = [ d for d in dirnames if d not in exclude_dirs ] for filename in [ f for f in filenames if os . path . isfile ( os . path . join ( root , f )) and include_file ( f ) ]: full_path = os . path . join ( root , filename ) rel_path = os . path . relpath ( full_path , source ) if target : target_path : typing . Optional [ str ] = os . path . join ( target , rel_path ) else : target_path = None file_model = KiaraFile . load_file ( full_path , target_path , incl_orig_path = incl_orig_path ) sum_size = sum_size + file_model . size included_files [ rel_path ] = file_model orig_bundle_name = os . path . basename ( source ) if incl_orig_path : orig_path : typing . Optional [ str ] = source else : orig_path = None if target : path = target else : path = source return KiaraFileBundle . create_from_file_models ( files = included_files , orig_bundle_name = orig_bundle_name , orig_path = orig_path , path = path , sum_size = sum_size , ) @classmethod def create_from_file_models ( self , files : typing . Mapping [ str , KiaraFile ], orig_bundle_name : str , orig_path : typing . Optional [ str ], path : str , sum_size : typing . Optional [ int ] = None , is_onboarded : bool = False , ): result : typing . Dict [ str , typing . Any ] = {} result [ \"included_files\" ] = files result [ \"orig_path\" ] = orig_path result [ \"path\" ] = path result [ \"import_time\" ] = datetime . datetime . now () . isoformat () result [ \"number_of_files\" ] = len ( files ) result [ \"bundle_name\" ] = os . path . basename ( result [ \"path\" ]) result [ \"orig_bundle_name\" ] = orig_bundle_name result [ \"is_onboarded\" ] = is_onboarded if sum_size is None : sum_size = 0 for f in files . values (): sum_size = sum_size + f . size result [ \"size\" ] = sum_size return KiaraFileBundle ( ** result ) _file_bundle_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_bundle_name : str = Field ( description = \"The original name of this folder at the time of import.\" ) bundle_name : str = Field ( description = \"The name of this bundle.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this folder at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) number_of_files : int = Field ( description = \"How many files are included in this bundle.\" ) included_files : typing . Dict [ str , KiaraFile ] = Field ( description = \"A map of all the included files, incl. their properties. Uses the relative path of each file as key.\" ) size : int = Field ( description = \"The size of all files in this folder, combined.\" ) path : str = Field ( description = \"The archive path of the folder.\" ) is_onboarded : bool = Field ( description = \"Whether this bundle is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file_bundle\" def get_relative_path ( self , file : KiaraFile ): return os . path . relpath ( file . path , self . path ) def read_text_file_contents ( self , ignore_errors : bool = False ) -> typing . Mapping [ str , str ]: content_dict : typing . Dict [ str , str ] = {} def read_file ( rel_path : str , fm : KiaraFile ): with open ( fm . path , encoding = \"utf-8\" ) as f : try : content = f . read () content_dict [ rel_path ] = content # type: ignore except Exception as e : if ignore_errors : log_message ( f \"Can't read file: { e } \" ) log . warning ( f \"Ignoring file: { fm . path } \" ) else : raise Exception ( f \"Can't read file (as text) ' { fm . path } : { e } \" ) # TODO: common ignore files and folders for f in self . included_files . values (): rel_path = self . get_relative_path ( f ) read_file ( rel_path = rel_path , fm = f ) return content_dict @property def file_bundle_hash ( self ): if self . _file_bundle_hash is not None : return self . _file_bundle_hash # hash_format =\"sha3-256\" hashes = \"\" for path in sorted ( self . included_files . keys ()): fm = self . included_files [ path ] hashes = hashes + \"_\" + path + \"_\" + fm . file_hash self . _file_bundle_hash = hashlib . sha3_256 ( hashes . encode ( \"utf-8\" )) . hexdigest () return self . _file_bundle_hash def copy_bundle ( self , target_path : str , incl_orig_path : bool = False , is_onboarded : bool = False ) -> \"KiaraFileBundle\" : if target_path == self . path : raise Exception ( f \"Target path and current path are the same: { target_path } \" ) result = {} for rel_path , item in self . included_files . items (): _target_path = os . path . join ( target_path , rel_path ) new_fm = item . copy_file ( _target_path , is_onboarded = is_onboarded ) result [ rel_path ] = new_fm if incl_orig_path : orig_path = self . orig_path else : orig_path = None fb = KiaraFileBundle . create_from_file_models ( result , orig_bundle_name = self . orig_bundle_name , orig_path = orig_path , path = target_path , sum_size = self . size , is_onboarded = is_onboarded , ) if self . _file_bundle_hash is not None : fb . _file_bundle_hash = self . _file_bundle_hash return fb def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\" def __str__ ( self ): return self . __repr__ () bundle_name : str pydantic-field required \u00b6 The name of this bundle. import_time : str pydantic-field required \u00b6 The time when the file was imported. included_files : Dict [ str , kiara_modules . core . metadata_models . KiaraFile ] pydantic-field required \u00b6 A map of all the included files, incl. their properties. Uses the relative path of each file as key. is_onboarded : bool pydantic-field \u00b6 Whether this bundle is imported into the kiara data store. number_of_files : int pydantic-field required \u00b6 How many files are included in this bundle. orig_bundle_name : str pydantic-field required \u00b6 The original name of this folder at the time of import. orig_path : str pydantic-field \u00b6 The original path to this folder at the time of import. path : str pydantic-field required \u00b6 The archive path of the folder. size : int pydantic-field required \u00b6 The size of all files in this folder, combined. __repr__ ( self ) special \u00b6 Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\" __str__ ( self ) special \u00b6 Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ () TableMetadata ( HashedMetadataModel ) pydantic-model \u00b6 Describes properties for the 'table' data type. Source code in core/metadata_models.py class TableMetadata ( HashedMetadataModel ): \"\"\"Describes properties for the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"table\" column_names : typing . List [ str ] = Field ( description = \"The name of the columns of the table.\" ) column_schema : typing . Dict [ str , ColumnSchema ] = Field ( description = \"The schema description of the table.\" ) rows : int = Field ( description = \"The number of rows the table contains.\" ) size : typing . Optional [ int ] = Field ( description = \"The tables size in bytes.\" , default = None ) def _obj_to_hash ( self ) -> typing . Any : return { \"column_names\" : self . column_names , \"column_schemas\" : { k : v . dict () for k , v in self . column_schema . items ()}, \"rows\" : self . rows , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.table\" column_names : List [ str ] pydantic-field required \u00b6 The name of the columns of the table. column_schema : Dict [ str , kiara_modules . core . metadata_models . ColumnSchema ] pydantic-field required \u00b6 The schema description of the table. rows : int pydantic-field required \u00b6 The number of rows the table contains. size : int pydantic-field \u00b6 The tables size in bytes.","title":"metadata_models"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.ArrayMetadata","text":"Describes properties fo the 'array' type. Source code in core/metadata_models.py class ArrayMetadata ( HashedMetadataModel ): \"\"\"Describes properties fo the 'array' type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"array\" length : int = Field ( description = \"The number of elements the array contains.\" ) size : int = Field ( description = \"Total number of bytes consumed by the elements of the array.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"length\" : self . length , \"size\" : self . size } def get_category_alias ( self ) -> str : return \"instance.metadata.array\"","title":"ArrayMetadata"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.ArrayMetadata.length","text":"The number of elements the array contains.","title":"length"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.ArrayMetadata.size","text":"Total number of bytes consumed by the elements of the array.","title":"size"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.ColumnSchema","text":"Describes properties of a single column of the 'table' data type. Source code in core/metadata_models.py class ColumnSchema ( BaseModel ): \"\"\"Describes properties of a single column of the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"column\" type_name : str = Field ( description = \"The type name of the column (backend-specific).\" ) metadata : typing . Dict [ str , typing . Any ] = Field ( description = \"Other metadata for the column.\" , default_factory = dict )","title":"ColumnSchema"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.ColumnSchema.metadata","text":"Other metadata for the column.","title":"metadata"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.ColumnSchema.type_name","text":"The type name of the column (backend-specific).","title":"type_name"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.FolderImportConfig","text":"Source code in core/metadata_models.py class FolderImportConfig ( BaseModel ): include_files : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, include all files where the filename ends with that string.\" , default = None , ) exclude_dirs : typing . Optional [ typing . List [ str ]] = Field ( description = \"A list of strings, exclude all folders whose name ends with that string.\" , default = None , ) exclude_files : typing . Optional [ typing . List [ str ]] = Field ( description = f \"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: { DEFAULT_EXCLUDE_FILES } .\" , default = DEFAULT_EXCLUDE_FILES , )","title":"FolderImportConfig"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.FolderImportConfig.exclude_dirs","text":"A list of strings, exclude all folders whose name ends with that string.","title":"exclude_dirs"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.FolderImportConfig.exclude_files","text":"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: ['.DS_Store'].","title":"exclude_files"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.FolderImportConfig.include_files","text":"A list of strings, include all files where the filename ends with that string.","title":"include_files"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabase","text":"Source code in core/metadata_models.py class KiaraDatabase ( MetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database\" @classmethod def create_in_temp_dir ( cls , init_sql : typing . Optional [ str ] = None ): temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = cls ( db_file_path = db_path ) db . create_if_not_exists () if init_sql : db . execute_sql ( sql_script = init_sql , invalidate = True ) return db db_file_path : str = Field ( description = \"The path to the sqlite database file.\" ) _cached_engine = PrivateAttr ( default = None ) _cached_inspector = PrivateAttr ( default = None ) _table_names = PrivateAttr ( default = None ) _table_schemas = PrivateAttr ( default = None ) def get_id ( self ) -> str : return self . db_file_path def get_category_alias ( self ) -> str : return \"instance.metadata.database\" @validator ( \"db_file_path\" , allow_reuse = True ) def ensure_absolute_path ( cls , path : str ): path = os . path . abspath ( path ) if not os . path . exists ( os . path . dirname ( path )): raise ValueError ( f \"Parent folder for database file does not exist: { path } \" ) return path @property def db_url ( self ) -> str : return f \"sqlite:/// { self . db_file_path } \" def get_sqlalchemy_engine ( self ) -> \"Engine\" : if self . _cached_engine is not None : return self . _cached_engine from sqlalchemy import create_engine self . _cached_engine = create_engine ( self . db_url , future = True ) # with self._cached_engine.connect() as con: # con.execute(text(\"PRAGMA query_only = ON\")) return self . _cached_engine def create_if_not_exists ( self ): from sqlalchemy_utils import create_database , database_exists if not database_exists ( self . db_url ): create_database ( self . db_url ) def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None def copy_database_file ( self , target : str ): os . makedirs ( os . path . dirname ( target )) shutil . copy2 ( self . db_file_path , target ) new_db = KiaraDatabase ( db_file_path = target ) return new_db def get_sqlalchemy_inspector ( self ) -> \"Inspector\" : if self . _cached_inspector is not None : return self . _cached_inspector self . _cached_inspector = inspect ( self . get_sqlalchemy_engine ()) return self . _cached_inspector @property def table_names ( self ) -> typing . Iterable [ str ]: if self . _table_names is not None : return self . _table_names self . _table_names = self . get_sqlalchemy_inspector () . get_table_names () return self . _table_names def get_schema_for_table ( self , table_name : str ): if self . _table_schemas is not None : if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ] ts : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} inspector = self . get_sqlalchemy_inspector () for tn in inspector . get_table_names (): columns = self . get_sqlalchemy_inspector () . get_columns ( tn ) ts [ tn ] = {} for c in columns : ts [ tn ][ c [ \"name\" ]] = c self . _table_schemas = ts if table_name not in self . _table_schemas . keys (): raise Exception ( f \"Can't get table schema, database does not contain table with name ' { table_name } '.\" ) return self . _table_schemas [ table_name ]","title":"KiaraDatabase"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabase.db_file_path","text":"The path to the sqlite database file.","title":"db_file_path"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabase.execute_sql","text":"Execute an sql script. Parameters: Name Type Description Default sql_script str the sql script required invalidate bool whether to invalidate cached values within this object False Source code in core/metadata_models.py def execute_sql ( self , sql_script : str , invalidate : bool = False ): \"\"\"Execute an sql script. Arguments: sql_script: the sql script invalidate: whether to invalidate cached values within this object \"\"\" self . create_if_not_exists () conn = self . get_sqlalchemy_engine () . raw_connection () cursor = conn . cursor () cursor . executescript ( sql_script ) conn . commit () conn . close () if invalidate : self . _cached_inspector = None self . _table_names = None self . _table_schemas = None","title":"execute_sql()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabaseInfo","text":"Source code in core/metadata_models.py class KiaraDatabaseInfo ( HashedMetadataModel ): _metadata_key : typing . ClassVar [ str ] = \"database_info\" table_names : typing . List [ str ] = Field ( description = \"The names of all tables in this database.\" ) view_names : typing . List [ str ] = Field ( description = \"The names of all views in this database.\" ) tables : typing . Dict [ str , TableMetadata ] = Field ( description = \"Information about the tables within this database.\" ) size : int = Field ( description = \"The size of the database file.\" ) def _obj_to_hash ( self ) -> typing . Any : return { \"table_names\" : self . table_names , \"view_names\" : self . view_names , \"tables\" : self . tables , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.database_info\"","title":"KiaraDatabaseInfo"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.size","text":"The size of the database file.","title":"size"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.table_names","text":"The names of all tables in this database.","title":"table_names"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.tables","text":"Information about the tables within this database.","title":"tables"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraDatabaseInfo.view_names","text":"The names of all views in this database.","title":"view_names"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile","text":"Describes properties for the 'file' value type. Source code in core/metadata_models.py class KiaraFile ( MetadataModel ): \"\"\"Describes properties for the 'file' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file\" @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m _file_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_filename : str = Field ( description = \"The original filename of this file at the time of import.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this file at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) mime_type : str = Field ( description = \"The mime type of the file.\" ) file_name : str = Field ( \"The name of the file.\" ) size : int = Field ( description = \"The size of the file.\" ) path : str = Field ( description = \"The archive path of the file.\" ) is_onboarded : bool = Field ( description = \"Whether the file is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file\" def copy_file ( self , target : str , incl_orig_path : bool = False , is_onboarded : bool = False ): fm = KiaraFile . load_file ( self . path , target ) if incl_orig_path : fm . orig_path = self . orig_path else : fm . orig_path = None fm . orig_filename = self . orig_filename fm . import_time = self . import_time if self . _file_hash is not None : fm . _file_hash = self . _file_hash fm . is_onboarded = is_onboarded return fm @property def file_hash ( self ): if self . _file_hash is not None : return self . _file_hash sha256_hash = hashlib . sha3_256 () with open ( self . path , \"rb\" ) as f : # Read and update hash string value in blocks of 4K for byte_block in iter ( lambda : f . read ( 4096 ), b \"\" ): sha256_hash . update ( byte_block ) self . _file_hash = sha256_hash . hexdigest () return self . _file_hash @property def file_name_without_extension ( self ) -> str : return self . file_name . split ( \".\" )[ 0 ] @property def import_time_as_datetime ( self ) -> datetime . datetime : from dateutil import parser return parser . parse ( self . import_time ) def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\" def __str__ ( self ): return self . __repr__ ()","title":"KiaraFile"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.import_time","text":"The time when the file was imported.","title":"import_time"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.is_onboarded","text":"Whether the file is imported into the kiara data store.","title":"is_onboarded"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.mime_type","text":"The mime type of the file.","title":"mime_type"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.orig_filename","text":"The original filename of this file at the time of import.","title":"orig_filename"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.orig_path","text":"The original path to this file at the time of import.","title":"orig_path"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.path","text":"The archive path of the file.","title":"path"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.size","text":"The size of the file.","title":"size"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.__repr__","text":"Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileMetadata(name= { self . file_name } )\"","title":"__repr__()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.__str__","text":"Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ ()","title":"__str__()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.load_file","text":"Utility method to read metadata of a file from disk and optionally move it into a data archive location. Source code in core/metadata_models.py @classmethod def load_file ( cls , source : str , target : typing . Optional [ str ] = None , incl_orig_path : bool = False , ): \"\"\"Utility method to read metadata of a file from disk and optionally move it into a data archive location.\"\"\" import mimetypes import filetype if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isfile ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) orig_filename = os . path . basename ( source ) orig_path : str = os . path . abspath ( source ) file_import_time = datetime . datetime . now () . isoformat () # TODO: timezone file_stats = os . stat ( orig_path ) size = file_stats . st_size if target : if os . path . exists ( target ): raise ValueError ( f \"Target path exists: { target } \" ) os . makedirs ( os . path . dirname ( target ), exist_ok = True ) shutil . copy2 ( source , target ) else : target = orig_path r = mimetypes . guess_type ( target ) if r [ 0 ] is not None : mime_type = r [ 0 ] else : _mime_type = filetype . guess ( target ) if not _mime_type : mime_type = \"application/octet-stream\" else : mime_type = _mime_type . MIME if not incl_orig_path : _orig_path : typing . Optional [ str ] = None else : _orig_path = orig_path m = KiaraFile ( orig_filename = orig_filename , orig_path = _orig_path , import_time = file_import_time , mime_type = mime_type , size = size , file_name = orig_filename , path = target , ) return m","title":"load_file()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFile.read_content","text":"Read the content of a file. Source code in core/metadata_models.py def read_content ( self , as_str : bool = True , max_lines : int = - 1 ) -> typing . Union [ str , bytes ]: \"\"\"Read the content of a file.\"\"\" mode = \"r\" if as_str else \"rb\" with open ( self . path , mode ) as f : if max_lines <= 0 : content = f . read () else : content = \"\" . join (( next ( f ) for x in range ( max_lines ))) return content","title":"read_content()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle","text":"Describes properties for the 'file_bundle' value type. Source code in core/metadata_models.py class KiaraFileBundle ( MetadataModel ): \"\"\"Describes properties for the 'file_bundle' value type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"file_bundle\" @classmethod def import_folder ( cls , source : str , target : typing . Optional [ str ] = None , import_config : typing . Union [ None , typing . Mapping [ str , typing . Any ], FolderImportConfig ] = None , incl_orig_path : bool = False , ): if not source : raise ValueError ( \"No source path provided.\" ) if not os . path . exists ( os . path . realpath ( source )): raise ValueError ( f \"Path does not exist: { source } \" ) if not os . path . isdir ( os . path . realpath ( source )): raise ValueError ( f \"Path is not a file: { source } \" ) if target and os . path . exists ( target ): raise ValueError ( f \"Target path already exists: { target } \" ) if source . endswith ( os . path . sep ): source = source [ 0 : - 1 ] if target and target . endswith ( os . path . sep ): target = target [ 0 : - 1 ] if import_config is None : _import_config = FolderImportConfig () elif isinstance ( import_config , typing . Mapping ): _import_config = FolderImportConfig ( ** import_config ) elif isinstance ( import_config , FolderImportConfig ): _import_config = import_config else : raise TypeError ( f \"Invalid type for folder import config: { type ( import_config ) } .\" ) included_files : typing . Dict [ str , KiaraFile ] = {} exclude_dirs = _import_config . exclude_dirs invalid_extensions = _import_config . exclude_files valid_extensions = _import_config . include_files sum_size = 0 def include_file ( filename : str ) -> bool : if invalid_extensions and any ( filename . endswith ( ext ) for ext in invalid_extensions ): return False if not valid_extensions : return True else : return any ( filename . endswith ( ext ) for ext in valid_extensions ) for root , dirnames , filenames in os . walk ( source , topdown = True ): if exclude_dirs : dirnames [:] = [ d for d in dirnames if d not in exclude_dirs ] for filename in [ f for f in filenames if os . path . isfile ( os . path . join ( root , f )) and include_file ( f ) ]: full_path = os . path . join ( root , filename ) rel_path = os . path . relpath ( full_path , source ) if target : target_path : typing . Optional [ str ] = os . path . join ( target , rel_path ) else : target_path = None file_model = KiaraFile . load_file ( full_path , target_path , incl_orig_path = incl_orig_path ) sum_size = sum_size + file_model . size included_files [ rel_path ] = file_model orig_bundle_name = os . path . basename ( source ) if incl_orig_path : orig_path : typing . Optional [ str ] = source else : orig_path = None if target : path = target else : path = source return KiaraFileBundle . create_from_file_models ( files = included_files , orig_bundle_name = orig_bundle_name , orig_path = orig_path , path = path , sum_size = sum_size , ) @classmethod def create_from_file_models ( self , files : typing . Mapping [ str , KiaraFile ], orig_bundle_name : str , orig_path : typing . Optional [ str ], path : str , sum_size : typing . Optional [ int ] = None , is_onboarded : bool = False , ): result : typing . Dict [ str , typing . Any ] = {} result [ \"included_files\" ] = files result [ \"orig_path\" ] = orig_path result [ \"path\" ] = path result [ \"import_time\" ] = datetime . datetime . now () . isoformat () result [ \"number_of_files\" ] = len ( files ) result [ \"bundle_name\" ] = os . path . basename ( result [ \"path\" ]) result [ \"orig_bundle_name\" ] = orig_bundle_name result [ \"is_onboarded\" ] = is_onboarded if sum_size is None : sum_size = 0 for f in files . values (): sum_size = sum_size + f . size result [ \"size\" ] = sum_size return KiaraFileBundle ( ** result ) _file_bundle_hash : typing . Optional [ str ] = PrivateAttr ( default = None ) orig_bundle_name : str = Field ( description = \"The original name of this folder at the time of import.\" ) bundle_name : str = Field ( description = \"The name of this bundle.\" ) orig_path : typing . Optional [ str ] = Field ( description = \"The original path to this folder at the time of import.\" , default = None , ) import_time : str = Field ( description = \"The time when the file was imported.\" ) number_of_files : int = Field ( description = \"How many files are included in this bundle.\" ) included_files : typing . Dict [ str , KiaraFile ] = Field ( description = \"A map of all the included files, incl. their properties. Uses the relative path of each file as key.\" ) size : int = Field ( description = \"The size of all files in this folder, combined.\" ) path : str = Field ( description = \"The archive path of the folder.\" ) is_onboarded : bool = Field ( description = \"Whether this bundle is imported into the kiara data store.\" , default = False , ) def get_id ( self ) -> str : return self . path def get_category_alias ( self ) -> str : return \"instance.metadata.file_bundle\" def get_relative_path ( self , file : KiaraFile ): return os . path . relpath ( file . path , self . path ) def read_text_file_contents ( self , ignore_errors : bool = False ) -> typing . Mapping [ str , str ]: content_dict : typing . Dict [ str , str ] = {} def read_file ( rel_path : str , fm : KiaraFile ): with open ( fm . path , encoding = \"utf-8\" ) as f : try : content = f . read () content_dict [ rel_path ] = content # type: ignore except Exception as e : if ignore_errors : log_message ( f \"Can't read file: { e } \" ) log . warning ( f \"Ignoring file: { fm . path } \" ) else : raise Exception ( f \"Can't read file (as text) ' { fm . path } : { e } \" ) # TODO: common ignore files and folders for f in self . included_files . values (): rel_path = self . get_relative_path ( f ) read_file ( rel_path = rel_path , fm = f ) return content_dict @property def file_bundle_hash ( self ): if self . _file_bundle_hash is not None : return self . _file_bundle_hash # hash_format =\"sha3-256\" hashes = \"\" for path in sorted ( self . included_files . keys ()): fm = self . included_files [ path ] hashes = hashes + \"_\" + path + \"_\" + fm . file_hash self . _file_bundle_hash = hashlib . sha3_256 ( hashes . encode ( \"utf-8\" )) . hexdigest () return self . _file_bundle_hash def copy_bundle ( self , target_path : str , incl_orig_path : bool = False , is_onboarded : bool = False ) -> \"KiaraFileBundle\" : if target_path == self . path : raise Exception ( f \"Target path and current path are the same: { target_path } \" ) result = {} for rel_path , item in self . included_files . items (): _target_path = os . path . join ( target_path , rel_path ) new_fm = item . copy_file ( _target_path , is_onboarded = is_onboarded ) result [ rel_path ] = new_fm if incl_orig_path : orig_path = self . orig_path else : orig_path = None fb = KiaraFileBundle . create_from_file_models ( result , orig_bundle_name = self . orig_bundle_name , orig_path = orig_path , path = target_path , sum_size = self . size , is_onboarded = is_onboarded , ) if self . _file_bundle_hash is not None : fb . _file_bundle_hash = self . _file_bundle_hash return fb def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\" def __str__ ( self ): return self . __repr__ ()","title":"KiaraFileBundle"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.bundle_name","text":"The name of this bundle.","title":"bundle_name"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.import_time","text":"The time when the file was imported.","title":"import_time"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.included_files","text":"A map of all the included files, incl. their properties. Uses the relative path of each file as key.","title":"included_files"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.is_onboarded","text":"Whether this bundle is imported into the kiara data store.","title":"is_onboarded"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.number_of_files","text":"How many files are included in this bundle.","title":"number_of_files"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.orig_bundle_name","text":"The original name of this folder at the time of import.","title":"orig_bundle_name"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.orig_path","text":"The original path to this folder at the time of import.","title":"orig_path"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.path","text":"The archive path of the folder.","title":"path"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.size","text":"The size of all files in this folder, combined.","title":"size"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.__repr__","text":"Return repr(self). Source code in core/metadata_models.py def __repr__ ( self ): return f \"FileBundle(name= { self . bundle_name } )\"","title":"__repr__()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.KiaraFileBundle.__str__","text":"Return str(self). Source code in core/metadata_models.py def __str__ ( self ): return self . __repr__ ()","title":"__str__()"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.TableMetadata","text":"Describes properties for the 'table' data type. Source code in core/metadata_models.py class TableMetadata ( HashedMetadataModel ): \"\"\"Describes properties for the 'table' data type.\"\"\" _metadata_key : typing . ClassVar [ str ] = \"table\" column_names : typing . List [ str ] = Field ( description = \"The name of the columns of the table.\" ) column_schema : typing . Dict [ str , ColumnSchema ] = Field ( description = \"The schema description of the table.\" ) rows : int = Field ( description = \"The number of rows the table contains.\" ) size : typing . Optional [ int ] = Field ( description = \"The tables size in bytes.\" , default = None ) def _obj_to_hash ( self ) -> typing . Any : return { \"column_names\" : self . column_names , \"column_schemas\" : { k : v . dict () for k , v in self . column_schema . items ()}, \"rows\" : self . rows , \"size\" : self . size , } def get_category_alias ( self ) -> str : return \"instance.metadata.table\"","title":"TableMetadata"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.TableMetadata.column_names","text":"The name of the columns of the table.","title":"column_names"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.TableMetadata.column_schema","text":"The schema description of the table.","title":"column_schema"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.TableMetadata.rows","text":"The number of rows the table contains.","title":"rows"},{"location":"reference/kiara_modules/core/metadata_models/#kiara_modules.core.metadata_models.TableMetadata.size","text":"The tables size in bytes.","title":"size"},{"location":"reference/kiara_modules/core/operations/","text":"","title":"operations"},{"location":"reference/kiara_modules/core/python/","text":"","title":"python"},{"location":"reference/kiara_modules/core/string/","text":"DeserializeStringModule ( KiaraModule ) \u00b6 Source code in core/string.py class DeserializeStringModule ( KiaraModule ): _module_type_name = \"deserialize\" _config_cls = DeserializeStringModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : serialization_type = self . get_config_value ( \"serialization_type\" ) if serialization_type not in [ \"json\" ]: raise KiaraProcessingException ( f \"Can't deserialize string: serialisation type ' { serialization_type } ' not supported.\" ) serialized = inputs . get_value_data ( \"serialized\" ) outputs . set_value ( \"value_item\" , serialized ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }} DeserializeStringModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/string.py class DeserializeStringModuleConfig ( ModuleTypeConfigSchema ): serialization_type : str = Field ( description = \"The serialization type that was used to serialize the value.\" ) serialization_type : str pydantic-field required \u00b6 The serialization type that was used to serialize the value. RegexModule ( KiaraModule ) \u00b6 Match a string using a regular expression. Source code in core/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"match_regex\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema RegexModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/string.py class RegexModuleConfig ( ModuleTypeConfigSchema ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , ) only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/string.py class ReplaceModuleConfig ( ModuleTypeConfigSchema ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , ) default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule ( KiaraModule ) \u00b6 Replace a string if it matches a key in a mapping dictionary. Source code in core/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} StringManipulationModule ( KiaraModule ) \u00b6 Base module to simplify creating other modules that do string manipulation. Source code in core/string.py class StringManipulationModule ( KiaraModule ): \"\"\"Base module to simplify creating other modules that do string manipulation.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_string = inputs . get_value_data ( \"text\" ) result = self . process_string ( input_string ) outputs . set_value ( \"text\" , result ) @abstractmethod def process_string ( self , text : str ) -> str : pass create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }}","title":"string"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.DeserializeStringModule","text":"Source code in core/string.py class DeserializeStringModule ( KiaraModule ): _module_type_name = \"deserialize\" _config_cls = DeserializeStringModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : serialization_type = self . get_config_value ( \"serialization_type\" ) if serialization_type not in [ \"json\" ]: raise KiaraProcessingException ( f \"Can't deserialize string: serialisation type ' { serialization_type } ' not supported.\" ) serialized = inputs . get_value_data ( \"serialized\" ) outputs . set_value ( \"value_item\" , serialized )","title":"DeserializeStringModule"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.DeserializeStringModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"serialized\" : { \"type\" : \"string\" , \"doc\" : \"The serialized form of the string.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.DeserializeStringModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : \"string\" , \"doc\" : \"The string data.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.DeserializeStringModuleConfig","text":"Source code in core/string.py class DeserializeStringModuleConfig ( ModuleTypeConfigSchema ): serialization_type : str = Field ( description = \"The serialization type that was used to serialize the value.\" )","title":"DeserializeStringModuleConfig"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.DeserializeStringModuleConfig.serialization_type","text":"The serialization type that was used to serialize the value.","title":"serialization_type"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.RegexModule","text":"Match a string using a regular expression. Source code in core/string.py class RegexModule ( KiaraModule ): \"\"\"Match a string using a regular expression.\"\"\" _config_cls = RegexModuleConfig _module_type_name = \"match_regex\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"RegexModule"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.RegexModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.RegexModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.RegexModuleConfig","text":"Source code in core/string.py class RegexModuleConfig ( ModuleTypeConfigSchema ): regex : str = Field ( description = \"The regex to apply.\" ) only_first_match : bool = Field ( description = \"Whether to only return the first match, or all matches.\" , default = False , )","title":"RegexModuleConfig"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.RegexModuleConfig.only_first_match","text":"Whether to only return the first match, or all matches.","title":"only_first_match"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.RegexModuleConfig.regex","text":"The regex to apply.","title":"regex"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.ReplaceModuleConfig","text":"Source code in core/string.py class ReplaceModuleConfig ( ModuleTypeConfigSchema ): replacement_map : typing . Dict [ str , str ] = Field ( description = \"A map, containing the strings to be replaced as keys, and the replacements as values.\" ) default_value : typing . Optional [ str ] = Field ( description = \"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.\" , default = None , )","title":"ReplaceModuleConfig"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.ReplaceModuleConfig.default_value","text":"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.","title":"default_value"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.ReplaceModuleConfig.replacement_map","text":"A map, containing the strings to be replaced as keys, and the replacements as values.","title":"replacement_map"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.ReplaceStringModule","text":"Replace a string if it matches a key in a mapping dictionary. Source code in core/string.py class ReplaceStringModule ( KiaraModule ): \"\"\"Replace a string if it matches a key in a mapping dictionary.\"\"\" _config_cls = ReplaceModuleConfig _module_type_name = \"replace\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"ReplaceStringModule"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.ReplaceStringModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.ReplaceStringModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.StringManipulationModule","text":"Base module to simplify creating other modules that do string manipulation. Source code in core/string.py class StringManipulationModule ( KiaraModule ): \"\"\"Base module to simplify creating other modules that do string manipulation.\"\"\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_string = inputs . get_value_data ( \"text\" ) result = self . process_string ( input_string ) outputs . set_value ( \"text\" , result ) @abstractmethod def process_string ( self , text : str ) -> str : pass","title":"StringManipulationModule"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.StringManipulationModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/string/#kiara_modules.core.string.StringManipulationModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/string.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/value/","text":"DataProfilerModule ( KiaraModule ) \u00b6 Generate a data profile report for a dataset. This uses the DataProfiler Python library, check out its documentation for more details. Source code in core/value.py class DataProfilerModule ( KiaraModule ): \"\"\"Generate a data profile report for a dataset. This uses the [DataProfiler](https://capitalone.github.io/DataProfiler/docs/0.7.0/html/index.html) Python library, check out its documentation for more details. \"\"\" _module_type_name = \"data_profile\" _config_cls = DataProfilerModuleConfig @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from dataprofiler import Data , Profiler , ProfilerOptions , set_verbosity set_verbosity ( logging . WARNING ) value_type = self . get_config_value ( \"value_type\" ) profile_options = ProfilerOptions () profile_options . structured_options . data_labeler . is_enabled = False profile_options . unstructured_options . data_labeler . is_enabled = False if value_type == \"table\" : table_item : pa . Table = inputs . get_value_data ( \"item\" ) pd = table_item . to_pandas () profile = Profiler ( pd , options = profile_options ) # Calculate Statistics, Entity Recognition, etc report = profile . report () elif value_type == \"file\" : file_item : KiaraFile = inputs . get_value_data ( \"item\" ) data = Data ( file_item . path ) profile = Profiler ( data , options = profile_options ) report = profile . report () else : raise KiaraProcessingException ( f \"Data profiling of value type ' { value_type } ' not supported.\" ) outputs . set_value ( \"report\" , report ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs retrieve_module_profiles ( kiara ) classmethod \u00b6 Retrieve a collection of profiles (pre-set module configs) for this kiara module type. This is used to automatically create generally useful operations (incl. their ids). Source code in core/value.py @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles DataProfilerModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/value.py class DataProfilerModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to profile.\" ) value_type : str pydantic-field required \u00b6 The value type to profile.","title":"value"},{"location":"reference/kiara_modules/core/value/#kiara_modules.core.value.DataProfilerModule","text":"Generate a data profile report for a dataset. This uses the DataProfiler Python library, check out its documentation for more details. Source code in core/value.py class DataProfilerModule ( KiaraModule ): \"\"\"Generate a data profile report for a dataset. This uses the [DataProfiler](https://capitalone.github.io/DataProfiler/docs/0.7.0/html/index.html) Python library, check out its documentation for more details. \"\"\" _module_type_name = \"data_profile\" _config_cls = DataProfilerModuleConfig @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from dataprofiler import Data , Profiler , ProfilerOptions , set_verbosity set_verbosity ( logging . WARNING ) value_type = self . get_config_value ( \"value_type\" ) profile_options = ProfilerOptions () profile_options . structured_options . data_labeler . is_enabled = False profile_options . unstructured_options . data_labeler . is_enabled = False if value_type == \"table\" : table_item : pa . Table = inputs . get_value_data ( \"item\" ) pd = table_item . to_pandas () profile = Profiler ( pd , options = profile_options ) # Calculate Statistics, Entity Recognition, etc report = profile . report () elif value_type == \"file\" : file_item : KiaraFile = inputs . get_value_data ( \"item\" ) data = Data ( file_item . path ) profile = Profiler ( data , options = profile_options ) report = profile . report () else : raise KiaraProcessingException ( f \"Data profiling of value type ' { value_type } ' not supported.\" ) outputs . set_value ( \"report\" , report )","title":"DataProfilerModule"},{"location":"reference/kiara_modules/core/value/#kiara_modules.core.value.DataProfilerModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"item\" : { \"type\" : self . get_config_value ( \"value_type\" ), \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } to profile.\" , } } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/value/#kiara_modules.core.value.DataProfilerModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/value.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Mapping [ str , typing . Any ]] = { \"report\" : { \"type\" : \"dict\" , \"doc\" : \"Statistics/details about the dataset.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/value/#kiara_modules.core.value.DataProfilerModule.retrieve_module_profiles","text":"Retrieve a collection of profiles (pre-set module configs) for this kiara module type. This is used to automatically create generally useful operations (incl. their ids). Source code in core/value.py @classmethod def retrieve_module_profiles ( cls , kiara : \"Kiara\" ) -> typing . Mapping [ str , typing . Union [ typing . Mapping [ str , typing . Any ], Operation ]]: supported_source_types = [ \"table\" , \"file\" ] doc = cls . get_type_metadata () . documentation all_profiles = {} for sup_type in supported_source_types : op_config = { \"module_type\" : cls . _module_type_id , # type: ignore \"module_config\" : { \"value_type\" : sup_type }, \"doc\" : doc , } all_profiles [ f \"profile. { sup_type } .data\" ] = op_config return all_profiles","title":"retrieve_module_profiles()"},{"location":"reference/kiara_modules/core/value/#kiara_modules.core.value.DataProfilerModuleConfig","text":"Source code in core/value.py class DataProfilerModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to profile.\" )","title":"DataProfilerModuleConfig"},{"location":"reference/kiara_modules/core/value/#kiara_modules.core.value.DataProfilerModuleConfig.value_type","text":"The value type to profile.","title":"value_type"},{"location":"reference/kiara_modules/core/value_types/","text":"This module contains the value type classes that are used in the kiara_modules.core package. ArrayType ( AnyType ) \u00b6 An Apache arrow array. Source code in core/value_types.py class ArrayType ( AnyType ): \"\"\"An Apache arrow array.\"\"\" _value_type_name = \"array\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Array @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . ChunkedArray , pa . Table ] def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 ) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) array = value . get_value_data () import pyarrow as pa temp_table = pa . Table . from_arrays ( arrays = [ array ], names = [ \"array\" ]) atw = ArrowTabularWrap ( temp_table ) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 ) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" ) BooleanType ( AnyType ) \u00b6 A boolean. Source code in core/value_types.py class BooleanType ( AnyType ): \"A boolean.\" _value_type_name = \"boolean\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bool @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" ) BytesType ( AnyType ) \u00b6 An array of bytes. Source code in core/value_types.py class BytesType ( AnyType ): \"\"\"An array of bytes.\"\"\" _value_type_name = \"bytes\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bytes @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : bytes = value . get_value_data () return [ data . decode ()] # @classmethod # def get_operations( # cls, # ) -> typing.Mapping[str, typing.Mapping[str, typing.Mapping[str, typing.Any]]]: # # return { # \"save_value\": { # \"default\": { # \"module_type\": \"bytes.save\", # \"input_name\": \"bytes\", # } # } # } calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) DatabaseType ( ComplexModelType ) \u00b6 A database, containing one or several tables. This is backed by sqlite databases. Source code in core/value_types.py class DatabaseType ( ComplexModelType [ KiaraDatabase ]): \"\"\"A database, containing one or several tables. This is backed by sqlite databases. \"\"\" _value_type_name = \"database\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return KiaraDatabase @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraDatabase , str ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : KiaraDatabase = value . get_value_data () from sqlalchemy import inspect inspector = inspect ( db . get_sqlalchemy_engine ()) result : typing . List [ typing . Any ] = [ \"\" ] for table_name in inspector . get_table_names (): atw = SqliteTabularWrap ( db = db , table_name = table_name ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { table_name } [/i]\" ) result . append ( pretty ) return result parse_value ( self , value ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value DateType ( AnyType ) \u00b6 A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core/value_types.py class DateType ( AnyType ): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _value_type_name = \"date\" @classmethod def backing_python_type ( cls ) -> typing . Type : return datetime . datetime @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value )) def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_typpe ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value )) parse_value ( self , v ) \u00b6 Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v Any the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime ) DictType ( AnyType ) \u00b6 A dict-like object. Source code in core/value_types.py class DictType ( AnyType ): \"\"\"A dict-like object.\"\"\" _value_type_name = \"dict\" @classmethod def backing_python_type ( cls ) -> typing . Type : return dict @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" ) FileBundleType ( AnyType ) \u00b6 A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileBundleType ( AnyType ): \"\"\"A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file_bundle\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFileBundle @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFileBundle ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_no_included_files = print_config . get ( \"max_no_files\" , 40 ) data : KiaraFileBundle = value . get_value_data () pretty = data . dict ( exclude = { \"included_files\" }) files = list ( data . included_files . keys ()) if max_no_included_files >= 0 : if len ( files ) > max_no_included_files : half = int (( max_no_included_files - 1 ) / 2 ) head = files [ 0 : half ] tail = files [ - 1 * half :] # noqa files = ( head + [ \"..... output skipped .....\" , \"..... output skipped .....\" ] + tail ) pretty [ \"included_files\" ] = files return [ json . dumps ( pretty , indent = 2 )] # return [data.json(indent=2)] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash FileType ( AnyType ) \u00b6 A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileType ( AnyType ): \"\"\"A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFile @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFile ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : KiaraFile = value . get_value_data () max_lines = print_config . get ( \"max_lines\" , 34 ) try : lines = [] with open ( data . path , \"r\" ) as f : for idx , l in enumerate ( f ): if idx > max_lines : lines . append ( \"... \\n \" ) lines . append ( \"...\" ) break lines . append ( l ) # TODO: syntax highlighting return [ \"\" . join ( lines )] except UnicodeDecodeError : # found non-text data return [ \"Binary file or non-utf8 enconding, not printing content...\" , \"\" , \"[b]File metadata:[/b]\" , \"\" , data . json ( indent = 2 ), ] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash FloatType ( AnyType ) \u00b6 A float. Source code in core/value_types.py class FloatType ( AnyType ): \"A float.\" _value_type_name = \"float\" @classmethod def backing_python_type ( cls ) -> typing . Type : return float @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) IntegerType ( AnyType ) \u00b6 An integer. Source code in core/value_types.py class IntegerType ( AnyType ): \"\"\"An integer.\"\"\" _value_type_name = \"integer\" @classmethod def backing_python_type ( cls ) -> typing . Type : return int @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" ) ListType ( AnyType ) \u00b6 A list-like object. Source code in core/value_types.py class ListType ( AnyType ): \"\"\"A list-like object.\"\"\" _value_type_name = \"list\" @classmethod def backing_python_type ( cls ) -> typing . Type : return list @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable ) RenderablesType ( ValueType ) \u00b6 A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. Source code in core/value_types.py class RenderablesType ( ValueType [ object , ValueTypeConfigSchema ]): \"\"\"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. \"\"\" _value_type_name = \"renderables\" @classmethod def backing_python_type ( cls ) -> typing . Type : return object @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , ConsoleRenderable , RichCast ] @classmethod def type_config_cls ( cls ) -> typing . Type [ ValueTypeConfigSchema ]: return ValueTypeConfigSchema StringType ( AnyType ) \u00b6 A string. Source code in core/value_types.py class StringType ( AnyType ): \"\"\"A string.\"\"\" _value_type_name = \"string\" @classmethod def backing_python_type ( cls ) -> typing . Type : return str @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ data ] calculate_value_hash ( value , hash_type ) classmethod \u00b6 Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" ) TableType ( AnyType ) \u00b6 A table. Internally, this is backed by the Apache Arrow Table class. Source code in core/value_types.py class TableType ( AnyType ): \"\"\"A table. Internally, this is backed by the [Apache Arrow](https://arrow.apache.org) [``Table``](https://arrow.apache.org/docs/python/generated/pyarrow.Table.html) class. \"\"\" _value_type_name = \"table\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Table @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . Table ] @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None # @classmethod # def get_supported_hash_types(cls) -> typing.Iterable[str]: # # return [\"pandas_df_hash\"] # # @classmethod # def calculate_value_hash(cls, value: typing.Any, hash_type: str) -> str: # # import pyarrow as pa # # # this is only for testing, and will be replaced with a native arrow table hush function, once I figure out how to do that efficiently # table: pa.Table = value # from pandas.util import hash_pandas_object # # hash_result = hash_pandas_object(table.to_pandas()).sum() # return str(hash_result) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) atw = ArrowTabularWrap ( value . get_value_data ()) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result check_data ( data ) classmethod \u00b6 Check whether the provided input matches this value type. If it does, return a ValueType object (with the appropriate type configuration). Source code in core/value_types.py @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None validate ( cls , value ) \u00b6 Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" )","title":"value_types"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.ArrayType","text":"An Apache arrow array. Source code in core/value_types.py class ArrayType ( AnyType ): \"\"\"An Apache arrow array.\"\"\" _value_type_name = \"array\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Array @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . ChunkedArray , pa . Table ] def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 ) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) array = value . get_value_data () import pyarrow as pa temp_table = pa . Table . from_arrays ( arrays = [ array ], names = [ \"array\" ]) atw = ArrowTabularWrap ( temp_table ) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result","title":"ArrayType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.ArrayType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : import pyarrow as pa if isinstance ( value , pa . Table ): if len ( value . columns ) != 1 : raise Exception ( f \"Invalid type, only Arrow Arrays or single-column Tables allowed. This value is a table with { len ( value . columns ) } columns.\" ) return value . column ( 0 )","title":"parse_value()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.ArrayType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if isinstance ( value , pa . ChunkedArray ): return value else : raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Array . __name__ } '.\" )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.BooleanType","text":"A boolean. Source code in core/value_types.py class BooleanType ( AnyType ): \"A boolean.\" _value_type_name = \"boolean\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bool @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"BooleanType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.BooleanType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.BooleanType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): if not isinstance ( value , bool ): # if isinstance(v, str): # if v.lower() in [\"true\", \"yes\"]: # v = True # elif v.lower() in [\"false\", \"no\"]: # v = False # else: # raise ValueError(f\"Can't parse string into boolean: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for boolean: { value } \" )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.BytesType","text":"An array of bytes. Source code in core/value_types.py class BytesType ( AnyType ): \"\"\"An array of bytes.\"\"\" _value_type_name = \"bytes\" @classmethod def backing_python_type ( cls ) -> typing . Type : return bytes @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : bytes = value . get_value_data () return [ data . decode ()] # @classmethod # def get_operations( # cls, # ) -> typing.Mapping[str, typing.Mapping[str, typing.Mapping[str, typing.Any]]]: # # return { # \"save_value\": { # \"default\": { # \"module_type\": \"bytes.save\", # \"input_name\": \"bytes\", # } # } # }","title":"BytesType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.BytesType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DatabaseType","text":"A database, containing one or several tables. This is backed by sqlite databases. Source code in core/value_types.py class DatabaseType ( ComplexModelType [ KiaraDatabase ]): \"\"\"A database, containing one or several tables. This is backed by sqlite databases. \"\"\" _value_type_name = \"database\" @classmethod def backing_model_type ( self ) -> typing . Type [ KiaraDatabase ]: return KiaraDatabase @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraDatabase , str ] def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) db : KiaraDatabase = value . get_value_data () from sqlalchemy import inspect inspector = inspect ( db . get_sqlalchemy_engine ()) result : typing . List [ typing . Any ] = [ \"\" ] for table_name in inspector . get_table_names (): atw = SqliteTabularWrap ( db = db , table_name = table_name ) pretty = atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) result . append ( f \"[b]Table[/b]: [i] { table_name } [/i]\" ) result . append ( pretty ) return result","title":"DatabaseType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DatabaseType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , value : typing . Any ) -> typing . Any : if isinstance ( value , str ): # TODO: check path exists return KiaraDatabase ( db_file_path = value ) return value","title":"parse_value()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DateType","text":"A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. Source code in core/value_types.py class DateType ( AnyType ): \"\"\"A date. Internally, this will always be represented as a Python ``datetime`` object. Iff provided as input, it can also be as string, in which case the [``dateutils.parser.parse``](https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.parse) method will be used to parse the string into a datetime object. \"\"\" _value_type_name = \"date\" @classmethod def backing_python_type ( cls ) -> typing . Type : return datetime . datetime @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value )) def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"DateType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DateType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_typpe : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DateType.parse_value","text":"Parse a value into a supported python type. This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date). Parameters: Name Type Description Default v Any the value required Returns: Type Description Any 'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object Source code in core/value_types.py def parse_value ( self , v : typing . Any ) -> typing . Any : from dateutil import parser if isinstance ( v , str ): d = parser . parse ( v ) return d elif isinstance ( v , datetime . date ): _d = datetime . datetime ( year = v . year , month = v . month , day = v . day ) return _d return None","title":"parse_value()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DateType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ): assert isinstance ( value , datetime . datetime )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DictType","text":"A dict-like object. Source code in core/value_types.py class DictType ( AnyType ): \"\"\"A dict-like object.\"\"\" _value_type_name = \"dict\" @classmethod def backing_python_type ( cls ) -> typing . Type : return dict @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )]","title":"DictType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DictType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ])","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.DictType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , typing . Mapping ): raise ValueError ( f \"Invalid type ' { type ( value ) } ', not a mapping.\" )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FileBundleType","text":"A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileBundleType ( AnyType ): \"\"\"A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file_bundle\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFileBundle @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFileBundle ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_no_included_files = print_config . get ( \"max_no_files\" , 40 ) data : KiaraFileBundle = value . get_value_data () pretty = data . dict ( exclude = { \"included_files\" }) files = list ( data . included_files . keys ()) if max_no_included_files >= 0 : if len ( files ) > max_no_included_files : half = int (( max_no_included_files - 1 ) / 2 ) head = files [ 0 : half ] tail = files [ - 1 * half :] # noqa files = ( head + [ \"..... output skipped .....\" , \"..... output skipped .....\" ] + tail ) pretty [ \"included_files\" ] = files return [ json . dumps ( pretty , indent = 2 )] # return [data.json(indent=2)]","title":"FileBundleType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FileBundleType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFileBundle ) return value . file_bundle_hash","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FileType","text":"A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. Source code in core/value_types.py class FileType ( AnyType ): \"\"\"A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. \"\"\" _value_type_name = \"file\" @classmethod def backing_python_type ( cls ) -> typing . Type : return KiaraFile @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ KiaraFile ] @classmethod def get_supported_hash_types ( cls ) -> typing . Iterable [ str ]: return [ \"sha3_256\" ] @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data : KiaraFile = value . get_value_data () max_lines = print_config . get ( \"max_lines\" , 34 ) try : lines = [] with open ( data . path , \"r\" ) as f : for idx , l in enumerate ( f ): if idx > max_lines : lines . append ( \"... \\n \" ) lines . append ( \"...\" ) break lines . append ( l ) # TODO: syntax highlighting return [ \"\" . join ( lines )] except UnicodeDecodeError : # found non-text data return [ \"Binary file or non-utf8 enconding, not printing content...\" , \"\" , \"[b]File metadata:[/b]\" , \"\" , data . json ( indent = 2 ), ]","title":"FileType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FileType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : assert hash_type == \"sha3_256\" assert isinstance ( value , KiaraFile ) return value . file_hash","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FloatType","text":"A float. Source code in core/value_types.py class FloatType ( AnyType ): \"A float.\" _value_type_name = \"float\" @classmethod def backing_python_type ( cls ) -> typing . Type : return float @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"FloatType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FloatType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.FloatType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> typing . Any : if not isinstance ( value , float ): raise ValueError ( f \"Invalid type ' { type ( value ) } ' for float: { value } \" )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.IntegerType","text":"An integer. Source code in core/value_types.py class IntegerType ( AnyType ): \"\"\"An integer.\"\"\" _value_type_name = \"integer\" @classmethod def backing_python_type ( cls ) -> typing . Type : return int @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ str ( data )]","title":"IntegerType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.IntegerType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.IntegerType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , int ): # if isinstance(v, str): # try: # v = int(v) # except Exception: # raise ValueError(f\"Can't parse string into integer: {v}\") # else: raise ValueError ( f \"Invalid type ' { type ( value ) } ' for integer: { value } \" )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.ListType","text":"A list-like object. Source code in core/value_types.py class ListType ( AnyType ): \"\"\"A list-like object.\"\"\" _value_type_name = \"list\" @classmethod def backing_python_type ( cls ) -> typing . Type : return list @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ]) def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ pprint . pformat ( data )]","title":"ListType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.ListType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( self , value : typing . Any , hash_type : str ) -> str : from deepdiff import DeepHash dh = DeepHash ( value ) return str ( dh [ value ])","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.ListType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : assert isinstance ( value , typing . Iterable )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.RenderablesType","text":"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. Source code in core/value_types.py class RenderablesType ( ValueType [ object , ValueTypeConfigSchema ]): \"\"\"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. \"\"\" _value_type_name = \"renderables\" @classmethod def backing_python_type ( cls ) -> typing . Type : return object @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: return [ str , ConsoleRenderable , RichCast ] @classmethod def type_config_cls ( cls ) -> typing . Type [ ValueTypeConfigSchema ]: return ValueTypeConfigSchema","title":"RenderablesType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.StringType","text":"A string. Source code in core/value_types.py class StringType ( AnyType ): \"\"\"A string.\"\"\" _value_type_name = \"string\" @classmethod def backing_python_type ( cls ) -> typing . Type : return str @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value )) def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : data = value . get_value_data () return [ data ]","title":"StringType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.StringType.calculate_value_hash","text":"Calculate the hash of this value. If a hash can't be calculated, or the calculation of a type is not implemented (yet), this will return None. Source code in core/value_types.py @classmethod def calculate_value_hash ( cls , value : typing . Any , hash_type : str ) -> str : return str ( hash ( value ))","title":"calculate_value_hash()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.StringType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : if not isinstance ( value , str ): raise ValueError ( f \"Invalid type ' { type ( value ) } ': string required\" )","title":"validate()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.TableType","text":"A table. Internally, this is backed by the Apache Arrow Table class. Source code in core/value_types.py class TableType ( AnyType ): \"\"\"A table. Internally, this is backed by the [Apache Arrow](https://arrow.apache.org) [``Table``](https://arrow.apache.org/docs/python/generated/pyarrow.Table.html) class. \"\"\" _value_type_name = \"table\" @classmethod def backing_python_type ( cls ) -> typing . Type : import pyarrow as pa return pa . Table @classmethod def candidate_python_types ( cls ) -> typing . Optional [ typing . Iterable [ typing . Type ]]: import pyarrow as pa return [ pa . Table ] @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None # @classmethod # def get_supported_hash_types(cls) -> typing.Iterable[str]: # # return [\"pandas_df_hash\"] # # @classmethod # def calculate_value_hash(cls, value: typing.Any, hash_type: str) -> str: # # import pyarrow as pa # # # this is only for testing, and will be replaced with a native arrow table hush function, once I figure out how to do that efficiently # table: pa.Table = value # from pandas.util import hash_pandas_object # # hash_result = hash_pandas_object(table.to_pandas()).sum() # return str(hash_result) def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" ) def pretty_print_as_renderables ( self , value : \"Value\" , print_config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : max_rows = print_config . get ( \"max_no_rows\" ) max_row_height = print_config . get ( \"max_row_height\" ) max_cell_length = print_config . get ( \"max_cell_length\" ) half_lines : typing . Optional [ int ] = None if max_rows : half_lines = int ( max_rows / 2 ) atw = ArrowTabularWrap ( value . get_value_data ()) result = [ atw . pretty_print ( rows_head = half_lines , rows_tail = half_lines , max_row_height = max_row_height , max_cell_length = max_cell_length , ) ] return result","title":"TableType"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.TableType.check_data","text":"Check whether the provided input matches this value type. If it does, return a ValueType object (with the appropriate type configuration). Source code in core/value_types.py @classmethod def check_data ( cls , data : typing . Any ) -> typing . Optional [ \"ValueType\" ]: import pyarrow as pa if isinstance ( data , pa . Table ): return TableType () return None","title":"check_data()"},{"location":"reference/kiara_modules/core/value_types/#kiara_modules.core.value_types.TableType.validate","text":"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type). Source code in core/value_types.py def validate ( cls , value : typing . Any ) -> None : import pyarrow as pa if not isinstance ( value , pa . Table ): raise Exception ( f \"invalid type ' { type ( value ) . __name__ } ', must be ' { pa . Table . __name__ } '.\" )","title":"validate()"},{"location":"reference/kiara_modules/core/yaml/","text":"ToYamlModuleOld ( OldTypeConversionModule ) \u00b6 Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. Source code in core/yaml.py class ToYamlModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. \"\"\" _module_type_name = \"to_yaml\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return YAML_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"yaml\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_yaml ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"yaml"},{"location":"reference/kiara_modules/core/yaml/#kiara_modules.core.yaml.ToYamlModuleOld","text":"Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. Source code in core/yaml.py class ToYamlModuleOld ( OldTypeConversionModule ): \"\"\"Convert arbitrary types into YAML format. Early days for this module, it doesn't support a whole lot of types yet. \"\"\" _module_type_name = \"to_yaml\" @classmethod def _get_supported_source_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return YAML_SUPPORTED_SOURCE_TYPES @classmethod def _get_target_types ( self ) -> typing . Union [ typing . Iterable [ str ], str ]: return [ \"yaml\" ] def convert ( self , value : Value , config : typing . Mapping [ str , typing . Any ] ) -> typing . Any : input_value : typing . Any = value . get_value_data () input_value_str = convert_to_yaml ( self . _kiara , data = input_value , convert_config = config ) return input_value_str","title":"ToYamlModuleOld"},{"location":"reference/kiara_modules/core/array/__init__/","text":"ArrayMetadataModule ( ExtractMetadataModule ) \u00b6 Extract metadata from an 'array' value. Source code in core/array/__init__.py class ArrayMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from an 'array' value.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"array\" @classmethod def get_metadata_key ( cls ) -> str : return \"array\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return ArrayMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa array : pa . Array = value . get_value_data () return { \"length\" : len ( array ), \"size\" : array . nbytes , } MapModule ( KiaraModule ) \u00b6 Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another kiara module. This 'child' module will then be used to compute the array items of the result. Source code in core/array/__init__.py class MapModule ( KiaraModule ): \"\"\"Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another *kiara* module. This 'child' module will then be used to compute the array items of the result. \"\"\" _config_cls = MapModuleConfig def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( id = \"map_module_child\" , module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_array : pa . Array = inputs . get_value_data ( \"array\" ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"array\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list )) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs module_instance_doc ( self ) \u00b6 Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/array/__init__.py def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result MapModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/array/__init__.py class MapModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , ) input_name : str pydantic-field \u00b6 The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input. module_config : Dict [ str , Any ] pydantic-field \u00b6 The config for the kiara filter module. module_type : str pydantic-field required \u00b6 The name of the kiara module to use to filter the input data. output_name : str pydantic-field \u00b6 The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. SampleArrayModule ( SampleValueModule ) \u00b6 Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/array/__init__.py class SampleArrayModule ( SampleValueModule ): \"\"\"Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"array\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= 100 : return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( 0 , sample_size ) return result_array def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( len ( array ) - sample_size ) return result_array get_value_type () classmethod \u00b6 Return the value type for this sample module. Source code in core/array/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"array\" StoreArrayTypeModule ( StoreValueTypeModule ) \u00b6 Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with kira to re-assemble the array object from disk. Source code in core/array/__init__.py class StoreArrayTypeModule ( StoreValueTypeModule ): \"\"\"Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with *kira* to re-assemble the array object from disk. \"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"array\" def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/array/__init__.py def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config","title":"array"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.ArrayMetadataModule","text":"Extract metadata from an 'array' value. Source code in core/array/__init__.py class ArrayMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from an 'array' value.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"array\" @classmethod def get_metadata_key ( cls ) -> str : return \"array\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return ArrayMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa array : pa . Array = value . get_value_data () return { \"length\" : len ( array ), \"size\" : array . nbytes , }","title":"ArrayMetadataModule"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModule","text":"Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another kiara module. This 'child' module will then be used to compute the array items of the result. Source code in core/array/__init__.py class MapModule ( KiaraModule ): \"\"\"Map a list of values into another list of values. This module must be configured with the type (and optional) configuration of another *kiara* module. This 'child' module will then be used to compute the array items of the result. \"\"\" _config_cls = MapModuleConfig def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( id = \"map_module_child\" , module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_array : pa . Array = inputs . get_value_data ( \"array\" ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"array\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list ))","title":"MapModule"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/array/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModule.module_instance_doc","text":"Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/array/__init__.py def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result","title":"module_instance_doc()"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModuleConfig","text":"Source code in core/array/__init__.py class MapModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , )","title":"MapModuleConfig"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModuleConfig.input_name","text":"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.","title":"input_name"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModuleConfig.module_config","text":"The config for the kiara filter module.","title":"module_config"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModuleConfig.module_type","text":"The name of the kiara module to use to filter the input data.","title":"module_type"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.MapModuleConfig.output_name","text":"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.","title":"output_name"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.SampleArrayModule","text":"Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/array/__init__.py class SampleArrayModule ( SampleValueModule ): \"\"\"Sample an array. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"array\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= 100 : return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array table = pa . Table . from_arrays ([ array ], names = [ \"column\" ]) query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table . column ( \"column\" ) def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( 0 , sample_size ) return result_array def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa array : pa . Array = value . get_value_data () if sample_size >= len ( array ): return array result_array = array . slice ( len ( array ) - sample_size ) return result_array","title":"SampleArrayModule"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.SampleArrayModule.get_value_type","text":"Return the value type for this sample module. Source code in core/array/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"array\"","title":"get_value_type()"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.StoreArrayTypeModule","text":"Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with kira to re-assemble the array object from disk. Source code in core/array/__init__.py class StoreArrayTypeModule ( StoreValueTypeModule ): \"\"\"Save an Arrow array to a file. This module wraps the input array into an Arrow Table, and saves this table as a feather file. The output of this module is a dictionary representing the configuration to be used with *kira* to re-assemble the array object from disk. \"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"array\" def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config","title":"StoreArrayTypeModule"},{"location":"reference/kiara_modules/core/array/__init__/#kiara_modules.core.array.StoreArrayTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/array/__init__.py def store_value ( self , value : Value , base_path : str ): import pyarrow as pa from pyarrow import feather array : pa . Array = value . get_value_data () # folder = inputs.get_value_data(\"folder_path\") # file_name = inputs.get_value_data(\"file_name\") # column_name = inputs.get_value_data(\"column_name\") path = os . path . join ( base_path , ARRAY_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path )) table = pa . Table . from_arrays ([ array ], names = [ ARRAY_SAVE_COLUM_NAME ]) feather . write_feather ( table , path ) load_config = { \"module_type\" : \"array.restore\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : ARRAY_SAVE_FILE_NAME , \"format\" : \"feather\" , \"column_name\" : ARRAY_SAVE_COLUM_NAME , }, \"output_name\" : \"array\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/array/utils/","text":"","title":"utils"},{"location":"reference/kiara_modules/core/bytes/__init__/","text":"LoadBytesModule ( KiaraModule ) \u00b6 Source code in core/bytes/__init__.py class LoadBytesModule ( KiaraModule ): _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) if not os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't read file, path does not exist: { path } \" ) with open ( path , \"rb\" ) as f : content = f . read () outputs . set_value ( \"bytes\" , content ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }} StoreBytesTypeModule ( StoreValueTypeModule ) \u00b6 Source code in core/bytes/__init__.py class StoreBytesTypeModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"bytes\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/bytes/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config msgpack \u00b6 DeserializeFromMsgPackModule ( KiaraModule ) \u00b6 Source code in core/bytes/msgpack.py class DeserializeFromMsgPackModule ( KiaraModule ): _module_type_name = \"to_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack msg = inputs . get_value_data ( \"bytes\" ) unpacked = msgpack . unpackb ( msg , raw = False ) value_type = unpacked [ \"value_type\" ] outputs . set_value ( \"value_type\" , value_type ) metadata = unpacked [ \"metadata\" ] outputs . set_value ( \"value_metadata\" , metadata ) new_data = unpacked [ \"data\" ] if not hasattr ( self , f \"to_ { value_type } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack deserialization: { value_type } \" ) func = getattr ( self , f \"to_ { value_type } \" ) obj = func ( data = new_data ) outputs . set_value ( \"value_data\" , obj ) def to_table ( self , data : bytes ) -> typing . Any : import pyarrow as pa reader = pa . ipc . open_stream ( data ) batches = [ b for b in reader ] new_table = pa . Table . from_batches ( batches ) return new_table def to_boolean ( self , data : bytes ): return data create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } SerializeToMsgPackModule ( KiaraModule ) \u00b6 Source code in core/bytes/msgpack.py class SerializeToMsgPackModule ( KiaraModule ): _module_type_name = \"from_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack type_name : str = self . get_config_value ( \"value_type\" ) if not hasattr ( self , f \"from_ { type_name } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack serialization: { type_name } \" ) func = getattr ( self , f \"from_ { type_name } \" ) value = inputs . get_value_obj ( \"value_item\" ) metadata = value . get_metadata ( also_return_schema = True ) msg = func ( value = value ) data = { \"value_type\" : value . type_name , \"metadata\" : metadata , \"data\" : msg } msg = msgpack . packb ( data , use_bin_type = True ) outputs . set_value ( \"bytes\" , msg ) def from_table ( self , value : Value ) -> bytes : import pyarrow as pa table_val : Value = value table : pa . Table = table_val . get_value_data () sink = pa . BufferOutputStream () writer = pa . ipc . new_stream ( sink , table . schema ) writer . write ( table ) writer . close () buf : pa . Buffer = sink . getvalue () return memoryview ( buf ) def from_boolean ( self , value : Value ) -> bytes : return value . get_value_data () create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/bytes/msgpack.py class SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to serialize/deserialize.\" ) value_type : str pydantic-field required \u00b6 The value type to serialize/deserialize.","title":"bytes"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.LoadBytesModule","text":"Source code in core/bytes/__init__.py class LoadBytesModule ( KiaraModule ): _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) if not os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't read file, path does not exist: { path } \" ) with open ( path , \"rb\" ) as f : content = f . read () outputs . set_value ( \"bytes\" , content )","title":"LoadBytesModule"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.LoadBytesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The base path to the file to read.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the file, within the base path.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.LoadBytesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The content of the file.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.StoreBytesTypeModule","text":"Source code in core/bytes/__init__.py class StoreBytesTypeModule ( StoreValueTypeModule ): _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"bytes\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config","title":"StoreBytesTypeModule"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.StoreBytesTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/bytes/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: path = os . path . join ( base_path , BYTES_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write bytes, target path already exists: { path } \" ) os . makedirs ( os . path . dirname ( path ), exist_ok = True ) bytes = value . get_value_data () with open ( path , \"wb\" ) as f : f . write ( bytes ) load_config = { \"module_type\" : \"bytes.load\" , \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : BYTES_SAVE_FILE_NAME }, \"output_name\" : \"bytes\" , } return load_config","title":"store_value()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack","text":"","title":"msgpack"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule","text":"Source code in core/bytes/msgpack.py class DeserializeFromMsgPackModule ( KiaraModule ): _module_type_name = \"to_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack msg = inputs . get_value_data ( \"bytes\" ) unpacked = msgpack . unpackb ( msg , raw = False ) value_type = unpacked [ \"value_type\" ] outputs . set_value ( \"value_type\" , value_type ) metadata = unpacked [ \"metadata\" ] outputs . set_value ( \"value_metadata\" , metadata ) new_data = unpacked [ \"data\" ] if not hasattr ( self , f \"to_ { value_type } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack deserialization: { value_type } \" ) func = getattr ( self , f \"to_ { value_type } \" ) obj = func ( data = new_data ) outputs . set_value ( \"value_data\" , obj ) def to_table ( self , data : bytes ) -> typing . Any : import pyarrow as pa reader = pa . ipc . open_stream ( data ) batches = [ b for b in reader ] new_table = pa . Table . from_batches ( batches ) return new_table def to_boolean ( self , data : bytes ): return data","title":"DeserializeFromMsgPackModule"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule","text":"Source code in core/bytes/msgpack.py class SerializeToMsgPackModule ( KiaraModule ): _module_type_name = \"from_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack type_name : str = self . get_config_value ( \"value_type\" ) if not hasattr ( self , f \"from_ { type_name } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack serialization: { type_name } \" ) func = getattr ( self , f \"from_ { type_name } \" ) value = inputs . get_value_obj ( \"value_item\" ) metadata = value . get_metadata ( also_return_schema = True ) msg = func ( value = value ) data = { \"value_type\" : value . type_name , \"metadata\" : metadata , \"data\" : msg } msg = msgpack . packb ( data , use_bin_type = True ) outputs . set_value ( \"bytes\" , msg ) def from_table ( self , value : Value ) -> bytes : import pyarrow as pa table_val : Value = value table : pa . Table = table_val . get_value_data () sink = pa . BufferOutputStream () writer = pa . ipc . new_stream ( sink , table . schema ) writer . write ( table ) writer . close () buf : pa . Buffer = sink . getvalue () return memoryview ( buf ) def from_boolean ( self , value : Value ) -> bytes : return value . get_value_data ()","title":"SerializeToMsgPackModule"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModuleConfig","text":"Source code in core/bytes/msgpack.py class SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to serialize/deserialize.\" )","title":"SerializeToMsgPackModuleConfig"},{"location":"reference/kiara_modules/core/bytes/__init__/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModuleConfig.value_type","text":"The value type to serialize/deserialize.","title":"value_type"},{"location":"reference/kiara_modules/core/bytes/msgpack/","text":"DeserializeFromMsgPackModule ( KiaraModule ) \u00b6 Source code in core/bytes/msgpack.py class DeserializeFromMsgPackModule ( KiaraModule ): _module_type_name = \"to_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack msg = inputs . get_value_data ( \"bytes\" ) unpacked = msgpack . unpackb ( msg , raw = False ) value_type = unpacked [ \"value_type\" ] outputs . set_value ( \"value_type\" , value_type ) metadata = unpacked [ \"metadata\" ] outputs . set_value ( \"value_metadata\" , metadata ) new_data = unpacked [ \"data\" ] if not hasattr ( self , f \"to_ { value_type } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack deserialization: { value_type } \" ) func = getattr ( self , f \"to_ { value_type } \" ) obj = func ( data = new_data ) outputs . set_value ( \"value_data\" , obj ) def to_table ( self , data : bytes ) -> typing . Any : import pyarrow as pa reader = pa . ipc . open_stream ( data ) batches = [ b for b in reader ] new_table = pa . Table . from_batches ( batches ) return new_table def to_boolean ( self , data : bytes ): return data create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } SerializeToMsgPackModule ( KiaraModule ) \u00b6 Source code in core/bytes/msgpack.py class SerializeToMsgPackModule ( KiaraModule ): _module_type_name = \"from_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack type_name : str = self . get_config_value ( \"value_type\" ) if not hasattr ( self , f \"from_ { type_name } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack serialization: { type_name } \" ) func = getattr ( self , f \"from_ { type_name } \" ) value = inputs . get_value_obj ( \"value_item\" ) metadata = value . get_metadata ( also_return_schema = True ) msg = func ( value = value ) data = { \"value_type\" : value . type_name , \"metadata\" : metadata , \"data\" : msg } msg = msgpack . packb ( data , use_bin_type = True ) outputs . set_value ( \"bytes\" , msg ) def from_table ( self , value : Value ) -> bytes : import pyarrow as pa table_val : Value = value table : pa . Table = table_val . get_value_data () sink = pa . BufferOutputStream () writer = pa . ipc . new_stream ( sink , table . schema ) writer . write ( table ) writer . close () buf : pa . Buffer = sink . getvalue () return memoryview ( buf ) def from_boolean ( self , value : Value ) -> bytes : return value . get_value_data () create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/bytes/msgpack.py class SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to serialize/deserialize.\" ) value_type : str pydantic-field required \u00b6 The value type to serialize/deserialize.","title":"msgpack"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule","text":"Source code in core/bytes/msgpack.py class DeserializeFromMsgPackModule ( KiaraModule ): _module_type_name = \"to_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }} def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack msg = inputs . get_value_data ( \"bytes\" ) unpacked = msgpack . unpackb ( msg , raw = False ) value_type = unpacked [ \"value_type\" ] outputs . set_value ( \"value_type\" , value_type ) metadata = unpacked [ \"metadata\" ] outputs . set_value ( \"value_metadata\" , metadata ) new_data = unpacked [ \"data\" ] if not hasattr ( self , f \"to_ { value_type } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack deserialization: { value_type } \" ) func = getattr ( self , f \"to_ { value_type } \" ) obj = func ( data = new_data ) outputs . set_value ( \"value_data\" , obj ) def to_table ( self , data : bytes ) -> typing . Any : import pyarrow as pa reader = pa . ipc . open_stream ( data ) batches = [ b for b in reader ] new_table = pa . Table . from_batches ( batches ) return new_table def to_boolean ( self , data : bytes ): return data","title":"DeserializeFromMsgPackModule"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : \"The msgpack-serialized value.\" }}","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.DeserializeFromMsgPackModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_type\" : { \"type\" : \"string\" , \"doc\" : \"The type of the value.\" }, \"value_data\" : { \"type\" : \"any\" , \"doc\" : f \"The { self . get_config_value ( 'value_type' ) } value.\" , }, \"value_metadata\" : { \"type\" : \"dict\" , \"doc\" : \"A dictionary with metadata of the serialized table. The result dict has the metadata key as key, and two sub-values under each key: 'metadata_item' (the actual metadata) and 'metadata_item_schema' (the schema for the metadata).\" , }, }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule","text":"Source code in core/bytes/msgpack.py class SerializeToMsgPackModule ( KiaraModule ): _module_type_name = \"from_value\" _config_cls = SerializeToMsgPackModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } } def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import msgpack type_name : str = self . get_config_value ( \"value_type\" ) if not hasattr ( self , f \"from_ { type_name } \" ): raise KiaraProcessingException ( f \"Value type not supported for msgpack serialization: { type_name } \" ) func = getattr ( self , f \"from_ { type_name } \" ) value = inputs . get_value_obj ( \"value_item\" ) metadata = value . get_metadata ( also_return_schema = True ) msg = func ( value = value ) data = { \"value_type\" : value . type_name , \"metadata\" : metadata , \"data\" : msg } msg = msgpack . packb ( data , use_bin_type = True ) outputs . set_value ( \"bytes\" , msg ) def from_table ( self , value : Value ) -> bytes : import pyarrow as pa table_val : Value = value table : pa . Table = table_val . get_value_data () sink = pa . BufferOutputStream () writer = pa . ipc . new_stream ( sink , table . schema ) writer . write ( table ) writer . close () buf : pa . Buffer = sink . getvalue () return memoryview ( buf ) def from_boolean ( self , value : Value ) -> bytes : return value . get_value_data ()","title":"SerializeToMsgPackModule"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"value_item\" : { \"type\" : self . config . get ( \"value_type\" ), \"doc\" : f \"A { self . get_config_value ( 'value_type' ) } value.\" , } }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/bytes/msgpack.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"bytes\" : { \"type\" : \"bytes\" , \"doc\" : f \"The msgpack-serialized { self . get_config_value ( 'value_type' ) } value.\" , } }","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModuleConfig","text":"Source code in core/bytes/msgpack.py class SerializeToMsgPackModuleConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The value type to serialize/deserialize.\" )","title":"SerializeToMsgPackModuleConfig"},{"location":"reference/kiara_modules/core/bytes/msgpack/#kiara_modules.core.bytes.msgpack.SerializeToMsgPackModuleConfig.value_type","text":"The value type to serialize/deserialize.","title":"value_type"},{"location":"reference/kiara_modules/core/database/__init__/","text":"BaseDatabaseInfoMetadataModule ( ExtractMetadataModule ) \u00b6 Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class BaseDatabaseInfoMetadataModule ( ExtractMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> BaseModel : from sqlalchemy import inspect , text database : KiaraDatabase = value . get_value_data () inspector : Inspector = inspect ( database . get_sqlalchemy_engine ()) table_names = inspector . get_table_names () view_names = inspector . get_view_names () table_infos = {} for table in table_names : columns = inspector . get_columns ( table_name = table ) columns_info = {} with database . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { table } \" )) num_rows = result . fetchone ()[ 0 ] try : result = con . execute ( text ( f 'SELECT SUM(\"pgsize\") FROM \"dbstat\" WHERE name=\" { table } \"' ) ) table_size = result . fetchone ()[ 0 ] except Exception : table_size = None for column in columns : column_name = column [ \"name\" ] cs = ColumnSchema ( type_name = column [ \"type\" ] . __visit_name__ , metadata = { \"is_primary_key\" : column [ \"primary_key\" ] == 1 , \"nullable\" : column [ \"nullable\" ], }, ) columns_info [ column_name ] = cs table_infos [ table ] = TableMetadata ( column_names = list ( columns_info . keys ()), column_schema = columns_info , rows = num_rows , size = table_size , ) file_stats = os . stat ( database . db_file_path ) size = file_stats . st_size kdi = KiaraDatabaseInfo ( table_names = table_names , view_names = view_names , tables = table_infos , size = size , ) return kdi BaseDatabaseMetadataModule ( ExtractMetadataModule ) \u00b6 Extract basic metadata from a database object. Source code in core/database/__init__.py class BaseDatabaseMetadataModule ( ExtractMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> KiaraDatabase : database : KiaraDatabase = value . get_value_data () return database ConvertToDatabaseModule ( CreateValueModule ) \u00b6 Create a database from files, file_bundles, etc. Source code in core/database/__init__.py class ConvertToDatabaseModule ( CreateValueModule ): \"\"\"Create a database from files, file_bundles, etc.\"\"\" _module_type_name = \"create\" _config_cls = DatabaseConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"database\" def from_table ( self , value : Value ): import pyarrow as pa from sqlalchemy import MetaData , Table from kiara_modules.core.table.utils import ( create_sqlite_schema_data_from_arrow_table , ) table : pa . Table = value . get_value_data () # maybe we could check the values lineage, to find the best table name? table_name = value . id . replace ( \"-\" , \"_\" ) index_columns = [] for cn in table . column_names : if cn . lower () == \"id\" : index_columns . append ( cn ) column_info : SqliteTableSchema = create_sqlite_schema_data_from_arrow_table ( table = table , index_columns = index_columns ) init_sql = create_table_init_sql ( table_name = table_name , table_schema = column_info ) db = KiaraDatabase . create_in_temp_dir ( init_sql = init_sql ) nodes_column_map : typing . Dict [ str , typing . Any ] = {} for batch in table . to_batches ( DEFAULT_DB_CHUNK_SIZE ): batch_dict = batch . to_pydict () for k , v in nodes_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] engine = db . get_sqlalchemy_engine () _metadata_obj = MetaData () sqlite_table = Table ( table_name , _metadata_obj , autoload_with = engine ) with engine . connect () as conn : with conn . begin (): conn . execute ( sqlite_table . insert (), data ) return db def from_csv_file ( self , value : Value ): f = tempfile . mkdtemp () db_path = os . path . join ( f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( f , ignore_errors = True ) atexit . register ( cleanup ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = value . get_value_data () ) return db_path def from_csv_file_bundle ( self , value : Value ): include_file_information : bool = True include_raw_content_in_file_info : bool = False temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = KiaraDatabase ( db_file_path = db_path ) db . create_if_not_exists () bundle : KiaraFileBundle = value . get_value_data () table_names : typing . List [ str ] = [] for rel_path in sorted ( bundle . included_files . keys ()): file_item = bundle . included_files [ rel_path ] table_name = find_free_id ( stem = file_item . file_name_without_extension , current_ids = table_names ) try : table_names . append ( table_name ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = file_item , table_name = table_name ) except Exception as e : if self . get_config_value ( \"ignore_errors\" ) is True or True : log_message ( f \"Ignoring file ' { rel_path } ': could not import data from file -- { e } \" ) continue raise KiaraProcessingException ( e ) if include_file_information : create_table_from_file_bundle ( file_bundle = value . get_value_data (), db_file_path = db_path , table_name = \"source_files_metadata\" , include_content = include_raw_content_in_file_info , ) return db_path def from_text_file_bundle ( self , value : Value ): return create_table_from_file_bundle ( file_bundle = value . get_value_data (), include_content = True ) DatabaseConversionModuleConfig ( CreateValueModuleConfig ) pydantic-model \u00b6 Source code in core/database/__init__.py class DatabaseConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , ) ignore_errors : bool pydantic-field \u00b6 Whether to ignore convert errors and omit the failed items. DatabaseInfoMetadataModule ( BaseDatabaseInfoMetadataModule ) \u00b6 Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class DatabaseInfoMetadataModule ( BaseDatabaseInfoMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" _module_type_name = \"info\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database_info\" DatabaseMetadataModule ( BaseDatabaseMetadataModule ) \u00b6 Extract basic metadata from a database object. Source code in core/database/__init__.py class DatabaseMetadataModule ( BaseDatabaseMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database\" LoadDatabaseConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/database/__init__.py class LoadDatabaseConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The type of the value to be stored (if database sub-type).\" , default = \"database\" , ) value_type : str pydantic-field \u00b6 The type of the value to be stored (if database sub-type). LoadDatabaseModule ( KiaraModule ) \u00b6 Source code in core/database/__init__.py class LoadDatabaseModule ( KiaraModule ): _module_type_name = \"load\" _config_cls = LoadDatabaseConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) outputs . set_value ( \"database\" , path ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs StoreDatabaseTypeModule ( StoreValueTypeModule ) \u00b6 Save an sqlite database to a file. Source code in core/database/__init__.py class StoreDatabaseTypeModule ( StoreValueTypeModule ): \"\"\"Save an sqlite database to a file.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"database\" def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db ) store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/database/__init__.py def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db ) query \u00b6 QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/database/query.py class QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) query : str pydantic-field \u00b6 The query to execute. If not specified, the user will be able to provide their own. QueryTableSQL ( KiaraModule ) \u00b6 Execute a sql query against an (Arrow) table. Source code in core/database/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryDatabaseSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pandas as pd import pyarrow as pa if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) else : _query = self . get_config_value ( \"query\" ) _database : KiaraDatabase = inputs . get_value_data ( \"database\" ) # can't re-use the default engine, because pandas does not support having the 'future' flag set to 'True' engine = create_engine ( _database . db_url ) df = pd . read_sql ( _query , con = engine ) table = pa . Table . from_pandas ( df ) outputs . set_value ( \"query_result\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} utils \u00b6 SqliteColumnAttributes ( BaseModel ) pydantic-model \u00b6 Source code in core/database/utils.py class SqliteColumnAttributes ( BaseModel ): data_type : str = Field ( description = \"The type of the data in this column.\" , default = \"ANY\" ) extra_column_info : typing . List [ str ] = Field ( description = \"Additional init information for the column.\" , default_factory = list ) create_index : bool = Field ( description = \"Whether to create an index for this column or not.\" , default = False ) create_index : bool pydantic-field \u00b6 Whether to create an index for this column or not. data_type : str pydantic-field \u00b6 The type of the data in this column. extra_column_info : List [ str ] pydantic-field \u00b6 Additional init information for the column. SqliteTableSchema ( BaseModel ) pydantic-model \u00b6 Source code in core/database/utils.py class SqliteTableSchema ( BaseModel ): columns : typing . Dict [ str , SqliteColumnAttributes ] = Field ( description = \"The table columns and their attributes.\" ) extra_schema : typing . List [ str ] = Field ( description = \"Extra schema information for this table.\" , default_factory = list ) column_map : typing . Dict [ str , str ] = Field ( description = \"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.\" , default_factory = dict , ) column_map : Dict [ str , str ] pydantic-field \u00b6 A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute. columns : Dict [ str , kiara_modules . core . database . utils . SqliteColumnAttributes ] pydantic-field required \u00b6 The table columns and their attributes. extra_schema : List [ str ] pydantic-field \u00b6 Extra schema information for this table. create_table_init_sql ( table_name , table_schema , schema_template_str = None ) \u00b6 Create an sql script to initialize a table. Parameters: Name Type Description Default column_attrs a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values required Source code in core/database/utils.py def create_table_init_sql ( table_name : str , table_schema : SqliteTableSchema , schema_template_str : typing . Optional [ str ] = None , ): \"\"\"Create an sql script to initialize a table. Arguments: column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values \"\"\" if schema_template_str is None : template_path = Path ( TEMPLATES_FOLDER ) / \"sqlite_schama.sql.j2\" schema_template_str = template_path . read_text () template = Environment ( loader = BaseLoader ()) . from_string ( schema_template_str ) edges_columns = [] edge_indexes = [] lines = [] for cn , details in table_schema . columns . items (): cn_type = details . data_type cn_extra = details . extra_column_info line = f \" { cn } { cn_type } \" if cn_extra : line = f \" { line } { ' ' . join ( cn_extra ) } \" edges_columns . append ( line ) if details . create_index : edge_indexes . append ( cn ) lines . append ( line ) lines . extend ( table_schema . extra_schema ) rendered = template . render ( table_name = table_name , column_info = lines , index_columns = edge_indexes ) return rendered","title":"database"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.BaseDatabaseInfoMetadataModule","text":"Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class BaseDatabaseInfoMetadataModule ( ExtractMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> BaseModel : from sqlalchemy import inspect , text database : KiaraDatabase = value . get_value_data () inspector : Inspector = inspect ( database . get_sqlalchemy_engine ()) table_names = inspector . get_table_names () view_names = inspector . get_view_names () table_infos = {} for table in table_names : columns = inspector . get_columns ( table_name = table ) columns_info = {} with database . get_sqlalchemy_engine () . connect () as con : result = con . execute ( text ( f \"SELECT count(*) from { table } \" )) num_rows = result . fetchone ()[ 0 ] try : result = con . execute ( text ( f 'SELECT SUM(\"pgsize\") FROM \"dbstat\" WHERE name=\" { table } \"' ) ) table_size = result . fetchone ()[ 0 ] except Exception : table_size = None for column in columns : column_name = column [ \"name\" ] cs = ColumnSchema ( type_name = column [ \"type\" ] . __visit_name__ , metadata = { \"is_primary_key\" : column [ \"primary_key\" ] == 1 , \"nullable\" : column [ \"nullable\" ], }, ) columns_info [ column_name ] = cs table_infos [ table ] = TableMetadata ( column_names = list ( columns_info . keys ()), column_schema = columns_info , rows = num_rows , size = table_size , ) file_stats = os . stat ( database . db_file_path ) size = file_stats . st_size kdi = KiaraDatabaseInfo ( table_names = table_names , view_names = view_names , tables = table_infos , size = size , ) return kdi","title":"BaseDatabaseInfoMetadataModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.BaseDatabaseMetadataModule","text":"Extract basic metadata from a database object. Source code in core/database/__init__.py class BaseDatabaseMetadataModule ( ExtractMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return KiaraDatabase def extract_metadata ( self , value : Value ) -> KiaraDatabase : database : KiaraDatabase = value . get_value_data () return database","title":"BaseDatabaseMetadataModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.ConvertToDatabaseModule","text":"Create a database from files, file_bundles, etc. Source code in core/database/__init__.py class ConvertToDatabaseModule ( CreateValueModule ): \"\"\"Create a database from files, file_bundles, etc.\"\"\" _module_type_name = \"create\" _config_cls = DatabaseConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"database\" def from_table ( self , value : Value ): import pyarrow as pa from sqlalchemy import MetaData , Table from kiara_modules.core.table.utils import ( create_sqlite_schema_data_from_arrow_table , ) table : pa . Table = value . get_value_data () # maybe we could check the values lineage, to find the best table name? table_name = value . id . replace ( \"-\" , \"_\" ) index_columns = [] for cn in table . column_names : if cn . lower () == \"id\" : index_columns . append ( cn ) column_info : SqliteTableSchema = create_sqlite_schema_data_from_arrow_table ( table = table , index_columns = index_columns ) init_sql = create_table_init_sql ( table_name = table_name , table_schema = column_info ) db = KiaraDatabase . create_in_temp_dir ( init_sql = init_sql ) nodes_column_map : typing . Dict [ str , typing . Any ] = {} for batch in table . to_batches ( DEFAULT_DB_CHUNK_SIZE ): batch_dict = batch . to_pydict () for k , v in nodes_column_map . items (): if k in batch_dict . keys (): _data = batch_dict . pop ( k ) if v in batch_dict . keys (): raise Exception ( \"Duplicate column name after mapping: {v} \" ) batch_dict [ v ] = _data data = [ dict ( zip ( batch_dict , t )) for t in zip ( * batch_dict . values ())] engine = db . get_sqlalchemy_engine () _metadata_obj = MetaData () sqlite_table = Table ( table_name , _metadata_obj , autoload_with = engine ) with engine . connect () as conn : with conn . begin (): conn . execute ( sqlite_table . insert (), data ) return db def from_csv_file ( self , value : Value ): f = tempfile . mkdtemp () db_path = os . path . join ( f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( f , ignore_errors = True ) atexit . register ( cleanup ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = value . get_value_data () ) return db_path def from_csv_file_bundle ( self , value : Value ): include_file_information : bool = True include_raw_content_in_file_info : bool = False temp_f = tempfile . mkdtemp () db_path = os . path . join ( temp_f , \"db.sqlite\" ) def cleanup (): shutil . rmtree ( db_path , ignore_errors = True ) atexit . register ( cleanup ) db = KiaraDatabase ( db_file_path = db_path ) db . create_if_not_exists () bundle : KiaraFileBundle = value . get_value_data () table_names : typing . List [ str ] = [] for rel_path in sorted ( bundle . included_files . keys ()): file_item = bundle . included_files [ rel_path ] table_name = find_free_id ( stem = file_item . file_name_without_extension , current_ids = table_names ) try : table_names . append ( table_name ) create_sqlite_table_from_file ( target_db_file = db_path , file_item = file_item , table_name = table_name ) except Exception as e : if self . get_config_value ( \"ignore_errors\" ) is True or True : log_message ( f \"Ignoring file ' { rel_path } ': could not import data from file -- { e } \" ) continue raise KiaraProcessingException ( e ) if include_file_information : create_table_from_file_bundle ( file_bundle = value . get_value_data (), db_file_path = db_path , table_name = \"source_files_metadata\" , include_content = include_raw_content_in_file_info , ) return db_path def from_text_file_bundle ( self , value : Value ): return create_table_from_file_bundle ( file_bundle = value . get_value_data (), include_content = True )","title":"ConvertToDatabaseModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.DatabaseConversionModuleConfig","text":"Source code in core/database/__init__.py class DatabaseConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , )","title":"DatabaseConversionModuleConfig"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.DatabaseConversionModuleConfig.ignore_errors","text":"Whether to ignore convert errors and omit the failed items.","title":"ignore_errors"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.DatabaseInfoMetadataModule","text":"Extract extended metadata (like tables, schemas) from a database object. Source code in core/database/__init__.py class DatabaseInfoMetadataModule ( BaseDatabaseInfoMetadataModule ): \"\"\"Extract extended metadata (like tables, schemas) from a database object.\"\"\" _module_type_name = \"info\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database_info\"","title":"DatabaseInfoMetadataModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.DatabaseMetadataModule","text":"Extract basic metadata from a database object. Source code in core/database/__init__.py class DatabaseMetadataModule ( BaseDatabaseMetadataModule ): \"\"\"Extract basic metadata from a database object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"database\" @classmethod def get_metadata_key ( cls ) -> str : return \"database\"","title":"DatabaseMetadataModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.LoadDatabaseConfig","text":"Source code in core/database/__init__.py class LoadDatabaseConfig ( ModuleTypeConfigSchema ): value_type : str = Field ( description = \"The type of the value to be stored (if database sub-type).\" , default = \"database\" , )","title":"LoadDatabaseConfig"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.LoadDatabaseConfig.value_type","text":"The type of the value to be stored (if database sub-type).","title":"value_type"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.LoadDatabaseModule","text":"Source code in core/database/__init__.py class LoadDatabaseModule ( KiaraModule ): _module_type_name = \"load\" _config_cls = LoadDatabaseConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, } def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) path = os . path . join ( base_path , rel_path ) outputs . set_value ( \"database\" , path )","title":"LoadDatabaseModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.LoadDatabaseModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the base directory where the database file is stored.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path of the database file within the base directory.\" , }, }","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.LoadDatabaseModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: value_type = self . get_config_value ( \"value_type\" ) if value_type != \"database\" : msg = f \" (as ' { value_type } ')\" else : msg = \"\" outputs : typing . Mapping [ str , typing . Any ] = { \"database\" : { \"type\" : value_type , \"doc\" : f \"The database value object { msg } .\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.StoreDatabaseTypeModule","text":"Save an sqlite database to a file. Source code in core/database/__init__.py class StoreDatabaseTypeModule ( StoreValueTypeModule ): \"\"\"Save an sqlite database to a file.\"\"\" _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"database\" def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db )","title":"StoreDatabaseTypeModule"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.StoreDatabaseTypeModule.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/database/__init__.py def store_value ( self , value : Value , base_path : str ): value_type = value . type_name # TODO: assert type inherits from database database : KiaraDatabase = value . get_value_data () path = os . path . join ( base_path , DEFAULT_DATABASE_SAVE_FILE_NAME ) if os . path . exists ( path ): raise KiaraProcessingException ( f \"Can't write file, path already exists: { path } \" ) new_db = database . copy_database_file ( path ) load_config = { \"module_type\" : \"database.load\" , \"module_config\" : { \"value_type\" : value_type }, \"inputs\" : { \"base_path\" : base_path , \"rel_path\" : DEFAULT_DATABASE_SAVE_FILE_NAME , }, \"output_name\" : \"database\" , } return ( load_config , new_db )","title":"store_value()"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.query","text":"","title":"query"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.query.QueryDatabaseSQLModuleConfig","text":"Source code in core/database/query.py class QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , )","title":"QueryDatabaseSQLModuleConfig"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.query.QueryDatabaseSQLModuleConfig.query","text":"The query to execute. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.query.QueryTableSQL","text":"Execute a sql query against an (Arrow) table. Source code in core/database/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryDatabaseSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pandas as pd import pyarrow as pa if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) else : _query = self . get_config_value ( \"query\" ) _database : KiaraDatabase = inputs . get_value_data ( \"database\" ) # can't re-use the default engine, because pandas does not support having the 'future' flag set to 'True' engine = create_engine ( _database . db_url ) df = pd . read_sql ( _query , con = engine ) table = pa . Table . from_pandas ( df ) outputs . set_value ( \"query_result\" , table )","title":"QueryTableSQL"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.query.QueryTableSQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.query.QueryTableSQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils","text":"","title":"utils"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes","text":"Source code in core/database/utils.py class SqliteColumnAttributes ( BaseModel ): data_type : str = Field ( description = \"The type of the data in this column.\" , default = \"ANY\" ) extra_column_info : typing . List [ str ] = Field ( description = \"Additional init information for the column.\" , default_factory = list ) create_index : bool = Field ( description = \"Whether to create an index for this column or not.\" , default = False )","title":"SqliteColumnAttributes"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes.create_index","text":"Whether to create an index for this column or not.","title":"create_index"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes.data_type","text":"The type of the data in this column.","title":"data_type"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteColumnAttributes.extra_column_info","text":"Additional init information for the column.","title":"extra_column_info"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteTableSchema","text":"Source code in core/database/utils.py class SqliteTableSchema ( BaseModel ): columns : typing . Dict [ str , SqliteColumnAttributes ] = Field ( description = \"The table columns and their attributes.\" ) extra_schema : typing . List [ str ] = Field ( description = \"Extra schema information for this table.\" , default_factory = list ) column_map : typing . Dict [ str , str ] = Field ( description = \"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.\" , default_factory = dict , )","title":"SqliteTableSchema"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteTableSchema.column_map","text":"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.","title":"column_map"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteTableSchema.columns","text":"The table columns and their attributes.","title":"columns"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.SqliteTableSchema.extra_schema","text":"Extra schema information for this table.","title":"extra_schema"},{"location":"reference/kiara_modules/core/database/__init__/#kiara_modules.core.database.utils.create_table_init_sql","text":"Create an sql script to initialize a table. Parameters: Name Type Description Default column_attrs a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values required Source code in core/database/utils.py def create_table_init_sql ( table_name : str , table_schema : SqliteTableSchema , schema_template_str : typing . Optional [ str ] = None , ): \"\"\"Create an sql script to initialize a table. Arguments: column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values \"\"\" if schema_template_str is None : template_path = Path ( TEMPLATES_FOLDER ) / \"sqlite_schama.sql.j2\" schema_template_str = template_path . read_text () template = Environment ( loader = BaseLoader ()) . from_string ( schema_template_str ) edges_columns = [] edge_indexes = [] lines = [] for cn , details in table_schema . columns . items (): cn_type = details . data_type cn_extra = details . extra_column_info line = f \" { cn } { cn_type } \" if cn_extra : line = f \" { line } { ' ' . join ( cn_extra ) } \" edges_columns . append ( line ) if details . create_index : edge_indexes . append ( cn ) lines . append ( line ) lines . extend ( table_schema . extra_schema ) rendered = template . render ( table_name = table_name , column_info = lines , index_columns = edge_indexes ) return rendered","title":"create_table_init_sql()"},{"location":"reference/kiara_modules/core/database/query/","text":"QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/database/query.py class QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) query : str pydantic-field \u00b6 The query to execute. If not specified, the user will be able to provide their own. QueryTableSQL ( KiaraModule ) \u00b6 Execute a sql query against an (Arrow) table. Source code in core/database/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryDatabaseSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pandas as pd import pyarrow as pa if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) else : _query = self . get_config_value ( \"query\" ) _database : KiaraDatabase = inputs . get_value_data ( \"database\" ) # can't re-use the default engine, because pandas does not support having the 'future' flag set to 'True' engine = create_engine ( _database . db_url ) df = pd . read_sql ( _query , con = engine ) table = pa . Table . from_pandas ( df ) outputs . set_value ( \"query_result\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"query"},{"location":"reference/kiara_modules/core/database/query/#kiara_modules.core.database.query.QueryDatabaseSQLModuleConfig","text":"Source code in core/database/query.py class QueryDatabaseSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , )","title":"QueryDatabaseSQLModuleConfig"},{"location":"reference/kiara_modules/core/database/query/#kiara_modules.core.database.query.QueryDatabaseSQLModuleConfig.query","text":"The query to execute. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/database/query/#kiara_modules.core.database.query.QueryTableSQL","text":"Execute a sql query against an (Arrow) table. Source code in core/database/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryDatabaseSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pandas as pd import pyarrow as pa if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) else : _query = self . get_config_value ( \"query\" ) _database : KiaraDatabase = inputs . get_value_data ( \"database\" ) # can't re-use the default engine, because pandas does not support having the 'future' flag set to 'True' engine = create_engine ( _database . db_url ) df = pd . read_sql ( _query , con = engine ) table = pa . Table . from_pandas ( df ) outputs . set_value ( \"query_result\" , table )","title":"QueryTableSQL"},{"location":"reference/kiara_modules/core/database/query/#kiara_modules.core.database.query.QueryTableSQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"database\" : { \"type\" : \"database\" , \"doc\" : \"The database to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/database/query/#kiara_modules.core.database.query.QueryTableSQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/database/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/database/utils/","text":"SqliteColumnAttributes ( BaseModel ) pydantic-model \u00b6 Source code in core/database/utils.py class SqliteColumnAttributes ( BaseModel ): data_type : str = Field ( description = \"The type of the data in this column.\" , default = \"ANY\" ) extra_column_info : typing . List [ str ] = Field ( description = \"Additional init information for the column.\" , default_factory = list ) create_index : bool = Field ( description = \"Whether to create an index for this column or not.\" , default = False ) create_index : bool pydantic-field \u00b6 Whether to create an index for this column or not. data_type : str pydantic-field \u00b6 The type of the data in this column. extra_column_info : List [ str ] pydantic-field \u00b6 Additional init information for the column. SqliteTableSchema ( BaseModel ) pydantic-model \u00b6 Source code in core/database/utils.py class SqliteTableSchema ( BaseModel ): columns : typing . Dict [ str , SqliteColumnAttributes ] = Field ( description = \"The table columns and their attributes.\" ) extra_schema : typing . List [ str ] = Field ( description = \"Extra schema information for this table.\" , default_factory = list ) column_map : typing . Dict [ str , str ] = Field ( description = \"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.\" , default_factory = dict , ) column_map : Dict [ str , str ] pydantic-field \u00b6 A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute. columns : Dict [ str , kiara_modules . core . database . utils . SqliteColumnAttributes ] pydantic-field required \u00b6 The table columns and their attributes. extra_schema : List [ str ] pydantic-field \u00b6 Extra schema information for this table. create_table_init_sql ( table_name , table_schema , schema_template_str = None ) \u00b6 Create an sql script to initialize a table. Parameters: Name Type Description Default column_attrs a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values required Source code in core/database/utils.py def create_table_init_sql ( table_name : str , table_schema : SqliteTableSchema , schema_template_str : typing . Optional [ str ] = None , ): \"\"\"Create an sql script to initialize a table. Arguments: column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values \"\"\" if schema_template_str is None : template_path = Path ( TEMPLATES_FOLDER ) / \"sqlite_schama.sql.j2\" schema_template_str = template_path . read_text () template = Environment ( loader = BaseLoader ()) . from_string ( schema_template_str ) edges_columns = [] edge_indexes = [] lines = [] for cn , details in table_schema . columns . items (): cn_type = details . data_type cn_extra = details . extra_column_info line = f \" { cn } { cn_type } \" if cn_extra : line = f \" { line } { ' ' . join ( cn_extra ) } \" edges_columns . append ( line ) if details . create_index : edge_indexes . append ( cn ) lines . append ( line ) lines . extend ( table_schema . extra_schema ) rendered = template . render ( table_name = table_name , column_info = lines , index_columns = edge_indexes ) return rendered","title":"utils"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteColumnAttributes","text":"Source code in core/database/utils.py class SqliteColumnAttributes ( BaseModel ): data_type : str = Field ( description = \"The type of the data in this column.\" , default = \"ANY\" ) extra_column_info : typing . List [ str ] = Field ( description = \"Additional init information for the column.\" , default_factory = list ) create_index : bool = Field ( description = \"Whether to create an index for this column or not.\" , default = False )","title":"SqliteColumnAttributes"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteColumnAttributes.create_index","text":"Whether to create an index for this column or not.","title":"create_index"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteColumnAttributes.data_type","text":"The type of the data in this column.","title":"data_type"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteColumnAttributes.extra_column_info","text":"Additional init information for the column.","title":"extra_column_info"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteTableSchema","text":"Source code in core/database/utils.py class SqliteTableSchema ( BaseModel ): columns : typing . Dict [ str , SqliteColumnAttributes ] = Field ( description = \"The table columns and their attributes.\" ) extra_schema : typing . List [ str ] = Field ( description = \"Extra schema information for this table.\" , default_factory = list ) column_map : typing . Dict [ str , str ] = Field ( description = \"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.\" , default_factory = dict , )","title":"SqliteTableSchema"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteTableSchema.column_map","text":"A dictionary describing how to map incoming data column names. Values in this dict point to keys in this models 'columns' attribute.","title":"column_map"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteTableSchema.columns","text":"The table columns and their attributes.","title":"columns"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.SqliteTableSchema.extra_schema","text":"Extra schema information for this table.","title":"extra_schema"},{"location":"reference/kiara_modules/core/database/utils/#kiara_modules.core.database.utils.create_table_init_sql","text":"Create an sql script to initialize a table. Parameters: Name Type Description Default column_attrs a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values required Source code in core/database/utils.py def create_table_init_sql ( table_name : str , table_schema : SqliteTableSchema , schema_template_str : typing . Optional [ str ] = None , ): \"\"\"Create an sql script to initialize a table. Arguments: column_attrs: a map with the column name as key, and column details ('type', 'extra_column_info', 'create_index') as values \"\"\" if schema_template_str is None : template_path = Path ( TEMPLATES_FOLDER ) / \"sqlite_schama.sql.j2\" schema_template_str = template_path . read_text () template = Environment ( loader = BaseLoader ()) . from_string ( schema_template_str ) edges_columns = [] edge_indexes = [] lines = [] for cn , details in table_schema . columns . items (): cn_type = details . data_type cn_extra = details . extra_column_info line = f \" { cn } { cn_type } \" if cn_extra : line = f \" { line } { ' ' . join ( cn_extra ) } \" edges_columns . append ( line ) if details . create_index : edge_indexes . append ( cn ) lines . append ( line ) lines . extend ( table_schema . extra_schema ) rendered = template . render ( table_name = table_name , column_info = lines , index_columns = edge_indexes ) return rendered","title":"create_table_init_sql()"},{"location":"reference/kiara_modules/core/pipelines/__init__/","text":"Virtual module that is used as base for PipelineModule classes that are auto-generated from pipeline descriptions under this folder.","title":"pipelines"},{"location":"reference/kiara_modules/core/table/__init__/","text":"ConvertToTableModule ( CreateValueModule ) \u00b6 Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: bytes: a memoryview of the byte-representation of the Table string: the base64-encoded byte-representation of the Table Source code in core/table/__init__.py class ConvertToTableModule ( CreateValueModule ): \"\"\"Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: - bytes: a memoryview of the byte-representation of the Table - string: the base64-encoded byte-representation of the Table \"\"\" _module_type_name = \"create\" _config_cls = TableConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"table\" # def to_bytes(self, value: Value) -> bytes: # # import pyarrow as pa # # table_val: Value = value # table: pa.Table = table_val.get_value_data() # # batches = table.to_batches() # # sink = pa.BufferOutputStream() # writer = pa.ipc.new_stream(sink, batches[0].schema) # # for batch in batches: # writer.write_batch(batch) # writer.close() # # buf: pa.Buffer = sink.getvalue() # return memoryview(buf) # # def to_string(self, value: Value): # # _bytes: bytes = self.to_bytes(value) # string = base64.b64encode(_bytes) # return string.decode() # def from_bytes(self, value: Value): # raise NotImplementedError() # # def from_string(self, value: Value): # raise NotImplementedError() def from_csv_file ( self , value : Value ): from pyarrow import csv input_file : KiaraFile = value . get_value_data () imported_data = csv . read_csv ( input_file . path ) return imported_data def from_text_file_bundle ( self , value : Value ): import pyarrow as pa bundle : KiaraFileBundle = value . get_value_data () columns = FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS ignore_errors = self . get_config_value ( \"ignore_errors\" ) file_dict = bundle . read_text_file_contents ( ignore_errors = ignore_errors ) tabular : typing . Dict [ str , typing . List [ typing . Any ]] = {} for column in columns : for index , rel_path in enumerate ( sorted ( file_dict . keys ())): if column == \"content\" : _value : typing . Any = file_dict [ rel_path ] elif column == \"id\" : _value = index elif column == \"rel_path\" : _value = rel_path else : file_model = bundle . included_files [ rel_path ] _value = getattr ( file_model , column ) tabular . setdefault ( column , []) . append ( _value ) table = pa . Table . from_pydict ( tabular ) return table CutColumnModule ( KiaraModule ) \u00b6 Cut off one column from a table, returning an array. Source code in core/table/__init__.py class CutColumnModule ( KiaraModule ): \"\"\"Cut off one column from a table, returning an array.\"\"\" _module_type_name = \"cut_column\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table_value = inputs . get_value_obj ( \"table\" ) column_name : str = inputs . get_value_data ( \"column_name\" ) available = table_value . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if column_name not in available : raise KiaraProcessingException ( f \"Invalid column name ' { column_name } '. Available column names: { available } \" ) table : pa . Table = inputs . get_value_data ( \"table\" ) column = table . column ( column_name ) outputs . set_value ( \"array\" , column ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs ExportArrowTable ( KiaraModule ) \u00b6 Export a table object to disk. Source code in core/table/__init__.py class ExportArrowTable ( KiaraModule ): \"\"\"Export a table object to disk.\"\"\" _module_type_name = \"export\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from pyarrow import feather table : pa . Table = inputs . get_value_data ( \"table\" ) full_path : str = inputs . get_value_data ( \"path\" ) force_overwrite = inputs . get_value_data ( \"force_overwrite\" ) format : str = inputs . get_value_data ( \"format\" ) compression = inputs . get_value_data ( \"compression\" ) if compression not in [ \"zstd\" , \"lz4\" , \"uncompressed\" ]: raise KiaraProcessingException ( f \"Invalid compression format ' { compression } '. Allowed: 'zstd', 'lz4', 'uncompressed'.\" ) if format != \"feather\" : raise KiaraProcessingException ( f \"Can't export table to format ' { format } ': only 'feather' supported at the moment.\" ) if os . path . exists ( full_path ) and not force_overwrite : raise KiaraProcessingException ( f \"Can't write table to file, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : format , }, \"value_id\" : NO_VALUE_ID_MARKER , \"output_name\" : \"table\" , } outputs . set_value ( \"load_config\" , result ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs LoadArrowTable ( KiaraModule ) \u00b6 Load a table object from disk. Source code in core/table/__init__.py class LoadArrowTable ( KiaraModule ): \"\"\"Load a table object from disk.\"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from pyarrow import feather base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) format = inputs . get_value_data ( \"format\" ) if format != \"feather\" : raise NotImplementedError () path = os . path . join ( base_path , rel_path ) table = feather . read_table ( path ) outputs . set_value ( \"table\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs MapColumnModule ( KiaraModule ) \u00b6 Map the items of one column of a table onto an array, using another module. Source code in core/table/__init__.py class MapColumnModule ( KiaraModule ): \"\"\"Map the items of one column of a table onto an array, using another module.\"\"\" _config_cls = MapColumnsModuleConfig _module_type_name = \"map_column\" def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table : pa . Table = inputs . get_value_data ( \"table\" ) column_name = inputs . get_value_data ( \"column_name\" ) if column_name not in table . column_names : raise KiaraProcessingException ( f \"Table column ' { column_name } ' not available in table. Available columns: { ', ' . join ( table . column_names ) } .\" ) input_array : pa . Array = table . column ( column_name ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"table\" , \"column_name\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list )) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs module_instance_doc ( self ) \u00b6 Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/table/__init__.py def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result MapColumnsModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/__init__.py class MapColumnsModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , ) input_name : str pydantic-field \u00b6 The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input. module_config : Dict [ str , Any ] pydantic-field \u00b6 The config for the kiara filter module. module_type : str pydantic-field required \u00b6 The name of the kiara module to use to filter the input data. output_name : str pydantic-field \u00b6 The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output. MergeTableModule ( KiaraModule ) \u00b6 Create a table from other tables and/or arrays. Source code in core/table/__init__.py class MergeTableModule ( KiaraModule ): \"\"\"Create a table from other tables and/or arrays.\"\"\" _module_type_name = \"merge\" _config_cls = MergeTableModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_schema : typing . Dict [ str , typing . Any ] = self . get_config_value ( \"input_schema\" ) sources = {} for field_name in input_schema . keys (): sources [ field_name ] = inputs . get_value_data ( field_name ) len_dict = {} arrays = [] column_names = [] for source_key , table_or_column in sources . items (): if isinstance ( table_or_column , pa . Table ): rows = table_or_column . num_rows for name in table_or_column . schema . names : column = table_or_column . column ( name ) arrays . append ( column ) column_names . append ( name ) elif isinstance ( table_or_column , ( pa . Array , pa . ChunkedArray )): rows = len ( table_or_column ) arrays . append ( table_or_column ) column_names . append ( source_key ) else : raise KiaraProcessingException ( f \"Can't merge table: invalid type ' { type ( table_or_column ) } ' for source ' { source_key } '.\" ) len_dict [ source_key ] = rows all_rows = None for source_key , rows in len_dict . items (): if all_rows is None : all_rows = rows else : if all_rows != rows : all_rows = None break if all_rows is None : len_str = \"\" for name , rows in len_dict . items (): len_str = f \" { name } ( { rows } )\" raise KiaraProcessingException ( f \"Can't merge table, sources have different lengths: { len_str } \" ) table = pa . Table . from_arrays ( arrays = arrays , names = column_names ) outputs . set_value ( \"table\" , table ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs MergeTableModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/__init__.py class MergeTableModuleConfig ( ModuleTypeConfigSchema ): input_schema : typing . Dict [ str , typing . Any ] = Field ( description = \"A dict describing the inputs for this merge process.\" ) input_schema : Dict [ str , Any ] pydantic-field required \u00b6 A dict describing the inputs for this merge process. SampleTableModule ( SampleValueModule ) \u00b6 Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/table/__init__.py class SampleTableModule ( SampleValueModule ): \"\"\"Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"table\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= 100 : return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( 0 , sample_size ) def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( len ( table ) - sample_size ) get_value_type () classmethod \u00b6 Return the value type for this sample module. Source code in core/table/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"table\" SaveArrowTableConfig ( StoreValueModuleConfig ) pydantic-model \u00b6 Source code in core/table/__init__.py class SaveArrowTableConfig ( StoreValueModuleConfig ): compression : str = Field ( description = \"The compression to use when saving the table.\" , default = \"zstd\" ) compression : str pydantic-field \u00b6 The compression to use when saving the table. StoreArrowTable ( StoreValueTypeModule ) \u00b6 Source code in core/table/__init__.py class StoreArrowTable ( StoreValueTypeModule ): _config_cls = SaveArrowTableConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"table\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result store_value ( self , value , base_path ) \u00b6 Save the value, and return the load config needed to load it again. Source code in core/table/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result TableConversionModuleConfig ( CreateValueModuleConfig ) pydantic-model \u00b6 Source code in core/table/__init__.py class TableConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , ) ignore_errors : bool pydantic-field \u00b6 Whether to ignore convert errors and omit the failed items. TableMetadataModule ( ExtractMetadataModule ) \u00b6 Extract metadata from a table object. Source code in core/table/__init__.py class TableMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from a table object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"table\" @classmethod def get_metadata_key ( cls ) -> str : return \"table\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return TableMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa table : pa . Table = value . get_value_data () table_schema = {} for name in table . schema . names : field = table . schema . field ( name ) md = field . metadata _type = field . type if not md : md = { \"arrow_type_id\" : _type . id , } _d = { \"type_name\" : str ( _type ), \"metadata\" : md , } table_schema [ name ] = _d return { \"column_names\" : table . column_names , \"column_schema\" : table_schema , \"rows\" : table . num_rows , \"size\" : table . nbytes , } filter \u00b6 CreateFilteredTableModule ( KiaraModule ) \u00b6 Filter a table using a mask array. Source code in core/table/filter.py class CreateFilteredTableModule ( KiaraModule ): \"\"\"Filter a table using a mask array.\"\"\" _module_type_name = \"with_mask\" _config_cls = TableFilterModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs query \u00b6 QueryTableGraphQL ( KiaraModule ) \u00b6 Execute a graphql aggregation query against an (Arrow) table. References https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } Source code in core/table/query.py class QueryTableGraphQL ( KiaraModule ): \"\"\"Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } \"\"\" _module_type_name = \"graphql\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import vaex table = inputs . get_value_data ( \"table\" ) query = inputs . get_value_data ( \"query\" ) df = vaex . from_arrow_table ( table ) result = df . graphql . execute ( query ) outputs . set_value ( \"query_result\" , result . to_dict ()[ \"data\" ]) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs QueryTableSQL ( KiaraModule ) \u00b6 Execute a sql query against an (Arrow) table. Source code in core/table/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryTableSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import duckdb if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) _relation_name : str = inputs . get_value_data ( \"relation_name\" ) else : _query = self . get_config_value ( \"query\" ) _relation_name = self . get_config_value ( \"relation_name\" ) if _relation_name . upper () in RESERVED_SQL_KEYWORDS : raise KiaraProcessingException ( f \"Invalid relation name ' { _relation_name } ': this is a reserved sql keyword, please select a different name.\" ) _table = inputs . get_value_data ( \"table\" ) rel_from_arrow = duckdb . arrow ( _table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( _relation_name , _query ) outputs . set_value ( \"query_result\" , result . fetch_arrow_table ()) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/query.py class QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) relation_name : typing . Optional [ str ] = Field ( description = \"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\" , default = \"data\" , ) query : str pydantic-field \u00b6 The query to execute. If not specified, the user will be able to provide their own. relation_name : str pydantic-field \u00b6 The name the table is referred to in the sql query. If not specified, the user will be able to provide their own. utils \u00b6 create_sqlite_schema_data_from_arrow_table ( table , column_map = None , index_columns = None , extra_column_info = None ) \u00b6 Create a sql schema statement from an Arrow table object. Parameters: Name Type Description Default table pa.Table the Arrow table object required column_map Optional[Mapping[str, str]] a map that contains column names that should be changed in the new table None index_columns Optional[Iterable[str]] a list of column names (after mapping) to create module_indexes for None extra_column_info Optional[Mapping[str, Iterable[str]]] a list of extra schema instructions per column name (after mapping) None Source code in core/table/utils.py def create_sqlite_schema_data_from_arrow_table ( table : \"pa.Table\" , column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , index_columns : typing . Optional [ typing . Iterable [ str ]] = None , extra_column_info : typing . Optional [ typing . Mapping [ str , typing . Iterable [ str ]] ] = None , ) -> SqliteTableSchema : \"\"\"Create a sql schema statement from an Arrow table object. Arguments: table: the Arrow table object column_map: a map that contains column names that should be changed in the new table index_columns: a list of column names (after mapping) to create module_indexes for extra_column_info: a list of extra schema instructions per column name (after mapping) \"\"\" columns = convert_arrow_column_types_to_sqlite ( table = table ) if column_map is None : column_map = {} if extra_column_info is None : extra_column_info = {} temp : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if index_columns is None : index_columns = [] for cn , data in columns . items (): if cn in column_map . keys (): new_key = column_map [ cn ] else : new_key = cn temp_data = dict ( data ) if new_key in extra_column_info . keys (): temp_data [ \"extra_column_info\" ] = extra_column_info [ new_key ] else : temp_data [ \"extra_column_info\" ] = [ \"\" ] if cn in index_columns : temp_data [ \"create_index\" ] = True temp [ new_key ] = temp_data columns = temp if not columns : raise Exception ( \"Resulting table schema has no columns.\" ) else : for ic in index_columns : if ic not in columns . keys (): raise Exception ( f \"Can't create schema, requested index column name not available: { ic } \" ) return SqliteTableSchema ( columns = columns , column_map = column_map )","title":"table"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.ConvertToTableModule","text":"Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: bytes: a memoryview of the byte-representation of the Table string: the base64-encoded byte-representation of the Table Source code in core/table/__init__.py class ConvertToTableModule ( CreateValueModule ): \"\"\"Create an Arrow table from files, file_bundles, etc. This module supportes two conversion targets currently: - bytes: a memoryview of the byte-representation of the Table - string: the base64-encoded byte-representation of the Table \"\"\" _module_type_name = \"create\" _config_cls = TableConversionModuleConfig @classmethod def get_target_value_type ( cls ) -> str : return \"table\" # def to_bytes(self, value: Value) -> bytes: # # import pyarrow as pa # # table_val: Value = value # table: pa.Table = table_val.get_value_data() # # batches = table.to_batches() # # sink = pa.BufferOutputStream() # writer = pa.ipc.new_stream(sink, batches[0].schema) # # for batch in batches: # writer.write_batch(batch) # writer.close() # # buf: pa.Buffer = sink.getvalue() # return memoryview(buf) # # def to_string(self, value: Value): # # _bytes: bytes = self.to_bytes(value) # string = base64.b64encode(_bytes) # return string.decode() # def from_bytes(self, value: Value): # raise NotImplementedError() # # def from_string(self, value: Value): # raise NotImplementedError() def from_csv_file ( self , value : Value ): from pyarrow import csv input_file : KiaraFile = value . get_value_data () imported_data = csv . read_csv ( input_file . path ) return imported_data def from_text_file_bundle ( self , value : Value ): import pyarrow as pa bundle : KiaraFileBundle = value . get_value_data () columns = FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS ignore_errors = self . get_config_value ( \"ignore_errors\" ) file_dict = bundle . read_text_file_contents ( ignore_errors = ignore_errors ) tabular : typing . Dict [ str , typing . List [ typing . Any ]] = {} for column in columns : for index , rel_path in enumerate ( sorted ( file_dict . keys ())): if column == \"content\" : _value : typing . Any = file_dict [ rel_path ] elif column == \"id\" : _value = index elif column == \"rel_path\" : _value = rel_path else : file_model = bundle . included_files [ rel_path ] _value = getattr ( file_model , column ) tabular . setdefault ( column , []) . append ( _value ) table = pa . Table . from_pydict ( tabular ) return table","title":"ConvertToTableModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.CutColumnModule","text":"Cut off one column from a table, returning an array. Source code in core/table/__init__.py class CutColumnModule ( KiaraModule ): \"\"\"Cut off one column from a table, returning an array.\"\"\" _module_type_name = \"cut_column\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table_value = inputs . get_value_obj ( \"table\" ) column_name : str = inputs . get_value_data ( \"column_name\" ) available = table_value . get_metadata ( \"table\" )[ \"table\" ][ \"column_names\" ] if column_name not in available : raise KiaraProcessingException ( f \"Invalid column name ' { column_name } '. Available column names: { available } \" ) table : pa . Table = inputs . get_value_data ( \"table\" ) column = table . column ( column_name ) outputs . set_value ( \"array\" , column )","title":"CutColumnModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.CutColumnModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A table.\" }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column to extract.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.CutColumnModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The column.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.ExportArrowTable","text":"Export a table object to disk. Source code in core/table/__init__.py class ExportArrowTable ( KiaraModule ): \"\"\"Export a table object to disk.\"\"\" _module_type_name = \"export\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa from pyarrow import feather table : pa . Table = inputs . get_value_data ( \"table\" ) full_path : str = inputs . get_value_data ( \"path\" ) force_overwrite = inputs . get_value_data ( \"force_overwrite\" ) format : str = inputs . get_value_data ( \"format\" ) compression = inputs . get_value_data ( \"compression\" ) if compression not in [ \"zstd\" , \"lz4\" , \"uncompressed\" ]: raise KiaraProcessingException ( f \"Invalid compression format ' { compression } '. Allowed: 'zstd', 'lz4', 'uncompressed'.\" ) if format != \"feather\" : raise KiaraProcessingException ( f \"Can't export table to format ' { format } ': only 'feather' supported at the moment.\" ) if os . path . exists ( full_path ) and not force_overwrite : raise KiaraProcessingException ( f \"Can't write table to file, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : format , }, \"value_id\" : NO_VALUE_ID_MARKER , \"output_name\" : \"table\" , } outputs . set_value ( \"load_config\" , result )","title":"ExportArrowTable"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.ExportArrowTable.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table object.\" }, \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file to write.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, \"force_overwrite\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether to overwrite an existing file.\" , \"default\" : False , }, \"compression\" : { \"type\" : \"string\" , \"doc\" : \"The compression to use. Use either: 'zstd' (default), 'lz4', or 'uncompressed'.\" , \"default\" : \"zstd\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.ExportArrowTable.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"load_config\" : { \"type\" : \"load_config\" , \"doc\" : \"The configuration to use with kiara to load the saved value.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.LoadArrowTable","text":"Load a table object from disk. Source code in core/table/__init__.py class LoadArrowTable ( KiaraModule ): \"\"\"Load a table object from disk.\"\"\" _module_type_name = \"load\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : from pyarrow import feather base_path = inputs . get_value_data ( \"base_path\" ) rel_path = inputs . get_value_data ( \"rel_path\" ) format = inputs . get_value_data ( \"format\" ) if format != \"feather\" : raise NotImplementedError () path = os . path . join ( base_path , rel_path ) table = feather . read_table ( path ) outputs . set_value ( \"table\" , table )","title":"LoadArrowTable"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.LoadArrowTable.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"base_path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder that contains the table file.\" , }, \"rel_path\" : { \"type\" : \"string\" , \"doc\" : \"The relative path to the table file within base_path.\" , }, \"format\" : { \"type\" : \"string\" , \"doc\" : \"The format of the table file ('feather' or 'parquet').\" , \"default\" : \"feather\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.LoadArrowTable.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The pyarrow table object.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnModule","text":"Map the items of one column of a table onto an array, using another module. Source code in core/table/__init__.py class MapColumnModule ( KiaraModule ): \"\"\"Map the items of one column of a table onto an array, using another module.\"\"\" _config_cls = MapColumnsModuleConfig _module_type_name = \"map_column\" def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result def __init__ ( self , * args , ** kwargs ): self . _child_module : typing . Optional [ KiaraModule ] = None self . _module_input_name : typing . Optional [ str ] = None self . _module_output_name : typing . Optional [ str ] = None super () . __init__ ( * args , ** kwargs ) @property def child_module ( self ) -> KiaraModule : if self . _child_module is not None : return self . _child_module module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) self . _child_module = self . _kiara . create_module ( module_type = module_name , module_config = module_config ) return self . _child_module @property def module_input_name ( self ) -> str : if self . _module_input_name is not None : return self . _module_input_name self . _module_input_name = self . get_config_value ( \"input_name\" ) if self . _module_input_name is None : if len ( list ( self . child_module . input_names )) == 1 : self . _module_input_name = next ( iter ( self . child_module . input_names )) else : raise KiaraProcessingException ( f \"No 'input_name' specified, and configured module has more than one inputs. Please specify an 'input_name' value in your module config, pick one of: { ', ' . join ( self . child_module . input_names ) } \" ) return self . _module_input_name @property def module_output_name ( self ) -> str : if self . _module_output_name is not None : return self . _module_output_name self . _module_output_name = self . get_config_value ( \"output_name\" ) if self . _module_output_name is None : if len ( list ( self . child_module . output_names )) == 1 : self . _module_output_name = next ( iter ( self . child_module . output_names )) else : raise KiaraProcessingException ( f \"No 'output_name' specified, and configured module has more than one outputs. Please specify an 'output_name' value in your module config, pick one of: { ', ' . join ( self . child_module . output_names ) } \" ) return self . _module_output_name def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa table : pa . Table = inputs . get_value_data ( \"table\" ) column_name = inputs . get_value_data ( \"column_name\" ) if column_name not in table . column_names : raise KiaraProcessingException ( f \"Table column ' { column_name } ' not available in table. Available columns: { ', ' . join ( table . column_names ) } .\" ) input_array : pa . Array = table . column ( column_name ) init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"table\" , \"column_name\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) result_list = map_with_module ( input_array , module_input_name = self . module_input_name , module_obj = self . child_module , init_data = init_data , module_output_name = self . module_output_name , ) outputs . set_value ( \"array\" , pa . array ( result_list ))","title":"MapColumnModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to use as input.\" , }, \"column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the table column to run the mapping operation on.\" , }, } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"table\" assert input_name != \"column_name\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnModule.module_instance_doc","text":"Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in core/table/__init__.py def module_instance_doc ( self ) -> str : config : MapColumnsModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( id = \"map_column_child\" , module_type = module_type , module_config = module_config ) type_md = m . get_type_metadata () doc = type_md . documentation . full_doc link = type_md . context . get_url_for_reference ( \"module_doc\" ) if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the rows of an input table onto a new array of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result","title":"module_instance_doc()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnsModuleConfig","text":"Source code in core/table/__init__.py class MapColumnsModuleConfig ( ModuleTypeConfigSchema ): module_type : str = Field ( description = \"The name of the kiara module to use to filter the input data.\" ) module_config : typing . Optional [ typing . Dict [ str , typing . Any ]] = Field ( description = \"The config for the kiara filter module.\" , default_factory = dict ) input_name : typing . Optional [ str ] = Field ( description = \"The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input.\" , default = None , ) output_name : typing . Optional [ str ] = Field ( description = \"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.\" , default = None , )","title":"MapColumnsModuleConfig"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.input_name","text":"The name of the input name of the module which will receive the rows from our input table. Can be omitted if the configured module only has a single input.","title":"input_name"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.module_config","text":"The config for the kiara filter module.","title":"module_config"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.module_type","text":"The name of the kiara module to use to filter the input data.","title":"module_type"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MapColumnsModuleConfig.output_name","text":"The name of the output name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single output.","title":"output_name"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MergeTableModule","text":"Create a table from other tables and/or arrays. Source code in core/table/__init__.py class MergeTableModule ( KiaraModule ): \"\"\"Create a table from other tables and/or arrays.\"\"\" _module_type_name = \"merge\" _config_cls = MergeTableModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_schema : typing . Dict [ str , typing . Any ] = self . get_config_value ( \"input_schema\" ) sources = {} for field_name in input_schema . keys (): sources [ field_name ] = inputs . get_value_data ( field_name ) len_dict = {} arrays = [] column_names = [] for source_key , table_or_column in sources . items (): if isinstance ( table_or_column , pa . Table ): rows = table_or_column . num_rows for name in table_or_column . schema . names : column = table_or_column . column ( name ) arrays . append ( column ) column_names . append ( name ) elif isinstance ( table_or_column , ( pa . Array , pa . ChunkedArray )): rows = len ( table_or_column ) arrays . append ( table_or_column ) column_names . append ( source_key ) else : raise KiaraProcessingException ( f \"Can't merge table: invalid type ' { type ( table_or_column ) } ' for source ' { source_key } '.\" ) len_dict [ source_key ] = rows all_rows = None for source_key , rows in len_dict . items (): if all_rows is None : all_rows = rows else : if all_rows != rows : all_rows = None break if all_rows is None : len_str = \"\" for name , rows in len_dict . items (): len_str = f \" { name } ( { rows } )\" raise KiaraProcessingException ( f \"Can't merge table, sources have different lengths: { len_str } \" ) table = pa . Table . from_arrays ( arrays = arrays , names = column_names ) outputs . set_value ( \"table\" , table )","title":"MergeTableModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MergeTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: input_schema_dict = self . get_config_value ( \"input_schema\" ) return input_schema_dict","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MergeTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/__init__.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MergeTableModuleConfig","text":"Source code in core/table/__init__.py class MergeTableModuleConfig ( ModuleTypeConfigSchema ): input_schema : typing . Dict [ str , typing . Any ] = Field ( description = \"A dict describing the inputs for this merge process.\" )","title":"MergeTableModuleConfig"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.MergeTableModuleConfig.input_schema","text":"A dict describing the inputs for this merge process.","title":"input_schema"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.SampleTableModule","text":"Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. Source code in core/table/__init__.py class SampleTableModule ( SampleValueModule ): \"\"\"Sample a table. Samples are used to randomly select a subset of a dataset, which helps test queries and workflows on smaller versions of the original data, to adjust parameters before a full run. \"\"\" _module_type_name = \"sample\" @classmethod def get_value_type ( cls ) -> str : return \"table\" # def create_input_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return { # \"table\": {\"type\": \"table\", \"doc\": \"The table to sample data from.\"}, # \"sample_size\": { # \"type\": \"integer\", # \"doc\": \"The percentage or number of rows to sample (depending on 'sample_unit' input).\", # } # } # # def create_output_schema( # self, # ) -> typing.Mapping[ # str, typing.Union[ValueSchema, typing.Mapping[str, typing.Any]] # ]: # # return {\"sampled_table\": {\"type\": \"table\", \"doc\": \"A sampled table.\"}} def sample_percent ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= 100 : return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } PERCENT (bernoulli);\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows ( self , value : Value , sample_size : int ): import duckdb import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table query = f \"SELECT * FROM data USING SAMPLE { sample_size } ;\" rel_from_arrow = duckdb . arrow ( table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( \"data\" , query ) result_table : pa . Table = result . fetch_arrow_table () return result_table def sample_rows_from_start ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( 0 , sample_size ) def sample_rows_to_end ( self , value : Value , sample_size : int ): import pyarrow as pa table : pa . Table = value . get_value_data () if sample_size >= len ( table ): return table return table . slice ( len ( table ) - sample_size )","title":"SampleTableModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.SampleTableModule.get_value_type","text":"Return the value type for this sample module. Source code in core/table/__init__.py @classmethod def get_value_type ( cls ) -> str : return \"table\"","title":"get_value_type()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.SaveArrowTableConfig","text":"Source code in core/table/__init__.py class SaveArrowTableConfig ( StoreValueModuleConfig ): compression : str = Field ( description = \"The compression to use when saving the table.\" , default = \"zstd\" )","title":"SaveArrowTableConfig"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.SaveArrowTableConfig.compression","text":"The compression to use when saving the table.","title":"compression"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.StoreArrowTable","text":"Source code in core/table/__init__.py class StoreArrowTable ( StoreValueTypeModule ): _config_cls = SaveArrowTableConfig _module_type_name = \"store\" @classmethod def retrieve_supported_types ( cls ) -> typing . Union [ str , typing . Iterable [ str ]]: return \"table\" def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result","title":"StoreArrowTable"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.StoreArrowTable.store_value","text":"Save the value, and return the load config needed to load it again. Source code in core/table/__init__.py def store_value ( self , value : Value , base_path : str ) -> typing . Dict [ str , typing . Any ]: import pyarrow as pa from pyarrow import feather table : pa . Table = value . get_value_data () full_path : str = os . path . join ( base_path , DEFAULT_SAVE_TABLE_FILE_NAME ) if os . path . exists ( full_path ): raise KiaraProcessingException ( f \"Can't save table, file already exists: { full_path } \" ) os . makedirs ( os . path . dirname ( full_path ), exist_ok = True ) compression = self . get_config_value ( \"compression\" ) feather . write_feather ( table , full_path , compression = compression ) result = { \"module_type\" : \"table.load\" , \"base_path_input_name\" : \"base_path\" , \"inputs\" : { \"base_path\" : os . path . dirname ( full_path ), \"rel_path\" : os . path . basename ( full_path ), \"format\" : \"feather\" , }, \"output_name\" : \"table\" , } return result","title":"store_value()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.TableConversionModuleConfig","text":"Source code in core/table/__init__.py class TableConversionModuleConfig ( CreateValueModuleConfig ): ignore_errors : bool = Field ( description = \"Whether to ignore convert errors and omit the failed items.\" , default = False , )","title":"TableConversionModuleConfig"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.TableConversionModuleConfig.ignore_errors","text":"Whether to ignore convert errors and omit the failed items.","title":"ignore_errors"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.TableMetadataModule","text":"Extract metadata from a table object. Source code in core/table/__init__.py class TableMetadataModule ( ExtractMetadataModule ): \"\"\"Extract metadata from a table object.\"\"\" _module_type_name = \"metadata\" @classmethod def _get_supported_types ( cls ) -> str : return \"table\" @classmethod def get_metadata_key ( cls ) -> str : return \"table\" def _get_metadata_schema ( self , type : str ) -> typing . Union [ str , typing . Type [ BaseModel ]]: return TableMetadata def extract_metadata ( self , value : Value ) -> typing . Mapping [ str , typing . Any ]: import pyarrow as pa table : pa . Table = value . get_value_data () table_schema = {} for name in table . schema . names : field = table . schema . field ( name ) md = field . metadata _type = field . type if not md : md = { \"arrow_type_id\" : _type . id , } _d = { \"type_name\" : str ( _type ), \"metadata\" : md , } table_schema [ name ] = _d return { \"column_names\" : table . column_names , \"column_schema\" : table_schema , \"rows\" : table . num_rows , \"size\" : table . nbytes , }","title":"TableMetadataModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.filter","text":"","title":"filter"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.filter.CreateFilteredTableModule","text":"Filter a table using a mask array. Source code in core/table/filter.py class CreateFilteredTableModule ( KiaraModule ): \"\"\"Filter a table using a mask array.\"\"\" _module_type_name = \"with_mask\" _config_cls = TableFilterModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered )","title":"CreateFilteredTableModule"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.filter.CreateFilteredTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.filter.CreateFilteredTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query","text":"","title":"query"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableGraphQL","text":"Execute a graphql aggregation query against an (Arrow) table. References https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } Source code in core/table/query.py class QueryTableGraphQL ( KiaraModule ): \"\"\"Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } \"\"\" _module_type_name = \"graphql\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import vaex table = inputs . get_value_data ( \"table\" ) query = inputs . get_value_data ( \"query\" ) df = vaex . from_arrow_table ( table ) result = df . graphql . execute ( query ) outputs . set_value ( \"query_result\" , result . to_dict ()[ \"data\" ])","title":"QueryTableGraphQL"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableGraphQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableGraphQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableSQL","text":"Execute a sql query against an (Arrow) table. Source code in core/table/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryTableSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import duckdb if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) _relation_name : str = inputs . get_value_data ( \"relation_name\" ) else : _query = self . get_config_value ( \"query\" ) _relation_name = self . get_config_value ( \"relation_name\" ) if _relation_name . upper () in RESERVED_SQL_KEYWORDS : raise KiaraProcessingException ( f \"Invalid relation name ' { _relation_name } ': this is a reserved sql keyword, please select a different name.\" ) _table = inputs . get_value_data ( \"table\" ) rel_from_arrow = duckdb . arrow ( _table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( _relation_name , _query ) outputs . set_value ( \"query_result\" , result . fetch_arrow_table ())","title":"QueryTableSQL"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableSQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableSQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableSQLModuleConfig","text":"Source code in core/table/query.py class QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) relation_name : typing . Optional [ str ] = Field ( description = \"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\" , default = \"data\" , )","title":"QueryTableSQLModuleConfig"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableSQLModuleConfig.query","text":"The query to execute. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.query.QueryTableSQLModuleConfig.relation_name","text":"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.","title":"relation_name"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.utils","text":"","title":"utils"},{"location":"reference/kiara_modules/core/table/__init__/#kiara_modules.core.table.utils.create_sqlite_schema_data_from_arrow_table","text":"Create a sql schema statement from an Arrow table object. Parameters: Name Type Description Default table pa.Table the Arrow table object required column_map Optional[Mapping[str, str]] a map that contains column names that should be changed in the new table None index_columns Optional[Iterable[str]] a list of column names (after mapping) to create module_indexes for None extra_column_info Optional[Mapping[str, Iterable[str]]] a list of extra schema instructions per column name (after mapping) None Source code in core/table/utils.py def create_sqlite_schema_data_from_arrow_table ( table : \"pa.Table\" , column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , index_columns : typing . Optional [ typing . Iterable [ str ]] = None , extra_column_info : typing . Optional [ typing . Mapping [ str , typing . Iterable [ str ]] ] = None , ) -> SqliteTableSchema : \"\"\"Create a sql schema statement from an Arrow table object. Arguments: table: the Arrow table object column_map: a map that contains column names that should be changed in the new table index_columns: a list of column names (after mapping) to create module_indexes for extra_column_info: a list of extra schema instructions per column name (after mapping) \"\"\" columns = convert_arrow_column_types_to_sqlite ( table = table ) if column_map is None : column_map = {} if extra_column_info is None : extra_column_info = {} temp : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if index_columns is None : index_columns = [] for cn , data in columns . items (): if cn in column_map . keys (): new_key = column_map [ cn ] else : new_key = cn temp_data = dict ( data ) if new_key in extra_column_info . keys (): temp_data [ \"extra_column_info\" ] = extra_column_info [ new_key ] else : temp_data [ \"extra_column_info\" ] = [ \"\" ] if cn in index_columns : temp_data [ \"create_index\" ] = True temp [ new_key ] = temp_data columns = temp if not columns : raise Exception ( \"Resulting table schema has no columns.\" ) else : for ic in index_columns : if ic not in columns . keys (): raise Exception ( f \"Can't create schema, requested index column name not available: { ic } \" ) return SqliteTableSchema ( columns = columns , column_map = column_map )","title":"create_sqlite_schema_data_from_arrow_table()"},{"location":"reference/kiara_modules/core/table/filter/","text":"CreateFilteredTableModule ( KiaraModule ) \u00b6 Filter a table using a mask array. Source code in core/table/filter.py class CreateFilteredTableModule ( KiaraModule ): \"\"\"Filter a table using a mask array.\"\"\" _module_type_name = \"with_mask\" _config_cls = TableFilterModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered ) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs","title":"filter"},{"location":"reference/kiara_modules/core/table/filter/#kiara_modules.core.table.filter.CreateFilteredTableModule","text":"Filter a table using a mask array. Source code in core/table/filter.py class CreateFilteredTableModule ( KiaraModule ): \"\"\"Filter a table using a mask array.\"\"\" _module_type_name = \"with_mask\" _config_cls = TableFilterModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import pyarrow as pa input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered )","title":"CreateFilteredTableModule"},{"location":"reference/kiara_modules/core/table/filter/#kiara_modules.core.table.filter.CreateFilteredTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/filter/#kiara_modules.core.table.filter.CreateFilteredTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/filter.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/query/","text":"QueryTableGraphQL ( KiaraModule ) \u00b6 Execute a graphql aggregation query against an (Arrow) table. References https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } Source code in core/table/query.py class QueryTableGraphQL ( KiaraModule ): \"\"\"Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } \"\"\" _module_type_name = \"graphql\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import vaex table = inputs . get_value_data ( \"table\" ) query = inputs . get_value_data ( \"query\" ) df = vaex . from_arrow_table ( table ) result = df . graphql . execute ( query ) outputs . set_value ( \"query_result\" , result . to_dict ()[ \"data\" ]) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs QueryTableSQL ( KiaraModule ) \u00b6 Execute a sql query against an (Arrow) table. Source code in core/table/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryTableSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import duckdb if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) _relation_name : str = inputs . get_value_data ( \"relation_name\" ) else : _query = self . get_config_value ( \"query\" ) _relation_name = self . get_config_value ( \"relation_name\" ) if _relation_name . upper () in RESERVED_SQL_KEYWORDS : raise KiaraProcessingException ( f \"Invalid relation name ' { _relation_name } ': this is a reserved sql keyword, please select a different name.\" ) _table = inputs . get_value_data ( \"table\" ) rel_from_arrow = duckdb . arrow ( _table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( _relation_name , _query ) outputs . set_value ( \"query_result\" , result . fetch_arrow_table ()) create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ) pydantic-model \u00b6 Source code in core/table/query.py class QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) relation_name : typing . Optional [ str ] = Field ( description = \"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\" , default = \"data\" , ) query : str pydantic-field \u00b6 The query to execute. If not specified, the user will be able to provide their own. relation_name : str pydantic-field \u00b6 The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableGraphQL","text":"Execute a graphql aggregation query against an (Arrow) table. References https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } Source code in core/table/query.py class QueryTableGraphQL ( KiaraModule ): \"\"\"Execute a graphql aggregation query against an (Arrow) table. References: - https://vaex.io/docs/example_graphql.html Examples: An example for a query could be: { df(where: { Language: {_eq: \"German\"} } ) { row(limit: 10) { Label City } } } \"\"\" _module_type_name = \"graphql\" def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import vaex table = inputs . get_value_data ( \"table\" ) query = inputs . get_value_data ( \"query\" ) df = vaex . from_arrow_table ( table ) result = df . graphql . execute ( query ) outputs . set_value ( \"query_result\" , result . to_dict ()[ \"data\" ])","title":"QueryTableGraphQL"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableGraphQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Mapping [ str , typing . Any ] = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query.\" }, \"query\" : { \"type\" : \"string\" , \"doc\" : \"The query.\" }, } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableGraphQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs : typing . Mapping [ str , typing . Any ] = { \"query_result\" : { \"type\" : \"dict\" , \"doc\" : \"The query result.\" } } return outputs","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableSQL","text":"Execute a sql query against an (Arrow) table. Source code in core/table/query.py class QueryTableSQL ( KiaraModule ): \"\"\"Execute a sql query against an (Arrow) table.\"\"\" _module_type_name = \"sql\" _config_cls = QueryTableSQLModuleConfig def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }} def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : import duckdb if self . get_config_value ( \"query\" ) is None : _query : str = inputs . get_value_data ( \"query\" ) _relation_name : str = inputs . get_value_data ( \"relation_name\" ) else : _query = self . get_config_value ( \"query\" ) _relation_name = self . get_config_value ( \"relation_name\" ) if _relation_name . upper () in RESERVED_SQL_KEYWORDS : raise KiaraProcessingException ( f \"Invalid relation name ' { _relation_name } ': this is a reserved sql keyword, please select a different name.\" ) _table = inputs . get_value_data ( \"table\" ) rel_from_arrow = duckdb . arrow ( _table ) result : duckdb . DuckDBPyResult = rel_from_arrow . query ( _relation_name , _query ) outputs . set_value ( \"query_result\" , result . fetch_arrow_table ())","title":"QueryTableSQL"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableSQL.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[input_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this input]\", \"optional*': [boolean whether this input is optional or required (defaults to 'False')] \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to query\" , } } if self . get_config_value ( \"query\" ) is None : inputs [ \"query\" ] = { \"type\" : \"string\" , \"doc\" : \"The query.\" } inputs [ \"relation_name\" ] = { \"type\" : \"string\" , \"doc\" : \"The name the table is referred to in the sql query.\" , \"default\" : \"data\" , } return inputs","title":"create_input_schema()"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableSQL.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional): { \"[output_field_name]: { \"type\": \"[value_type]\", \"doc*\": \"[a description of this output]\" \"[other_input_field_name]: { \"type: ... ... } Source code in core/table/query.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"query_result\" : { \"type\" : \"table\" , \"doc\" : \"The query result.\" }}","title":"create_output_schema()"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableSQLModuleConfig","text":"Source code in core/table/query.py class QueryTableSQLModuleConfig ( ModuleTypeConfigSchema ): query : typing . Optional [ str ] = Field ( description = \"The query to execute. If not specified, the user will be able to provide their own.\" , default = None , ) relation_name : typing . Optional [ str ] = Field ( description = \"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.\" , default = \"data\" , )","title":"QueryTableSQLModuleConfig"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableSQLModuleConfig.query","text":"The query to execute. If not specified, the user will be able to provide their own.","title":"query"},{"location":"reference/kiara_modules/core/table/query/#kiara_modules.core.table.query.QueryTableSQLModuleConfig.relation_name","text":"The name the table is referred to in the sql query. If not specified, the user will be able to provide their own.","title":"relation_name"},{"location":"reference/kiara_modules/core/table/utils/","text":"create_sqlite_schema_data_from_arrow_table ( table , column_map = None , index_columns = None , extra_column_info = None ) \u00b6 Create a sql schema statement from an Arrow table object. Parameters: Name Type Description Default table pa.Table the Arrow table object required column_map Optional[Mapping[str, str]] a map that contains column names that should be changed in the new table None index_columns Optional[Iterable[str]] a list of column names (after mapping) to create module_indexes for None extra_column_info Optional[Mapping[str, Iterable[str]]] a list of extra schema instructions per column name (after mapping) None Source code in core/table/utils.py def create_sqlite_schema_data_from_arrow_table ( table : \"pa.Table\" , column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , index_columns : typing . Optional [ typing . Iterable [ str ]] = None , extra_column_info : typing . Optional [ typing . Mapping [ str , typing . Iterable [ str ]] ] = None , ) -> SqliteTableSchema : \"\"\"Create a sql schema statement from an Arrow table object. Arguments: table: the Arrow table object column_map: a map that contains column names that should be changed in the new table index_columns: a list of column names (after mapping) to create module_indexes for extra_column_info: a list of extra schema instructions per column name (after mapping) \"\"\" columns = convert_arrow_column_types_to_sqlite ( table = table ) if column_map is None : column_map = {} if extra_column_info is None : extra_column_info = {} temp : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if index_columns is None : index_columns = [] for cn , data in columns . items (): if cn in column_map . keys (): new_key = column_map [ cn ] else : new_key = cn temp_data = dict ( data ) if new_key in extra_column_info . keys (): temp_data [ \"extra_column_info\" ] = extra_column_info [ new_key ] else : temp_data [ \"extra_column_info\" ] = [ \"\" ] if cn in index_columns : temp_data [ \"create_index\" ] = True temp [ new_key ] = temp_data columns = temp if not columns : raise Exception ( \"Resulting table schema has no columns.\" ) else : for ic in index_columns : if ic not in columns . keys (): raise Exception ( f \"Can't create schema, requested index column name not available: { ic } \" ) return SqliteTableSchema ( columns = columns , column_map = column_map )","title":"utils"},{"location":"reference/kiara_modules/core/table/utils/#kiara_modules.core.table.utils.create_sqlite_schema_data_from_arrow_table","text":"Create a sql schema statement from an Arrow table object. Parameters: Name Type Description Default table pa.Table the Arrow table object required column_map Optional[Mapping[str, str]] a map that contains column names that should be changed in the new table None index_columns Optional[Iterable[str]] a list of column names (after mapping) to create module_indexes for None extra_column_info Optional[Mapping[str, Iterable[str]]] a list of extra schema instructions per column name (after mapping) None Source code in core/table/utils.py def create_sqlite_schema_data_from_arrow_table ( table : \"pa.Table\" , column_map : typing . Optional [ typing . Mapping [ str , str ]] = None , index_columns : typing . Optional [ typing . Iterable [ str ]] = None , extra_column_info : typing . Optional [ typing . Mapping [ str , typing . Iterable [ str ]] ] = None , ) -> SqliteTableSchema : \"\"\"Create a sql schema statement from an Arrow table object. Arguments: table: the Arrow table object column_map: a map that contains column names that should be changed in the new table index_columns: a list of column names (after mapping) to create module_indexes for extra_column_info: a list of extra schema instructions per column name (after mapping) \"\"\" columns = convert_arrow_column_types_to_sqlite ( table = table ) if column_map is None : column_map = {} if extra_column_info is None : extra_column_info = {} temp : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = {} if index_columns is None : index_columns = [] for cn , data in columns . items (): if cn in column_map . keys (): new_key = column_map [ cn ] else : new_key = cn temp_data = dict ( data ) if new_key in extra_column_info . keys (): temp_data [ \"extra_column_info\" ] = extra_column_info [ new_key ] else : temp_data [ \"extra_column_info\" ] = [ \"\" ] if cn in index_columns : temp_data [ \"create_index\" ] = True temp [ new_key ] = temp_data columns = temp if not columns : raise Exception ( \"Resulting table schema has no columns.\" ) else : for ic in index_columns : if ic not in columns . keys (): raise Exception ( f \"Can't create schema, requested index column name not available: { ic } \" ) return SqliteTableSchema ( columns = columns , column_map = column_map )","title":"create_sqlite_schema_data_from_arrow_table()"},{"location":"value_types/","text":"xxxxxxx","title":"Index"},{"location":"value_types/SUMMARY/","text":"array boolean bytes database date dict file file_bundle float integer list renderables string table","title":"SUMMARY"},{"location":"value_types/array/","text":"array \u00b6 type_name array documentation An Apache arrow array. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name ArrayType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.ArrayType","title":"array"},{"location":"value_types/array/#kiara_info.value_types.array","text":"type_name array documentation An Apache arrow array. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name ArrayType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.ArrayType","title":"array"},{"location":"value_types/boolean/","text":"boolean \u00b6 type_name boolean documentation A boolean. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name BooleanType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.BooleanType","title":"boolean"},{"location":"value_types/boolean/#kiara_info.value_types.boolean","text":"type_name boolean documentation A boolean. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name BooleanType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.BooleanType","title":"boolean"},{"location":"value_types/bytes/","text":"bytes \u00b6 type_name bytes documentation An array of bytes. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name BytesType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.BytesType","title":"bytes"},{"location":"value_types/bytes/#kiara_info.value_types.bytes","text":"type_name bytes documentation An array of bytes. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name BytesType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.BytesType","title":"bytes"},{"location":"value_types/database/","text":"database \u00b6 type_name database documentation A database, containing one or several tables. This is backed by sqlite databases. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DatabaseType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.DatabaseTy\u2026","title":"database"},{"location":"value_types/database/#kiara_info.value_types.database","text":"type_name database documentation A database, containing one or several tables. This is backed by sqlite databases. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DatabaseType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.DatabaseTy\u2026","title":"database"},{"location":"value_types/date/","text":"date \u00b6 type_name date documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DateType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.DateType","title":"date"},{"location":"value_types/date/#kiara_info.value_types.date","text":"type_name date documentation A date. Internally, this will always be represented as a Python datetime object. Iff provided as input, it can also be as string, in which case the dateutils.parser.parse method will be used to parse the string into a datetime object. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DateType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.DateType","title":"date"},{"location":"value_types/dict/","text":"dict \u00b6 type_name dict documentation A dict-like object. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DictType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.DictType","title":"dict"},{"location":"value_types/dict/#kiara_info.value_types.dict","text":"type_name dict documentation A dict-like object. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name DictType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.DictType","title":"dict"},{"location":"value_types/file/","text":"file \u00b6 type_name file documentation A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name FileType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.FileType","title":"file"},{"location":"value_types/file/#kiara_info.value_types.file","text":"type_name file documentation A representation of a file. It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name FileType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.FileType","title":"file"},{"location":"value_types/file_bundle/","text":"file_bundle \u00b6 type_name file_bundle documentation A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name FileBundleType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.FileBundle\u2026","title":"file_bundle"},{"location":"value_types/file_bundle/#kiara_info.value_types.file_bundle","text":"type_name file_bundle documentation A representation of a set of files (folder, archive, etc.). It is recommended to 'onboard' files before working with them, otherwise metadata consistency can not be guaranteed. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name FileBundleType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.FileBundle\u2026","title":"file_bundle"},{"location":"value_types/float/","text":"float \u00b6 type_name float documentation A float. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name FloatType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.FloatType","title":"float"},{"location":"value_types/float/#kiara_info.value_types.float","text":"type_name float documentation A float. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name FloatType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.FloatType","title":"float"},{"location":"value_types/integer/","text":"integer \u00b6 type_name integer documentation An integer. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name IntegerType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.IntegerType","title":"integer"},{"location":"value_types/integer/#kiara_info.value_types.integer","text":"type_name integer documentation An integer. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name IntegerType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.IntegerType","title":"integer"},{"location":"value_types/list/","text":"list \u00b6 type_name list documentation A list-like object. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name ListType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.ListType","title":"list"},{"location":"value_types/list/#kiara_info.value_types.list","text":"type_name list documentation A list-like object. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name ListType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.ListType","title":"list"},{"location":"value_types/renderables/","text":"renderables \u00b6 type_name renderables documentation A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name RenderablesType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.Renderable\u2026","title":"renderables"},{"location":"value_types/renderables/#kiara_info.value_types.renderables","text":"type_name renderables documentation A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name RenderablesType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.Renderable\u2026","title":"renderables"},{"location":"value_types/string/","text":"string \u00b6 type_name string documentation A string. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name StringType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.StringType","title":"string"},{"location":"value_types/string/#kiara_info.value_types.string","text":"type_name string documentation A string. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name StringType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.StringType","title":"string"},{"location":"value_types/table/","text":"table \u00b6 type_name table documentation A table. Internally, this is backed by the Apache Arrow Table class. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name TableType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.TableType","title":"table"},{"location":"value_types/table/#kiara_info.value_types.table","text":"type_name table documentation A table. Internally, this is backed by the Apache Arrow Table class. origin Authors Markus Binsteiner (markus@frkl.io) context Tags core Labels package : kiara_modules.core References source_repo : https://github.com/DHARPA-Project/kiara_mo\u2026 documentation : https://dharpa.org/kiara_modules.core/ python_class class_name TableType module_name kiara_modules.core.value_types full_name kiara_modules.core.value_types.TableType","title":"table"}]}